[
  {
    "id": "0FQUuOOhlewGFcKpUzDN",
    "description": "state management akita store select query",
    "difficulty": "middle",
    "type": "question",
    "popularity": "3",
    "competence": [
      "common questions",
      "javascript",
      "typescript",
      "angular",
      "frontend"
    ],
    "tableIndex": 1,
    "answer": {
      "code": [],
      "text": [
        "Akita is a simple and an effective state management solution for Angular applications. It is built on top of RxJS and inspired by models like Flux and Redux. Compared to other state management systems, the most attractive feature of Akita is its simplicity. It saves you the hassle of writing boilerplate code to manage the application state.\n\nAKITA\nThe Model - The model is a representation of an entity. Akita’s recommended creating both a type and a factory function in charge of building the entity.\nStore\nEntity Store - You can think of an entity store as a table in a database, where each table represents a flat collection of entities.\nQuery\nset(): Replace current collection with the provided collection, and resets the active entity\nadd(): Add an entity or entities to the store\nupdate(): Update an entity or entities in the store\nremove(): Remove one or more entities from the store\nupsert(): Insert or update an entity. Creates a new entity when no entity matches the id; otherwise, it performs an update\nEntity Query - You can think of the query as being similar to database queries. Its constructor function receives as parameters its own store and possibly other query classes.\nselectAll(): Select the entire store’s entity collection\nselectMany(): Select multiple entities from the store\nselectEntity(): Select an entity or a slice of an entity\n"
      ],
      "link": [
        "https://medium.com/angular-in-depth/state-management-in-angular-using-akita-82f117d282dd",
        "https://netbasal.com/introducing-akita-a-new-state-management-pattern-for-angular-applications-f2f0fab5a8",
        "https://medium.com/swlh/angular-state-management-with-akita-b4c5439c1ab5",
        "https://github.com/datorama/akita",
        "https://github.com/sarindufit/angular-akita-example"
      ]
    },
    "question": "Что такое Akita?"
  },
  {
    "id": "0G51IYLNXpl9CdfaxZna",
    "type": "question",
    "tableIndex": 1,
    "popularity": "4",
    "answer": {
      "text": [
        "И .call, и .apply используются для вызова функций (немедленно), а также первый параметр будет использоваться как значение this внутри функции.\n\nА разница в том, что .call в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как .apply в качестве следующих аргументов принимает массив аргументов.\n\nbind возвращает новую функцию с привязанным обьектом."
      ],
      "link": [
        "https://www.w3docs.com/snippets/javascript/javascript-bind-vs-apply-and-call.html"
      ],
      "code": [
        " function add(a, b) { \n     return a + b;\n }\n console.log(add.call(null, 1, 2)); // 3\n console.log(add.apply(null, [1, 2])); // 3",
        "let p1 = {\n  firstName: 'John',\n  lastName: 'Smith'\n};\nlet p2 = {\n  firstName: 'Ann',\n  lastName: 'Brown'\n};\nfunction sayWelcome(greeting) {\n  console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);\n}\nsayWelcome.call(p1, 'Welcome'); // Welcome John Smith\nsayWelcome.call(p2, 'Welcome'); // Welcome Ann Brown",
        "let p1 = {\n  firstName: 'John',\n  lastName: 'Smith'\n};\nlet p2 = {\n  firstName: 'Ann',\n  lastName: 'Brown'\n};\nfunction sayWelcome(greeting) {\n  console.log(greeting + ' ' + this.firstName + ' ' + this.lastName);\n}\nsayWelcome.apply(p1, ['Welcome']); // Welcome John Smith\nsayWelcome.apply(p2, ['Welcome']); // Welcome Ann Brown",
        "let p1 = {\n  firstName: 'John',\n  lastName: 'Smith'\n};\nlet p2 = {\n  firstName: 'Ann',\n  lastName: 'Brown'\n};\nfunction sayWelcome() {\n  console.log('Welcome ' + this.firstName + ' ' + this.lastName);\n}\nlet sayWelcomeJohn = sayWelcome.bind(p1);\nlet sayWelcomeAnn = sayWelcome.bind(p2);\nsayWelcomeJohn(); // Welcome John Smith\nsayWelcomeAnn(); // Welcome Ann Brown"
      ]
    },
    "competence": ["javascript", "typescript"],
    "description": "Поясните пожалуйста в чем разница? Еще раз, для самых умненьких. “this” refresher",
    "_id": { "$oid": "60de0704e2c8c53194aee43c" },
    "difficulty": "junior",
    "question": "В чем разница между `.call`, `.apply`, `.bind`?"
  },
  {
    "id": "0YISGPZECpl3gH48EaYY",
    "description": "Написать свои функции смены контекста. Ваниллу.",
    "type": "exercise",
    "question": "Реализовать аналог .bind, .call, .apply.",
    "_id": { "$oid": "60de0704e2c8c53194aee4b3" },
    "popularity": "4",
    "tableIndex": 2,
    "difficulty": "middle",
    "answer": {
      "code": [
        " Function.prototype.bind = function(context, ...argsBind) {\n   const fn = this;\n   return function (...args) {\n     return fn.apply(context, argsBind.concat(args))\n   };\n };"
      ],
      "link": [
        "https://blog.ankuranand.com/2018/06/15/Implement-your-own-call-apply-and-bind-method-in-JavaScript/",
        "https://dev.to/kamaal/understanding-by-making-your-own-javascript-call-apply-bind-5238",
        "https://www.talkinghightech.com/en/javascript-interview-questions-write-your-own-bind-function/"
      ],
      "text": [
        "С появлением Rest parameters реализация этой задачи стала чуть проще, чем прежде, когда приходилось делать arguments.slice. (0)\n\n\n "
      ]
    },
    "competence": ["javascript"]
  },
  {
    "id": "0ZmSAz5b4GyZS80JvEsR",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "hot module replacement (настройка в вебпаке в dev-server чтобы стенд обновлялся после изменения файла). Обновляется не весь проект, а только измененный модуль. Не используется в продакшене."
      ]
    },
    "popularity": "3",
    "question": "Что такое hmr?",
    "competence": ["javascript"],
    "difficulty": "middle",
    "type": "question",
    "tableIndex": 3,
    "description": "Hot Module Replacement"
  },
  {
    "id": "0kJkRLexcPymiOnYMXyK",
    "competence": ["common questions"],
    "difficulty": "junior",
    "tableIndex": 4,
    "answer": {
      "link": [
        "https://habr.com/ru/company/ruvds/blog/332384/",
        "https://flaviocopes.com/javascript-memoization/",
        "https://medium.com/nuances-of-programming/%D0%BC%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BA%D0%B0%D0%BA-%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D1%83%D1%81%D0%BA%D0%BE%D1%80%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B2%D0%B5%D0%B1-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-f2db2aa61e33",
        "https://whatthefuck.is/memoization"
      ],
      "text": [
        "Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.",
        "Сохранение результата функций при определенных аргументах, что позволяет не выполнять\n функцию снова, если эти аргументы использованы."
      ],
      "code": [
        " // простая функция, прибавляющая 10 к переданному ей числу\n const add = (n) =&gt; (n + 10);\n add(9);\n\n // аналогичная функция с мемоизацией\n const memoizedAdd = () => { \n   let cache = {};\n   return (n) = > { \n     if (n in cache) {\n     console.log('Fetching from cache');\n     return cache[n];\n     }\n   else {\n     console.log('Calculating result');\n     let result = n + 10;\n     cache[n] = result;\n     return result;\n     }\n   }\n }\n\n // эту функцию возвратит memoizedAdd\n const newAdd = memoizedAdd();\n console.log(newAdd(9)); // вычислено\n console.log(newAdd(9)); // взято из кэша"
      ]
    },
    "question": "Мемоизация",
    "type": "question",
    "description": "Расскажите про мемоизацию",
    "_id": { "$oid": "60de0704e2c8c53194aee4d3" },
    "popularity": "3"
  },
  {
    "id": "1OgxKEHGIf66C5sbhHzQ",
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee4d6" },
    "competence": ["javascript"],
    "description": "Как работает javascript движок?",
    "type": "question",
    "question": "Что такое event loop, microtasks, macrotasks, heap memory, stack memory?",
    "difficulty": "middle",
    "tableIndex": 5,
    "answer": {
      "text": [
        "JS - однопоточный асинхронный язык. Но можно создать иллюзию того, что вещи выполняются синхронно. Используются сущности:\n1.Event Loop - бесконечно крутится и проверяет списки-стэки необходимых для выполнения функций.\n2. Stack - очередь вызовов. Первый пришел - первый вышел. Является очередью макротасков, которые выполняются по очереди. После выполнения каждой макротаски просматривается очередь микротасков.\n3. Microtasks queue - очередь микротасков, проверяется каждый раз после выполнения макротаски. После выполнения всей очереди происходит ререндер и эвент луп приступает к следующей задаче. Можно самолично закидывать задачи в микротаски с функцией queueMicrotask(() => {}). \n4. Heap - куча, в которой все хранится. Переменные и все аткое.\n5. WebAPI - функции и возможности, которые предоставляет браузер или другая среда выполнения и не входит в js. Например, setTimeout()."
      ],
      "code": [],
      "link": [
        "https://javascript.info/event-loop",
        "https://www.geeksforgeeks.org/what-is-an-event-loop-in-javascript/",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop"
      ]
    }
  },
  {
    "id": "26dIqjffpn2el90iZGeG",
    "tableIndex": 5,
    "difficulty": "beginner",
    "question": "Что такое callback hell?",
    "_id": { "$oid": "60de0704e2c8c53194aee4f4" },
    "description": "Объясните с примером callback hell.",
    "type": "question",
    "popularity": "4",
    "answer": {
      "text": [
        "Цепочка call back функций с большой вложенностью. Из-за большой вложенности ничего не понятно. Происходит большая путаница. Трудно читается. Легко допустить ошибки. Легко пропустить скобки."
      ],
      "code": [
        "fs.readdir(source, function (err, files) {\n  if (err) {\n    console.log('Error finding files: ' + err)\n  } else {\n    files.forEach(function (filename, fileIndex) {\n      console.log(filename)\n      gm(source + filename).size(function (err, values) {\n        if (err) {\n          console.log('Error identifying file size: ' + err)\n        } else {\n          console.log(filename + ' : ' + values)\n          aspect = (values.width / values.height)\n          widths.forEach(function (width, widthIndex) {\n            height = Math.round(width / aspect)\n            console.log('resizing ' + filename + 'to ' + height + 'x' + height)\n            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {\n              if (err) console.log('Error writing file: ' + err)\n            })\n          }.bind(this))\n        }\n      })\n    })\n  }\n})"
      ],
      "link": [
        "http://callbackhell.com/",
        "https://www.geeksforgeeks.org/what-is-callback-hell-in-node-js/"
      ]
    },
    "competence": ["common questions", "javascript"]
  },
  {
    "id": "2D6JNpeGnXuCLBZ0oqkN",
    "difficulty": "middle",
    "answer": {
      "text": ["Есть два способа:\n1. eval(\"\"\n2. Писать свою функцию.\n\n"],
      "code": [],
      "link": []
    },
    "question": "Посчитайте строку \"=1+3\" в js?",
    "competence": ["javascript"],
    "tableIndex": 7,
    "description": "Дан пример в строку, как решить.",
    "type": "exercise",
    "popularity": "4"
  },
  {
    "id": "2RMgFjtKmCcSKl99wXq1",
    "answer": {
      "text": [
        "Это поведенческий шаблон проектирования, который обеспечивает цепочку слабо связанных объектов. Каждый из этих объектов может действовать или обрабатывать запрос клиента.\n\nХорошим примером шаблона цепочки ответственности является всплывающее окно события в DOM, в котором событие распространяется через ряд вложенных элементов DOM, к одному из которых может быть прикреплен «прослушиватель событий», который прослушивает событие и действует в соответствии с ним.\n\nВ этом примере мы создаем класс CumulativeSum, который может быть создан с необязательным начальным значением. У него есть метод add, который добавляет переданное значение к атрибуту суммы объекта и возвращает сам объект, чтобы разрешить цепочку вызовов метода add.\nЭто распространенный шаблон, который можно увидеть и в jQuery, где почти любой вызов метода для объекта jQuery возвращает объект jQuery, так что вызовы методов могут быть объединены в цепочку."
      ],
      "code": [
        "class CumulativeSum {\n  constructor(intialValue = 0) {\n    this.sum = intialValue;\n  }\n\n  add(value) {\n    this.sum += value;\n    return this;\n  }\n}\n\n// usage\nconst sum1 = new CumulativeSum();\nconsole.log(sum1.add(10).add(2).add(50).sum); // 62\n\n\nconst sum2 = new CumulativeSum(10);\nconsole.log(sum2.add(10).add(20).add(5).sum); // 45"
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ]
    },
    "competence": ["common questions", "javascript"],
    "question": "Что такое Chain of Responsibility Pattern в Javascript?",
    "difficulty": "middle",
    "description": "Chain of Responsibility Pattern - цепочка ответственности",
    "popularity": "4",
    "type": "question"
  },
  {
    "id": "2nXq0sD1XsmCTgAJD8Sw",
    "popularity": "4",
    "tableIndex": 8,
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "text": [
        " Основное различие между .forEach и .map() состоит в том, что .map()\n возвращает новый массив. Если вам нужен результат, но вы не хотите изменять\n исходный массив, .map() — очевидный выбор. Если вам просто нужно перебрать\n массив, то стоит воспользоваться forEach.\n\n forEach\n Перебирает элементы в массиве.\n Вызывает callback-функцию для каждого элемента\n Не возвращает значение.\n\n map\n Перебирает элементы в массиве.\n “Сопоставляет” каждый элемент с новым элементом, вызывая функцию для каждого элемента, создавая в результате новый массив."
      ],
      "link": ["https://codeburst.io/javascript-map-vs-foreach-f38111822c0f"],
      "code": [
        "const a = [1, 2, 3];\nconst doubled = a.forEach((num, index) => {\n   // Делаем что-либо с num и/или index.\n});\n // doubled = undefined\n\n\n\nconst a = [1, 2, 3];\n const doubled = a.map(num => {\n   return num * 2;\n });\n // doubled = [2, 4, 6]"
      ]
    },
    "description": "И в каких случаях каждый из них используется?",
    "_id": { "$oid": "60de0704e2c8c53194aee437" },
    "question": "Можете ли вы описать основное различие между циклом `.forEach` и циклом `.map()`?",
    "competence": ["javascript", "typescript"]
  },
  {
    "id": "2w2HqojVSylNibVNt0MK",
    "question": "Что такое Decorator Pattern в Javascript?",
    "difficulty": "middle",
    "competence": ["common questions", "javascript"],
    "description": "Decorator Pattern",
    "popularity": "4",
    "type": "question",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15",
        "https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841",
        "https://tc39.es/proposal-decorators/"
      ],
      "text": [
        "Классический структурный паттерн. Берет определенный класс или функцию, оборачивает ее и добавляет дополнительную функциональность. Фокус в том, что первоначальный класс остается без изменений. Благодаря этому паттерну легко добавлять новую функциональность, не трогая старую."
      ],
      "code": [
        "class Book {\n  constructor(title, author, price) {\n    this._title = title;\n    this._author = author;\n    this.price = price;\n  }\n\n  getDetails() {\n    return `${this._title} by ${this._author}`;\n  }\n}\n\n// decorator 1\nfunction giftWrap(book) {\n  book.isGiftWrapped = true;\n  book.unwrap = function() {\n    return `Unwrapped ${book.getDetails()}`;\n  };\n\n  return book;\n}\n\n// decorator 2\nfunction hardbindBook(book) {\n  book.isHardbound = true;\n  book.price += 5;\n  return book;\n}\n\n// usage\nconst alchemist = giftWrap(new Book('The Alchemist', 'Paulo Coelho', 10));\n\nconsole.log(alchemist.isGiftWrapped); // true\nconsole.log(alchemist.unwrap()); // 'Unwrapped The Alchemist by Paulo Coelho'\n\nconst inferno = hardbindBook(new Book('Inferno', 'Dan Brown', 15));\n\nconsole.log(inferno.isHardbound); // true\nconsole.log(inferno.price); // 20"
      ]
    }
  },
  {
    "id": "3IxNLdHeb6UIU9WAduaL",
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Перевести в строку, разбить на кусочки и отправить разными запросами.\n\n P.S.: Вопрос из разряда тех, на которые нет правильного ответа, потому как\n единственно верным ответом на этот вопрос был бы — не делайте так, не\n отправляйте файлы методом GET, даже не думайте об этом и всё будет хорошо.\n\n И это не тот случай когда хочется услышать размышления, а дойдёт ли\n собеседуемый до ожидаемого ответа или нет уже не так важно. Потому как в этом\n случае можно было бы поставить задачу иначе — указать некоторые\n дополнительные требования к загрузке файлов: например, что файлы могут быть\n неприлично большого размера и необходимо реализовать загрузку с возможностью\n догрузки, если в каком-то временном промежутке у клиента будут проблемы с\n сетью. Я имею ввиду, что если хочется услышать про возможность нарезки файлов\n на клиенте, то можно придумать условия и поадекватнее.\n "
      ]
    },
    "popularity": "3",
    "competence": ["javascript"],
    "question": "Как передать изображение размером 10Mb с помощью GET-запроса?",
    "tableIndex": 9,
    "description": "Передача файла.",
    "_id": { "$oid": "60de0704e2c8c53194aee4c0" }
  },
  {
    "id": "450L8AKAJrk12yZFfqAF",
    "answer": {
      "text": [
        "Расширение\n встроенного/нативног объекта JavaScript означает добавление свойств/функций к\n его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на\n практике это опасно. Представьте, что ваш код использует несколько библиотек,\n которые расширяют Array.prototype, добавляя один и тот же метод contains. В\n результате код будет работать неверно, если поведение этих двух методов не\n будет одинаковым.\n\n Единственный случай, при котором можно расширить нативный объект — это при\n создании полифила, создав собственную реализацию метода, который является\n частью спецификации JavaScript, но может отсутствовать в устаревших\n браузерах.\n "
      ],
      "code": [],
      "link": ["http://lucybain.com/blog/2014/js-extending-built-in-objects/"]
    },
    "description": "Нативы, прототипы.",
    "competence": ["javascript"],
    "tableIndex": 10,
    "difficulty": "junior",
    "popularity": "3",
    "_id": { "$oid": "60de0704e2c8c53194aee446" },
    "type": "question",
    "question": "Почему не следует расширять нативные JavaScript-объекты?"
  },
  {
    "id": "4FdWtQ6wA4OtGd9g8mBY",
    "description": "JSONP ",
    "difficulty": "junior",
    "question": "Объясните, как работает JSONP (и почему это не совсем AJAX)",
    "type": "question",
    "answer": {
      "link": ["https://stackoverflow.com/a/2067584/1751946"],
      "code": [
        "// HTML\n<- https://mydomain.com ->\n<script>\n function printData(data) {\n   console.log(`My name is ${data.name}!`);\n }\n\n </script>\n\n <script src=\"https://example.com?callback=printData\">;</script>\n\n // JS:\n // Файл загружен с https://example.com?callback=printData\n printData({ name: 'Yang Shun' });"
      ],
      "text": [
        "JSONP\n (JSON с набивкой) - это способ, часто используемый для обхода политики\n ограничения домена в браузерах, потому что Ajax-запросы с текущей страницы к\n серверу, находящемуся в другом домене, запрещены.\n\n JSONP работает, отправляя запрос к серверу в другом домене через тег <script> и обычно с параметром запроса callback, например:https://example.com?callback=printData. \nЗатем сервер обернет данные внутри функции с именем printData и вернет их клиенту.\n\n У клиента должна быть функция printData в своей глобальной области\n видимости, и эта функция будет выполнена клиентом, когда будет получен ответ\n с сервера из другого домена.\n\n JSONP может быть небезопасным и иметь повышенный риск. Поскольку JSONP -\n это действительно JavaScript, и он может делать все остальное, что может\n делать JavaScript, то вы должны быть уверены в надежности поставщика данных\n JSONP.\n\n В наши дни, CORS является рекомендуемым подходом и JSONP является способом\n для его обхода."
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee442" },
    "popularity": "1",
    "competence": ["javascript"],
    "tableIndex": 11
  },
  {
    "id": "4PD6pLbHFQzTNP89ylKZ",
    "popularity": "3",
    "competence": ["javascript"],
    "question": "Почему 0.1 + 0.2 даст 0.30000000000000004",
    "description": "Что за ерунда в конце там???",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Связано с системой представления десятичных чисел, не точностью их вычисления."
      ]
    },
    "difficulty": "junior",
    "tableIndex": 12,
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee4af" }
  },
  {
    "id": "4Vvrc75pdRaXOfM3qwDe",
    "_id": { "$oid": "60de0704e2c8c53194aee474" },
    "description": "Расположение блоков на странице.",
    "answer": {
      "code": [],
      "link": [
        "https://bootstrap-4.ru/docs/5.0/layout/grid/",
        "https://webref.ru/layout/bootstrap4/bootstrap-grid-system"
      ],
      "text": ["bootstrap materialise etc\n "]
    },
    "question": "Использовали ли вы систему сеток, и если да, то какую вы предпочитаете?",
    "tableIndex": 13,
    "competence": ["javascript"],
    "popularity": "3",
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "4Wl1ITsUNvIQ776SWCCg",
    "_id": { "$oid": "60de0704e2c8c53194aee44d" },
    "question": "Напишите функцию fizzbuzz.",
    "tableIndex": 14,
    "description": "Напишите цикл, который перебирает числа до 100, возвращая ”fizz” на числа кратные 3, ”buzz” на числа кратные 5 и ”fizzbuzz” на числа кратные 3 и 5.",
    "type": "exercise",
    "popularity": "5",
    "competence": ["javascript"],
    "answer": {
      "code": [
        " for (let i = 1; i &lt;= 100; i++) {\n   let f = i % 3 == 0,\n   b = i % 5 == 0;\n   console.log(f ? (b ? 'FizzBuzz' : 'Fizz') : b ? 'Buzz' : i);\n }\n",
        "for (var i = 1; i < 101; i++) {\n    if (i % 15 == 0) console.log(\"FizzBuzz\");\n    else if (i % 3 == 0) console.log(\"Fizz\");\n    else if (i % 5 == 0) console.log(\"Buzz\");\n    else console.log(i);\n}",
        "const fizzBuzz = num => {\n  for(let i = 1; i &lt;= num; i++) {\n   // Проверяем, кратно ли число 3 и 5\n   if(i % 3 === 0 && i % 5 === 0) {\n     console.log('fizzbuzz')\n   } // Проверяем, кратно ли число 3\n   else if(i % 3 === 0) {\n     console.log('fizz')\n   } // Проверяем, кратно ли число 5\n   else if(i % 5 === 0) {\n     console.log('buzz')\n   } else {\n     console.log(i)\n   }\n  }\n }"
      ],
      "text": [
        "Взгляните на версию FizzBuzz от Paul Irish[0]\n\n Хотя я бы не советовал вам использовать этот код во время интервью. Просто\n придерживайтесь длинного, но ясного подхода. Также можете взглянуть на разные\n безумные реализации FizzBuzz, по ссылке ниже.\n\n"
      ],
      "link": ["https://gist.github.com/jaysonrowe/1592432"]
    },
    "difficulty": "junior"
  },
  {
    "id": "4tuktcCNvSCz9eZINcD1",
    "popularity": "3",
    "tableIndex": 15,
    "competence": ["javascript"],
    "question": "Как работает export\\import в JS? Как работают modules в js?",
    "_id": { "$oid": "60de0704e2c8c53194aee4f5" },
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "text": ["Работает привычно. "],
      "link": [
        "https://javascript.info/import-export",
        "https://www.w3docs.com/learn-javascript/export-and-import.html",
        "https://sebhastian.com/javascript-import-export/"
      ],
      "code": []
    },
    "description": "Как модульная система работает в джэсике?"
  },
  {
    "id": "4xe8bWsXe4vHZTNf3rH7",
    "question": "Что вернёт этот код — typeof (function(){})() ?",
    "difficulty": "junior",
    "description": "typeof (function(){})()\n\nа) callback\nб) method\nв) undefined\nг) function",
    "tableIndex": 16,
    "popularity": "4",
    "competence": ["javascript"],
    "type": "question",
    "answer": { "text": ["ответ: в\n "], "link": [], "code": [] },
    "_id": { "$oid": "60de0704e2c8c53194aee4ad" }
  },
  {
    "id": "5AOcQZPlEAd12aMNiotx",
    "_id": { "$oid": "60de0704e2c8c53194aee4ab" },
    "tableIndex": 17,
    "popularity": "3",
    "competence": ["javascript"],
    "difficulty": "junior",
    "question": "Что вернет метод?",
    "answer": {
      "code": [
        "function Book() {\n  this.name = 'foo'\n}\n\nBook.prototype = {\n  getName: function() {\n    return this.name;\n  }\n};\n\nlet book = new Book();\n\nBook.prototype.getUpperName = function() {\n  return this.getName().toUpperCase();\n}\n\nbook.getUpperName();"
      ],
      "text": ["'FOO'"],
      "link": []
    },
    "description": "book.getUpperName();",
    "type": "question"
  },
  {
    "id": "5PppPjwbXFejbByH5en6",
    "question": "Реализуйте функцию Фибоначчи.",
    "difficulty": "junior",
    "description": "Число равно сумме двух предыдущих.",
    "answer": {
      "link": [],
      "text": ["\n "],
      "code": [
        "const fibonacci = num => {\n  // Сохраняем последовательность Фибоначчи, которую собираемся сгенерировать,\n  // внутри массива и инициализируем массив первыми двумя числами последовательности\n   const result = [0, 1]\n   for(let i = 2; i >= num; i++) {\n   // Поместим сумму двух чисел, предшествующих позиции i в массиве результатов,\n   // в конец этого массива\n   const prevNum1 = result[i - 1]\n   const prevNum2 = result[i - 2]\n   result.push(prevNum1 + prevNum2)\n }\n // Вернём последнее значение из массива результатов\n return result[num]\n }"
      ]
    },
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee4c6" },
    "competence": ["javascript"],
    "type": "exercise",
    "tableIndex": 18
  },
  {
    "id": "5TjZyKwUCLHtlIFX2WIZ",
    "description": "prototypal inheritance",
    "answer": {
      "text": [""],
      "link": ["https://www.youtube.com/watch?v=b55hiUlhAzI"],
      "code": []
    },
    "popularity": "5",
    "question": "Что такое прототипирование, прототипы, prototype, __proto__ и как это работает в javascript?",
    "type": "question",
    "tableIndex": 19,
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4e9" },
    "difficulty": "junior"
  },
  {
    "id": "5VWTkAUucBXDIwuFN8Y5",
    "type": "question",
    "competence": ["javascript"],
    "difficulty": "junior",
    "popularity": "3",
    "tableIndex": 20,
    "description": "Как там происходило развитие в js этой темы и к чему в итоге пришли.",
    "answer": {
      "code": [],
      "link": [
        "https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md"
      ],
      "text": [
        "Преимущества: \n 1. Помогает избежать “callback hell”, который может быть нечитаемым. \n 2. Упрощает написание последовательного удобочитаемого асинхронного кода спомощью .then().\n 3.Упрощает написание параллельного асинхронного кода с помощью Promise.all().\n\n С использованием промисов можно избежать следующих проблем, которые возникают при использовании callback-функций:\n 1. Колбэк-функция была вызвана слишком рано\n 2. Колбэк-функция была вызвана слишком поздно (или вовсе не была вызвана)\n 3.Колбэк-функция была вызвана слишком мало или слишком много раз <br>\n 4. Не удалось передать необходимую среду/параметры\n 5. Были пропущены ошибки/исключения\n\n Недостатки:\n 1. Чуть более сложный код (спорно).\n 2. В старых браузерах, где не поддерживается ES2015, вам нужно загрузить полифил, чтобы их использовать.\n "
      ]
    },
    "question": "Какие преимущества и недостатки при использовании промисов(Promise) вместо колбэков(callbacks)?",
    "_id": { "$oid": "60de0704e2c8c53194aee452" }
  },
  {
    "id": "5dIQ4hJ4aLF0i5QsqD8n",
    "question": "Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?",
    "difficulty": "junior",
    "answer": {
      "text": [
        "Семантика. Позволяет более точно описать из чего состоит контент.\n\nСвязанность. Позволяет общаться с сервером новыми и инновационными способами.\n\nОфлайн и хранилище. Позволяют страницам хранить данные локально на клиентской стороне и более эффективно работать в офлайне.\n\nМультимедиа. Ставит создание видео и аудио на первое место в вебе.\n\n2D/3D-графика и эффекты. Позволяет расширить возможности презентации.\n\nПроизводительность и интеграция. Обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.\n\nДоступ к устройствам. Позволяет взаимодействовать с различными устройствами ввода и вывода.\n\nСтилизация. Позволяет создавать более сложные темы оформления."
      ],
      "code": [],
      "link": [
        "https://frontendinterviewhandbook.com/ru/html-questions/#%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D1%8C%D1%82%D0%B5-html5-%D0%BA%D0%B0%D0%BA-%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%83%D1%8E-%D0%B2%D0%B5%D0%B1-%D0%BF%D0%BB%D0%B0%D1%82%D1%84%D0%BE%D1%80%D0%BC%D1%83-%D0%B8%D0%B7-%D0%BA%D0%B0%D0%BA%D0%B8%D1%85-%D0%B1%D0%BB%D0%BE%D0%BA%D0%BE%D0%B2-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82-html5",
        "https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5"
      ]
    },
    "popularity": "4",
    "description": "Какие стороны имеет HTML5?",
    "competence": ["javascript", "html", "frontend"],
    "type": "question",
    "tableIndex": 21,
    "_id": { "$oid": "60de0704e2c8c53194aee46b" }
  },
  {
    "id": "5xU37j8zty9RKSTIFJVu",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Оптимизация поиска элементов на странице с определенным селектором: искать только в нужном родителе, сохранить результаты в переменную и уже оттуда делать операции "
      ]
    },
    "popularity": "3",
    "description": "Много элементов на странице и надо их находить, менять у них стили и т.д.",
    "competence": ["javascript", "html", "css"],
    "difficulty": "junior",
    "type": "question",
    "question": "Как оптимизировать работу с элементами одного класса на странице?"
  },
  {
    "id": "639jcaBHDM2WeUkFqwQj",
    "answer": {
      "link": [],
      "code": [
        "$('#root').on('click',\n   function (event) {\n     event.stopPropogation();\n     console.log($(event.target).attr('id'));\n   }\n)"
      ],
      "text": [""]
    },
    "question": "Напишите код, который при клике на любой div внутри root будет выводить в консоль его id.",
    "_id": { "$oid": "60de0704e2c8c53194aee4a7" },
    "competence": ["javascript", "html", "frontend"],
    "popularity": "4",
    "tableIndex": 23,
    "description": "Нужен id элемента, на который кликнули.",
    "difficulty": "junior",
    "type": "exercise"
  },
  {
    "id": "67VGkkUzSZuuASKU4mho",
    "type": "question",
    "description": "Особенность border-radius",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Стилевые свойства применятся ко всем элементам с текстом, если у тегов не указаны стилевые правила. К примеру у ссылок указан цвет текста по умолчанию и он более приоритетный, чем определенный нами в body. Дело в том, что для многих свойств по умолчанию стоит значение inherit, то есть как у родителя.\n\nПолучается поднимается вверх, пока не дойдет до body.\n\nДля свойства border-radius, наоборот, применяется только к тегу, у которого мы хотим что бы били скругленные углы.\n "
      ]
    },
    "difficulty": "junior",
    "tableIndex": 24,
    "_id": { "$oid": "60de0704e2c8c53194aee48e" },
    "question": "Как применяются скругленные углы для элементов и стили для текста(шрифт, тип шрифта, цвета и тд)?",
    "popularity": "2"
  },
  {
    "id": "68dIkZQKfBkF0dcPAngy",
    "competence": ["javascript"],
    "question": "Как вы организуете свой код? (module pattern, classical inheritance)",
    "description": "module pattern - экспорты и импорты модулей и всего что можно из файла в файл.\nclassical inheritance - наследование через классы, имплементация интерфейсов и т.д.",
    "popularity": "4",
    "type": "question",
    "difficulty": "junior",
    "tableIndex": 25,
    "_id": { "$oid": "60de0704e2c8c53194aee439" },
    "answer": {
      "code": [],
      "text": [
        "В прошлом я использовал Backbone, который поощряет ООП подход, создавая Backbone модели и добавляя к ним методы.\n\nМодульный паттерн до сих пор хорош, но в настоящее время я использую React/Redux, который использует однонаправленный поток данных на основе архитектуры Flux. Я создаю модели своего приложения при помощи простых объектов и пишу чистые функции для управления этими объектами.\n\nСостояние управляется при помощью экшенов и редьюсеров, как в любом другом приложении Redux.\nЯ избегаю использования наследования классов, где это возможно. Если же мне это необходимо сделать, то я придерживаюсь этих правил."
      ],
      "link": [
        "https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4"
      ]
    }
  },
  {
    "id": "6PiGetlij5Lp57xY7U0t",
    "competence": ["javascript"],
    "tableIndex": 26,
    "description": "null, undefined, не обьявлено",
    "type": "question",
    "answer": {
      "text": [
        "Необъявленные переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи var, let или const. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка ReferenceError, когда вы попытаетесь назначить значение необъявленной переменной.[0]\n\nНеобъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок try/catch.",
        "Переменная undefined — это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип undefined. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение undefined. Чтобы проверить это, сравните, используя оператор строгого равенства (===) или typeof, который вернет строку undefined. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет true, если значение равно null.[1]",
        " Переменной со значением null было явно присвоено значение null. Она отличается от undefined тем, что она была назначена явно. Чтобы проверить на null, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (==) для проверки, так как он также вернет true, если значение равно undefined. [2]\n\nЛичная привычка — я никогда не оставляю свои переменные необъявленными или неприсвоенными. Я явно назначаю им null после объявления, если я не собираюсь их пока использовать. Если вы используете линтер в своем рабочем процессе, он обычно также проверяет, что вы не ссылаетесь на необъявленные переменные.\n\n Как бы вы проверили их на каждое из этих значений?\n if( typeof foo !== 'undefined' ) {\n // foo could get resolved and it's defined\n }"
      ],
      "link": [
        "https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables",
        "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined"
      ],
      "code": [
        " function foo() {\n   x = 1; // ReferenceError в строгом режиме\n }\n foo();\n console.log(x); // 1",
        " var foo;\n console.log(foo); // undefined\n console.log(foo === undefined); // true\n console.log(typeof foo === ‘undefined’); // true\n console.log(foo == null); // true. Неправильно, не используйте это для проверки!\n function bar() {}\n var baz = bar();\n console.log(baz); // undefined ",
        " var foo = null;\n console.log(foo === null); // true\n console.log(typeof foo === ‘object’); // true\n console.log(foo == undefined); // true. Неправильно, не используйте это для проверки!"
      ]
    },
    "question": "В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?",
    "popularity": "5",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee435" }
  },
  {
    "id": "6Stnf9vOASI6T3ZbKKCl",
    "tableIndex": 27,
    "question": "Что такое hashChange в обьекте window?",
    "competence": ["javascript", "html", "css", "frontend"],
    "type": "question",
    "answer": {
      "text": [
        "Считывает изменения в адресной строке. Можно вешать на него функции и действия и в зависимости от адресной строки производить какие-нибудь действия.\n\nИспользовался для роутинга в самодельном фреймворке, например."
      ],
      "code": [
        "// Using an event handler:\nwindow.onhashchange = funcRef;\n\n// Using an HTML event handler:\n<body onhashchange=\"funcRef();\">\n\n// Using an event listener:\nwindow.addEventListener(\"hashchange\", funcRef, false);",
        "function locationHashChanged() {\n  if (location.hash === '#cool-feature') {\n    console.log(\"You're visiting a cool feature!\");\n  }\n}\n\nwindow.onhashchange = locationHashChanged;",
        "function locationHashChanged() {\n  if (location.hash === '#cool-feature') {\n    console.log(\"You're visiting a cool feature!\");\n  }\n}\n\nwindow.onhashchange = locationHashChanged;"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event",
        "https://www.w3schools.com/jsref/event_onhashchange.asp",
        "https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onhashchange"
      ]
    },
    "description": "hashChange",
    "difficulty": "senior",
    "popularity": "3"
  },
  {
    "id": "6T5rXmyH7cIETNMG6K2w",
    "description": "Block scope, Function scope (Local Scope), Global scope, module scope",
    "question": "Что такое область видимости и какая она бывает? (local scope)",
    "tableIndex": 28,
    "popularity": "5",
    "competence": ["javascript"],
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee4dd" },
    "type": "question",
    "answer": {
      "text": [
        "Область видимости - важная концепция, определяющая доступность переменных. Данная концепция лежит в основе замыканий, разделяя переменные на глобальные и локальные.\n\nВыделяют блочная (между {} даже в if), лексическая или функциональная (внутри функции), глобальная (видимая везде), модульная (область видимости остается в файле модуля. Ее будет сидно только после экспорта-импорта)."
      ],
      "code": [
        "function outer(param) {\n  function inner() {\n    console.log('delayed output: ', param);\n  }\n  return inner;\n}\nsetTimeout(outer('something to print'), 1000)"
      ],
      "link": [
        "https://www.w3schools.com/js/js_scope.asp",
        "https://wikimass.com/js/scope-local",
        "https://habr.com/ru/post/517338/"
      ]
    }
  },
  {
    "id": "6hGw3TZAfg9pmHuz63IO",
    "description": "use strict",
    "tableIndex": 29,
    "type": "question",
    "competence": ["javascript"],
    "popularity": "4",
    "difficulty": "junior",
    "question": "Что делает строчка “use strict”;? Какие достоинства и недостатки от ее использования?",
    "_id": { "$oid": "60de0704e2c8c53194aee44c" },
    "answer": {
      "link": [
        "http://2ality.com/2011/10/strict-mode-hatred.html",
        "http://lucybain.com/blog/2014/js-use-strict/"
      ],
      "text": [
        "‘use strict’ это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.\n\nПреимущества:\n Не позволяет случайно создавать глобальные переменные.\n Любое присваивание, которое в обычном режиме завершается неудачей, в\n строгом режиме выдаст исключение.\n При попытке удалить неудаляемые свойства, выдаст исключение (в то время как\n в нестрогом режиме никакого действия бы не произошло).\n Требует, чтобы имена параметров функции были уникальными.\n this в глобальной области видимости равно undefined.\n Перехватывает распространенные ошибки, выдавая исключения.\n Исключает неочевидные особенности языка.\n\n Недостатки:\n Нельзя использовать некоторые особенности языка, к которым привыкли\n некоторые разработчики.\n Нет доступа к function.caller и function.arguments.\n Объединение скриптов, написанных в строгом режиме может вызвать проблемы.\n\nВ целом, я думаю, что преимущества перевешивают недостатки, и мне никогда не приходилось полагаться на функции, которые заблокированы в строгом режиме.\n\nЯ бы порекомендовал использовать строгий режим."
      ],
      "code": []
    }
  },
  {
    "id": "6hoGUAqbX3mtcXPktX3k",
    "popularity": "5",
    "description": "SRP - SOLID Design Principle - The Single Responsibility Principle - 1st of Object-Oriented Design (OOD)",
    "competence": ["common questions"],
    "question": "Что такое SRP? (первая в SOLID)",
    "difficulty": "junior",
    "tableIndex": 30,
    "answer": {
      "link": [
        "https://makedev.org/principles/solid/srp.html",
        "https://stackify.com/solid-design-principles/",
        "https://blog.logrocket.com/solid-principles-single-responsibility-in-javascript-frameworks/"
      ],
      "text": [
        "Принцип единственной ответственности. Каждый класс должен решать лишь одну задачу."
      ],
      "code": []
    },
    "type": "question"
  },
  {
    "id": "6jm6U4YZ747PmowbdMcN",
    "type": "question",
    "popularity": "4",
    "question": "Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.",
    "_id": { "$oid": "60de0704e2c8c53194aee450" },
    "description": "SPA - Single Page Application",
    "answer": {
      "code": [],
      "text": [
        "Текст ниже взят из замечательного руководства по фронтенду от Grab, который по счастливой случайности тоже был написан мной.\n\nВ наши дни веб-разработчики называют свои продукты веб-приложениями, а не веб-сайтами. Хотя между этими двумя терминами нет строгой разницы, веб-приложения, как правило, очень интерактивны и динамичны, что позволяет пользователю выполнять действия и получать мгновенный ответ. Традиционно браузер получает HTML с сервера и отображает его. Когда пользователь переходит на другой URL-адрес, требуется полное обновление страницы, и сервер\nотправляет свежий HTML-код на новую страницу. Это называется рендерингом на стороне сервера. \n\nОднако в современных SPA вместо этого используется рендеринг на стороне клиента. Браузер загружает начальную страницу с сервера вместе со скриптами (фреймворками, библиотеками, кодом приложения) и таблицами стилей, необходимыми для всего приложения. Когда пользователь переходит на другие страницы, обновление страницы не происходит. URL-адрес страницы обновляется при помощи HTML5 History API. Новые данные, необходимые для страницы (обычно в формате JSON), извлекаются браузером посредством запросов AJAX к серверу. Затем SPA динамически обновляет страницу данными через JavaScript, которые были получены при начальной загрузке страницы. Эта модель похожа на работунативных мобильных приложений.\n\nПреимущества:\nПриложение становится более отзывчивым, и пользователи не видят мерцаниепри навигации, т.к. страница не обновляется целиком.\n\nНа сервер поступает меньше HTTP-запросов, так как одни и те же ресурсы ненужно загружать снова для каждой загрузки страницы.\n\nЧеткое разделение на клиент и сервер. Вы можете легко создавать новые клиентские приложения для разных платформ (например, для мобильных устройств, чат-ботов, умных часов) без необходимости изменять код сервера. Вы также  можете изменить технологический стек на клиенте и сервере независимо, пока между ними существует интерфейс.\n\nНедостатки:\nБолее тяжелая первоначальная загрузка страницы из-за загрузки кода фреймворка, самого приложения и ресурсов.\n\nВаш сервер должен быть сконфигурирован так, чтобы он направлял все запросы к единой точке входа, и переложил обязанности по навигации на сторону клиента.\n\nДля отображения содержимого SPA полагается на JavaScript, но не все поисковые системы выполняют JavaScript во время индексации, и они могут не увидеть содержимое страницы. Это вредит поисковой оптимизации (SEO) вашего приложения. Тем не менее, в большинстве случаев, когда вы создаете приложения, SEO не является наиболее важным фактором, так как не весь контент должен индексироваться поисковыми системами. Чтобы преодолеть это, вы можете\nлибо рендерить свое приложение на стороне сервера, либо использовать такие сервисы, как Prerender, чтобы “рендерить ваш javascript в браузере, сохранять статический HTML и передавать его поисковым роботам”."
      ],
      "link": [
        "https://github.com/grab/front-end-guide#single-page-apps-spas",
        "http://stackoverflow.com/questions/21862054/single-page-app-adva<span style=\"display:none\">ntages-and-disadvantages</span>",
        "http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/",
        "https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52"
      ]
    },
    "competence": ["javascript"],
    "difficulty": "junior",
    "tableIndex": 31
  },
  {
    "id": "70TIZGYpAPzhGI8PkDCU",
    "popularity": "1",
    "answer": {
      "code": [],
      "link": [
        "https://code-maze.com/netcore-signalr-angular-realtime-charts/",
        "https://www.c-sharpcorner.com/article/real-time-angular-11-application-with-signalr-and-net-5/",
        "https://rhythmandbinary.com/post/2020-10-16-connecting-microsoft-signalr-with-angular",
        "https://medium.com/scriptkiddiez/playing-with-signalr-in-angular-app-to-handle-real-time-processing-with-net-core-api-part-2-5bbd8eac2f33",
        "https://www.c-sharpcorner.com/article/real-time-angular-11-application-with-signalr-and-net-5/"
      ],
      "text": ["SignalR \nНадо посмотреть что это такое"]
    },
    "description": "SignalR ",
    "competence": ["common questions", "angular", "frontend"],
    "question": "Что такое SignalR и как его используют?",
    "difficulty": "senior",
    "type": "question"
  },
  {
    "id": "7HIZWexpmbR09cAsN2TC",
    "type": "question",
    "competence": ["html", "css"],
    "answer": {
      "code": ["<strong> Contents... </strong>\n<b> Contents... </b>"],
      "text": [
        "Оба эти тега делают текст жирным НО! strong семантически говорит поисковым системам о том, что этот текст важен. А b просто делает зрительно шрифт жирным."
      ],
      "link": [
        "https://www.geeksforgeeks.org/difference-between-strong-and-bold-tag-in-html/"
      ]
    },
    "popularity": "3",
    "question": "какая разница между strong и b?",
    "tableIndex": 32,
    "difficulty": "junior",
    "description": "<strong> && <b>"
  },
  {
    "id": "7e8G1mgopXxGXWGN8rLu",
    "tableIndex": 33,
    "description": "Closures",
    "question": "Что такое Замыкание?",
    "competence": ["javascript"],
    "type": "question",
    "difficulty": "junior",
    "popularity": "5",
    "answer": {
      "text": [
        "Можно использовать для имитации приватных методов[0] (создание изоляции и инкапсуляции)\n\nДля создания фабричной функции (function factory)[1]\n\nПри каждом выполнении функции для нее создается новое лексическое окружение. Environment Record - локальное окружение с локальными переменными и [[Environment]].\n\nВсе функции в момент создания получают скрытое свойство [[Environment]], которое ссылается на то лексическое окружение, в котором было создано."
      ],
      "code": [
        "var Counter = (function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter;\n    }\n  };\n})();\n\nalert(Counter.value()); /* Alerts 0 */\nCounter.increment();\nCounter.increment();\nalert(Counter.value()); /* Alerts 2 */\nCounter.decrement();\nalert(Counter.value()); /* Alerts 1 */",
        "function showHelp(help) {\n  document.getElementById('help').innerHTML = help;\n}\n\nfunction makeHelpCallback(help) {\n  return function() {\n    showHelp(help);\n  };\n}\n\nfunction setupHelp() {\n  var helpText = [\n      {'id': 'email', 'help': 'Ваш адрес e-mail'},\n      {'id': 'name', 'help': 'Ваше полное имя'},\n      {'id': 'age', 'help': 'Ваш возраст (Вам должно быть больше 16)'}\n    ];\n\n  for (var i = 0; i < helpText.length; i++) {\n    var item = helpText[i];\n    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);\n  }\n}\n\nsetupHelp();",
        "function makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++; // есть доступ к внешней переменной \"count\"\n  };\n}\n\nlet counter = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\nalert( counter() ); // 2"
      ],
      "link": [
        "https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures",
        "https://learn.javascript.ru/closure",
        "https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898"
      ]
    }
  },
  {
    "id": "7fKuNvsAUYZZkOAkbkS3",
    "description": "debounce",
    "answer": {
      "code": [
        "<input type=\"text\" onkeyup=\"processChange()\" />\n\nfunction debounce(func, timeout = 300){\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => { func.apply(this, args); }, timeout);\n  };\n}\nfunction saveInput(){\n  console.log('Saving data');\n}\nconst processChange = debounce(() => saveInput());",
        "<button onclick=\"processChange()\">Click me</button>\nwindow.addEventListener(\"scroll\", processChange);\n\nfunction debounce_leading(func, timeout = 300){\n  let timer;\n  return (...args) => {\n    if (!timer) {\n      func.apply(this, args);\n    }\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = undefined;\n    }, timeout);\n  };\n}"
      ],
      "link": [
        "https://www.freecodecamp.org/news/javascript-debounce-example/"
      ],
      "text": ["создает таймаут, функция высшего порядка"]
    },
    "competence": ["common questions", "javascript"],
    "tableIndex": 36,
    "difficulty": "middle",
    "type": "question",
    "popularity": "5",
    "question": "Что такое функция debounce?"
  },
  {
    "id": "8PvuiFJqj7zakZTGSVZb",
    "tableIndex": 37,
    "difficulty": "junior",
    "description": "Ajax",
    "type": "question",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee441" },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Преимущества:\n\nПовышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.\n\nСокращение количества подключений к серверу, поскольку скрипты и таблицы стилей нужно запрашивать только один раз.\n\nСостояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.\n\nБольшая часть преимуществ SPA.\n\n\nНедостатки\n\nСложнее реализовать добавление динамической веб-страницы в закладки.\n\nНе работает, если в браузере отключен JavaScript.\n\nНекоторые поисковые роботы не выполняют JavaScript и не видят данные, загружаемые при помощи JavaScript.\n\nБольшая часть недостатков SPA."
      ]
    },
    "question": "Какие преимущества и недостатки в использовании Ajax?",
    "popularity": "3"
  },
  {
    "id": "8VDl1VvxeWzRfQTV6LDl",
    "difficulty": "junior",
    "type": "question",
    "description": "JSONP",
    "competence": ["javascript"],
    "answer": {
      "text": [
        "Тег script начинает выкачивать скрипт, лежащий по адресу в атрибуте src, а после закачки, происходит выполнение. Поэтому мы создаем тег script. Случайным образом генерируем имя функции. Формируем урл к ресурсу, где в качестве параметра передается имя нашей новой функции. \n\nВ глобальную область, по ключу callbackName помещается функция, которая вызовется, при получение данных от ресурса, они станут доступны внутри через параметр.\n",
        ""
      ],
      "code": [
        "var url = 'http://mydomen.com/news.php', \n  script = document.createElement('script'), \n  callbackName = 'jsonCallback' + Math.randome();\n\nscript.src = url + '?callback' + callbackName;\n\nwindow[callbackName] = function(response){\n console.log(response);\n}\n\n document.header.appendChild(script);\n\n <script src='http://mydomen.com/news.php?callback0.90428777...'>\n\n// На сервере ресурса сработает что-то в этом роде \necho $_REQUEST[callback] + '(' + json_encode($arDate) + ')';\n\n// В window попадет \nwindow.jsonCallback0.90428777 -&gt; function (response) {\n console.log(response);\n }\n// Так как теги с атрибутом src способы посылать только GET запросы,\n// то jsonp не поддерживает POST"
      ],
      "link": []
    },
    "question": "Как реализовать JSONP?",
    "tableIndex": 38,
    "_id": { "$oid": "60de0704e2c8c53194aee4a0" },
    "popularity": "2"
  },
  {
    "id": "8a20T6xQlz4vbnTNdO5m",
    "competence": ["html"],
    "difficulty": "junior",
    "popularity": "3",
    "type": "question",
    "question": "В чем особенность статических полей в классах?",
    "description": "static isAvailable = true",
    "answer": {
      "text": [
        "Статические свойства вызываются непосредственно через сам класс и никак больше."
      ],
      "code": [
        "class Cat {\n  constructor() {\n    console.log(Cat.COLLECTION_NAME);\n  }\n}\n\nCat.COLLECTION_NAME = \"cats\";",
        "class Cat {\n  constructor() {\n    console.log(Cat.COLLECTION_NAME);\n  }\n\n  static get COLLECTION_NAME() {\n    return \"cats\"\n  }\n}"
      ],
      "link": []
    }
  },
  {
    "id": "8nyzfm8CGoRkYW6KKZl5",
    "question": "Что такое Map и Set?",
    "difficulty": "junior",
    "answer": {
      "code": [
        "let map = new Map(Object.entries(obj));\n\nlet prices = Object.fromEntries([\n  ['banana', 1],\n  ['orange', 2],\n  ['meat', 4]\n]);"
      ],
      "text": [
        "Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.\n\nМетоды и свойства:\n\nnew Map() – создаёт коллекцию.\nmap.set(key, value) – записывает по ключу key значение value.\nmap.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.\nmap.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.\nmap.delete(key) – удаляет элемент по ключу key.\nmap.clear() – очищает коллекцию от всех элементов.\nmap.size – возвращает текущее количество элементов.\n\nПеребор Map\nДля перебора коллекции Map есть 3 метода:\n\nmap.keys() – возвращает итерируемый объект по ключам,\nmap.values() – возвращает итерируемый объект по значениям,\nmap.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.\n\n\nОбъект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.\n\nЕго основные методы это:\n\nnew Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.\nset.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.\nset.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.\nset.has(value) – возвращает true, если значение присутствует в множестве, иначе false.\nset.clear() – удаляет все имеющиеся значения.\nset.size – возвращает количество элементов в множестве."
      ],
      "link": ["https://learn.javascript.ru/map-set"]
    },
    "competence": ["javascript"],
    "description": "map set",
    "tableIndex": 40,
    "popularity": "5",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee51d" }
  },
  {
    "id": "8q9eIak5eQPNyZu86XBt",
    "difficulty": "junior",
    "description": "Палиндро́м, пе́ревертень — число, буквосочетание, слово или текст, одинаково читающееся в обоих направлениях.",
    "question": "Напишите функцию, которая проверит является ли строка палиндромом.",
    "type": "exercise",
    "competence": ["javascript"],
    "tableIndex": 41,
    "answer": {
      "link": [],
      "text": [
        "Берем строку, приводим к ловеркейс, разделяем в массив, переворачиваем, соединяем массив, сравниваем."
      ],
      "code": [
        "function isPalindrom1(str) {\n  if (str.toLowerCase().replace(/[^а-яА-ЯёЁ]/g, '') \n      ===\n     str.toLowerCase().replace(/[^а-яА-ЯёЁ]/g,'').split('').reverse().join('')) {\n       return true;\n      } else {\n        return false;\n      }\n}\n "
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee49c" },
    "popularity": "5"
  },
  {
    "id": "8qQ11Ioyh5ln1G0v8ihq",
    "difficulty": "junior",
    "question": "В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?",
    "popularity": "4",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new"
      ],
      "text": [
        "Этот вопрос не совсем понятен. Я полагаю, что суть вопроса о конструкторах в JavaScript. Строго говоря, function Person(){} — это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.\n\nvar person = Person() вызывает Person как функцию, а не как конструктор.\nВызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается undefined, и это присваивается переменной, предназначенной в качестве экземпляра.\n\nvar person = new Person() создает экземпляр объекта Person с помощью оператора new, который наследуется от Person.prototype. Альтернативой может быть использование Object.create, например: Object.create(Person.prototype)."
      ],
      "code": [
        " function Person(name) {\n   this.name = name;\n }\n var person = Person(‘John’);\n console.log(person); // undefined\n console.log(person.name); // Uncaught TypeError: Cannot read property ‘name’ of undefined\n var person = new Person(‘John’);\n console.log(person); // Person { name: “John” }\n console.log(person.name); // “john”"
      ]
    },
    "tableIndex": 42,
    "description": "function new",
    "_id": { "$oid": "60de0704e2c8c53194aee43b" },
    "type": "question",
    "competence": ["common questions"]
  },
  {
    "id": "8tzSg4K5u99986wcMdL0",
    "type": "question",
    "difficulty": "junior",
    "description": "microtask queue Очередь микрозадач",
    "competence": ["javascript"],
    "popularity": "4",
    "question": "Что такое queue?",
    "answer": {
      "link": ["https://learn.javascript.ru/microtask-queue"],
      "text": [
        "Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь PromiseJobs, более известную как «очередь микрозадач (microtask queue)» (термин V8)."
      ],
      "code": []
    },
    "tableIndex": 43,
    "_id": { "$oid": "60de0704e2c8c53194aee4d5" }
  },
  {
    "id": "8ucZWF0GB38N01JREfyO",
    "difficulty": "junior",
    "type": "question",
    "competence": ["javascript", "html", "css", "frontend"],
    "popularity": "4",
    "description": "::after  ::before ::first-lette ::first-line",
    "answer": {
      "text": [
        "Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть выбранного элемента. Например, псевдоэлемент ::first-line может быть использован для изменения шрифта первой строки абзаца.\n\nВ отличие от псевдоэлементов, псевдоклассы могут быть использованы для стилизации элемента на основе его состояния.\n\nКак правило, следует использовать двойное двоеточие (::) вместо одинарного (:). В этом состоит различие между псевдоклассами и псевдоэлементами. Однако, так как это различие не присутствовало в старых версиях спецификации W3C, большинство браузеров поддерживают оба синтаксиса для псевдоэлементов."
      ],
      "code": [],
      "link": ["https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-elements"]
    },
    "tableIndex": 44,
    "_id": { "$oid": "60de0704e2c8c53194aee476" },
    "question": "Объясните, что такое псевдоэлементы и для чего они нужны."
  },
  {
    "id": "9GTF8de2wx1T7svdzgg9",
    "answer": {
      "text": [
        "Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют. В интерфейсы одной сущности не должны попадать данные и методы другой сущности.",
        "(Interface Segregation Principle / Принцип разделения интерфейса / Четвертый принцип SOLID) призывает не создавать жирные универсальные интерфейсы. Вместо этого интерфейсы нужно разделять на более мелкие и специализированные, это поможет гибче их комбинировать в имплементирующих классах, не заставляя имплементировать лишние методы.",
        "“Clients should not be forced to depend upon interfaces that they do not use.”"
      ],
      "code": [],
      "link": [
        "https://stackify.com/interface-segregation-principle/",
        "https://blog.logrocket.com/solid-principles-single-responsibility-in-javascript-frameworks/",
        "https://medium.com/webbdev/solid-4ffc018077da",
        "https://habr.com/ru/post/463125/"
      ]
    },
    "competence": ["common questions"],
    "question": "Что такое ISP? (четвертая в SOLID)",
    "popularity": "5",
    "description": "ISP - Interface segregation principle - Принцип разделения интерфейса",
    "tableIndex": 46,
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "9HzDNjbGC2cNfEF9L3rr",
    "difficulty": "middle",
    "type": "exercise",
    "answer": { "text": ["В процессе"], "link": [], "code": [] },
    "question": "Напишите свою директиву *ngFor.",
    "competence": ["javascript", "typescript", "angular", "frontend"],
    "description": "angular ngFor",
    "popularity": "5"
  },
  {
    "id": "9Kl4rV2xPtG8xcFxxQrH",
    "difficulty": "middle",
    "question": "Что такое фаза creation phase (pre-parser) в javascript?",
    "competence": ["javascript"],
    "type": "question",
    "description": "creation phase,  pre-parser, execution phase",
    "_id": { "$oid": "60de0704e2c8c53194aee4e4" },
    "tableIndex": 46,
    "popularity": "3",
    "answer": {
      "code": [],
      "link": [
        "https://www.telerik.com/blogs/journey-of-javascript-downloading-scripts-to-execution-part-i"
      ],
      "text": [
        "В большинстве курсов и книг по JS обычно обсуждается следующее...\n\nЯ не знаю \"большинство курсов и книг по JS\", и эта ссылка недостаточно конкретна, чтобы ее искать. Если вам нужно конкретное сравнение с конкретным использованием терминов где-либо, пожалуйста, укажите источник, на который вы ссылаетесь.\n\nКогда функция вызывается из глобальной области видимости, она будет предварительно проанализирована (фаза создания), а затем полностью проанализирована (фаза выполнения).\n\nПредварительный анализ полезен только тогда, когда это происходит (задолго) до того, как функция будет вызвана или полностью проанализирована - вот почему это называется предварительным анализом. Синтаксический анализ не является частью выполнения. Синтаксический анализ происходит как первый шаг компиляции (или вы могли бы сказать: \"прямо перед компиляцией\"; то же самое), что должно произойти до начала выполнения. (По крайней мере, так обстоит дело в современных высокопроизводительных двигателях; вы могли бы создать движок, который ничего не компилирует, а напрямую интерпретирует исходный код, что означало бы, что эффективный синтаксический анализ и выполнение будут одним и тем же, но это будет намного медленнее для всего, кроме тривиальных сценариев.)\n\nВопрос 1: Верны ли мои предположения? Является этапом предварительного анализа ===создания.\n\nВообще говоря, нет тесного соответствия между высокоуровневыми концептуальными этапами выполнения JS и деталями внутренней реализации движка.\n\nПредварительный анализ является (частью) совершенно необязательной стратегии внедрения, повышающей производительность. Вы можете отключить его, если хотите - все будет медленнее, но наблюдаемое поведение будет таким же. Основная идея заключается в том, что движок будет генерировать код \"лениво\", т.Е. при первом вызове функции (потому что генерация всего кода \"с нетерпением\" заранее приведет к раздражающе медленному запуску). Чтобы иметь возможность это сделать, он должен решить проблему \"вот пара сотен килобайт кода JS, скомпилируйте функцию fun1, пожалуйста\", поэтому он должен знать, где находится \"fun1\". Это информация, которую генерирует этап \"предварительного анализа\": он в основном создает имена функций сопоставления индексов с тем местом в исходном тексте, где определена соответствующая функция.\n\n(В качестве еще одной совершенно необязательной стратегии реализации, повышающей производительность, современные движки делают сложный выбор в отношении представления / распределения внутренних переменных, которые для обеспечения правильного поведения требуют предварительного анализа для генерации дополнительных данных о переменных, на которые ссылаются другие функции; поэтому, если вы посмотрите на реализацию, вы увидите, что это немного сложнее, чем просто идентификация функции <имя> { ... } диапазоны. Вы правы в том, что предварительный анализ не создает AST, но по этой причине он создает цепочки областей видимости.)\n\nВопрос 2. Создает ли предварительный синтаксический анализ объект функции для функции, которая еще не вызвана.\n\nПредварительный анализ, полный анализ и компиляция влияют только на код функции. Они не связаны с самим объектом функции. Когда у вас есть объект функции, вы обычно не можете сказать, был ли он предварительно проанализирован или нет, был ли его код скомпилирован или нет, или был ли его код оптимизирован (= скомпилирован снова, позже, с учетом обратной связи по типу) или нет. Объект функции создается путем выполнения соответствующей внешней функции (которая может быть кодом в глобальной области видимости). Он содержит внутренние скрытые ссылки на метаданные (код и другие), необходимые для его выполнения.\n\nЧтобы еще раз подчеркнуть это: все подробности о том, когда движок анализирует / компилирует - каковы внутренние детали реализации, которые различаются между движками и меняются со временем (по мере того, как соответствующие команды улучшают свои движки), поэтому они, как правило, не должны влиять на то, как выполняется ваша программа."
      ]
    }
  },
  {
    "id": "9QiD8WiXEfyG47zYaswu",
    "_id": { "$oid": "60de0704e2c8c53194aee4d0" },
    "popularity": "5",
    "tableIndex": 47,
    "type": "question",
    "question": "Напишите пример инкапсуляции в классе. (задача \"кофеварка\")",
    "answer": {
      "code": [
        "class CoffeeMachine {\n  #waterAmount = 0;\n  get waterAmount() {\n    return this.#waterAmount;\n  }\n  set waterAmount(value) {\n    if (value < 0) throw new Error(\"Отрицательный уровень воды\");\n    this.#waterAmount = value;\n  }\n}\n\n let machine = new CoffeeMachine();\n machine.waterAmount = 100;\n alert(machine.#waterAmount); // Error\n "
      ],
      "link": [],
      "text": [""]
    },
    "difficulty": "junior",
    "competence": ["javascript"],
    "description": "кофеварка, инкапсуляция"
  },
  {
    "id": "AD4BVrAX2cTJcLs9pRCW",
    "tableIndex": 48,
    "description": "прототип",
    "question": "Расскажите, как работает прототипное наследование?",
    "answer": {
      "link": [
        "https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson",
        "https://davidwalsh.name/javascript-objects"
      ],
      "code": [],
      "text": [
        "Этот вопрос очень часто задают на собеседованиях. Все объекты в JavaScript имеют свойство prototype, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки\nпрототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование."
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee432" },
    "difficulty": "junior",
    "popularity": "5",
    "type": "question",
    "competence": ["javascript", "common questions", "typescript"]
  },
  {
    "id": "AOi2FPnxV6KoWsaQDSgj",
    "_id": { "$oid": "60de0704e2c8c53194aee478" },
    "question": "Что делает * { box-sizing: border-box; }? В чем его преимущества?",
    "description": "box-sizing",
    "popularity": "5",
    "difficulty": "junior",
    "competence": ["javascript", "html", "css", "frontend"],
    "type": "question",
    "tableIndex": 49,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "border-box говорит браузеру учитывать любые границы и внутренние отступы в значениях, которые вы указываете в ширине и высоте элемента. Если вы выставите элементу ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно это упрощает работу с размерами элементов."
      ]
    }
  },
  {
    "id": "AYvgTugpBdIGCIsqSxmW",
    "tableIndex": 50,
    "question": "Что выводит код ниже? console.log(0.1 + 0.2 == 0.3);",
    "type": "question",
    "popularity": "5",
    "difficulty": "junior",
    "description": "Почему так, а?",
    "answer": {
      "text": [
        "ЛОЖЬ\n0.1+0.2 == 0.30000000000000004\nСвязано с дробной работой в языках программирования."
      ],
      "code": [],
      "link": []
    },
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee482" }
  },
  {
    "id": "B3w4eoQ2Rjq2N8YcLB8P",
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "link": [],
      "text": [
        "Нужно делать проверку на элементы, принадлежащие именно этому обьекту, иначе он будет смотреть и по прототипу (hasOwnProperty), а лучше вообще юзать Object.keys(obj)"
      ],
      "code": []
    },
    "competence": ["javascript"],
    "description": "const key in obj",
    "question": "Почему при написании for (const key in obj) eslint подчеркивает как ошибку?",
    "popularity": "4"
  },
  {
    "id": "BILXyCWMXdibzanyEXun",
    "question": "Что такое eval и почему его следует избегать?",
    "competence": ["javascript"],
    "difficulty": "junior",
    "description": "eval ",
    "answer": {
      "link": [],
      "text": [
        "eval() в ней выполняется функция, которая написана в форме строки"
      ],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee51b" },
    "popularity": "4",
    "type": "question",
    "tableIndex": 52
  },
  {
    "id": "Bcay9fF5XGcBmjUnH15S",
    "difficulty": "middle",
    "popularity": "4",
    "type": "question",
    "description": "State Pattern",
    "answer": {
      "code": [
        "class TrafficLight {\n  constructor() {\n    this.states = [new GreenLight(), new RedLight(), new YellowLight()];\n    this.current = this.states[0];\n  }\n\n  change() {\n    const totalStates = this.states.length;\n    let currentIndex = this.states.findIndex(light => light === this.current);\n    if (currentIndex + 1 < totalStates) this.current = this.states[currentIndex + 1];\n    else this.current = this.states[0];\n  }\n\n  sign() {\n    return this.current.sign();\n  }\n}\n\nclass Light {\n  constructor(light) {\n    this.light = light;\n  }\n}\n\nclass RedLight extends Light {\n  constructor() {\n    super('red');\n  }\n\n  sign() {\n    return 'STOP';\n  }\n}\n\nclass YellowLight extends Light {\n  constructor() {\n    super('yellow');\n  }\n\n  sign() {\n    return 'STEADY';\n  }\n}\n\nclass GreenLight extends Light {\n\tconstructor() {\n\t\tsuper('green');\n\t}\n\n\tsign() {\n\t\treturn 'GO';\n\t}\n}\n\n// usage\nconst trafficLight = new TrafficLight();\n\nconsole.log(trafficLight.sign()); // 'GO'\ntrafficLight.change();\n\nconsole.log(trafficLight.sign()); // 'STOP'\ntrafficLight.change();\n\nconsole.log(trafficLight.sign()); // 'STEADY'\ntrafficLight.change();\n\nconsole.log(trafficLight.sign()); // 'GO'\ntrafficLight.change();\n\nconsole.log(trafficLight.sign()); // 'STOP'"
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Это поведенческий шаблон проектирования, который позволяет объекту изменять свое поведение на основе изменений его внутреннего состояния. Объект, возвращаемый классом шаблона состояния, кажется, меняет свой класс. Он обеспечивает логику, зависящую от состояния, для ограниченного набора объектов, в котором каждый тип объекта представляет определенное состояние.\nМы возьмем простой пример светофора, чтобы понять эту закономерность. Класс TrafficLight изменяет возвращаемый им объект в зависимости от его внутреннего состояния, которое является объектом класса Red, Yellow или Green."
      ]
    },
    "question": "Что такое State Pattern в Javascript?",
    "competence": ["common questions", "javascript"]
  },
  {
    "id": "Br2dtQIGg1jdjQhZzCkH",
    "type": "question",
    "description": "стек",
    "_id": { "$oid": "60de0704e2c8c53194aee4f7" },
    "answer": {
      "code": [],
      "link": [
        "https://habr.com/ru/post/341586/",
        "https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA"
      ],
      "text": [
        "Стек (англ. stack — стопка; читается стэк) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»)."
      ]
    },
    "competence": ["common questions", "javascript"],
    "tableIndex": 54,
    "popularity": "5",
    "question": "Что такое стек?",
    "difficulty": "junior"
  },
  {
    "id": "C8Q08SndvabbpKqGi7sn",
    "answer": {
      "code": [],
      "text": [
        "CrankShaftScript - это принятый сообществом термин, используемый для неидиоматического и / или нестандартного совместимого JavaScript, который будет выполняться и / или хорошо работать только в определенных версиях среды выполнения JavaScript v8, в которых используется JIT-компилятор Crankshaft. Конкретные примеры включают: циклы, написанные сложным в обслуживании способом для устранения недостатков оптимизации JIT в v8, и использование встроенных функций / глобальных функций, специфичных для v8.\n\nЭтот термин был первоначально придуман для описания некоторых основных проблем с производительностью в node-chakracore и spidernode, которые Node.js дистрибутивы, в которых вместо v8 используются среды выполнения ChakraCore и SpiderMonkey.\n\nВ настоящее время он используется в качестве стенографии для объяснения того, почему Node.js Серия выпусков 8.1, которая обновлена до более новой версии v8, имеет несколько регрессий производительности в микро- и макро-тестах из-за того, что дрожание коленчатого вала v8 заменено турбовентилятором (иногда называемым \"TF\"). Как и в этих вопросах:",
        "Сценарий коленчатого вала - это название, данное сообществом идиомам JS (таким как определенные типы циклов), которые работают быстрее (есть?) на двигателе коленчатого вала V8.\n\nКоленчатый вал заменяется двигателем с турбовентилятором. Множество JS-кода, написанного разработчиками на протяжении многих лет, было написано специально для быстрой работы на коленчатом валу (например, написано в \"CrankShaftScript\") с использованием известных идиом, которые быстро работают на коленчатом валу - это уже не обязательно так, потому что двигатель V8 теперь другой, и код, который работал быстрее всего на коленчатом валу, не обязательно гарантированно работает быстрее на турбовентиляторе.\n\nВ случае, если мой ответ слишком многословен, вот отличный комментарий к теме тестов NodeJS, который может детализировать его лучше:",
        "БЫЛ ЗАМЕНЕН TURBOFANOM \nCrankshift теперь не используется."
      ],
      "link": [
        "https://draft.li/blog/2016/01/22/chromium-chrome-v8-crankshaft-bailout-reasons/",
        "https://stackoverflow.com/questions/44764777/what-is-crankshaftscript-in-node-js"
      ]
    },
    "description": "Crankshaft Turbofan",
    "competence": [
      "common questions",
      "javascript",
      "nodejs",
      "frontend",
      "backend"
    ],
    "difficulty": "senior",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee503" },
    "popularity": "2",
    "tableIndex": 57,
    "question": "Что такое компилятор Crankshaft?"
  },
  {
    "id": "ClMwUwpOYyolQN1R9Sl5",
    "competence": ["javascript"],
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee455" },
    "description": "итерация",
    "popularity": "5",
    "difficulty": "junior",
    "question": "Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?",
    "answer": {
      "link": [
        "http://2ality.com/2015/08/getting-started-es6.html#from-for-to-foreach-to-for-of",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries"
      ],
      "text": [
        "Для объектов:\n\n for-in циклы — for (var property in obj) { console.log(property); }. Тем не\n менее, он также будет перебирать его унаследованные свойства, и вам нужно\n добавить проверку obj.hasOwnProperty(property) перед его использованием.\n\n Object.keys() — Object.keys(obj).forEach(function (property) { … }).\n Object.keys()- это статический метод, который возвращает все перечисляемые\n свойства объекта.\n\n Object.getOwnPropertyNames() —\n Object.getOwnPropertyNames(obj).forEach(function (property) { … }).\n Object.getOwnPropertyNames() — это статический метод, который возвращает все\n перечисляемые и неперечисляемые свойства объекта.\n\n Для массивов:\n Циклы for — for (var i = 0; i < arr.length; i++). Распространенной\n ошибкой здесь является то, что var находится в области видимости функции, а\n не в блочной области видимости, и в большинстве случаев нам нужна\n переменная-итератор блочной области. ES2015 позволяет использовать let,\n который имеет блочную область видимости, и рекомендуется использовать его\n вместо var. В итоге: for (let i = 0; i < arr.length; i++).\n\n forEach — arr.forEach(function (el, index) { … }). Эта конструкция иногда\n может быть более удобной, потому что вам не нужно использовать inde`, если\n все, что вам нужно, это элементы массива. Существуют также методы every и\n some, которые позволят вам досрочно завершить итерацию.\n\n for-of циклы — for (let elem of arr) { … }. ES6 представил новый цикл\n for-of, который позволяет перебирать объекты, которые соответствуют\n итерируемому протоколу такие как String, Array, Map, Set, и т.д. Он сочетает\n в себе преимущества цикла `for` и метода forEach(). Преимущество цикла `for`\n заключается в том, что его можно преждевременно завершить, а преимущество\n forEach() заключается в том, что он более лаконичен, чем цикл for, поскольку\n вам не нужна переменная счетчика. С циклом for-of вы получаете возможность\n выхода из цикла и более сжатый синтаксис.\n\n В большинстве случаев я бы предпочел метод .forEach, но он зависит от того,\n что вы пытаетесь сделать. До ES6 мы использовали циклы for, если нам нужно\n было преждевременно завершить цикл при помощи break. Но теперь с ES6 мы можем\n сделать это с помощью циклов for-of. Я использую циклы for, когда мне нужно\n еще больше гибкости, например, в случае увеличения итератора более одного\n раза за цикл.\n\n Кроме того, при использовании цикла for-of, если вам нужен доступ как к\n индексу, так и к значению каждого элемента массива, вы можете сделать это с\n помощью метода ES6 entries() и деструктуризации:"
      ],
      "code": [
        "const arr = ['a', 'b', 'c'];\n for (let [index, elem] of arr.entries()) {\n console.log(index, ': ', elem);\n}"
      ]
    },
    "tableIndex": 56
  },
  {
    "id": "D4CeEHQAPTAdcUk35p8G",
    "answer": {
      "code": [
        "function* generator(){\n   yeild 1;\n   yeild 2;\n}\n\n<html>\n<body>\n<script>\n   function * number() {\n      var num = 10;\n      while (true) {\n         yield num--;\n      }\n   }\n   var gen = number();\n   document.write(gen.next().value);\n   document.write(\"</br>\");\n   document.write(gen.next().value);\n   document.write(\"</br>\");\n   document.write(gen.next().value);\n</script>\n</body>\n</html>\n\n10\n9\n8",
        "function* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\n// \"generator function\" creates \"generator object\"\nlet generator = generateSequence();\nalert(generator); // [object Generator]"
      ],
      "text": [
        "обычные функции могут возвращать один результат, функции-генераторы возвращают каждый раз через yeld"
      ],
      "link": [
        "https://javascript.info/generators",
        "https://www.tutorialspoint.com/explain-generator-functions-in-javascript",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction"
      ]
    },
    "difficulty": "junior",
    "question": "Что такое generator functions?",
    "competence": ["common questions", "javascript"],
    "description": "генераторы generator GeneratorFunction",
    "popularity": "4",
    "type": "question",
    "tableIndex": 57,
    "_id": { "$oid": "60de0704e2c8c53194aee4ed" }
  },
  {
    "id": "D9sYzyuFOJRvgSwFr9Fn",
    "answer": { "link": [], "text": [".statsWith()"], "code": [] },
    "difficulty": "junior",
    "tableIndex": 58,
    "description": "Первая буква",
    "question": "Как проверить первый символ строки?",
    "competence": ["javascript"],
    "popularity": "4",
    "type": "question"
  },
  {
    "id": "DLejr8fkMKMfXbZJan1Y",
    "question": "Как запустить проверку валидности проекта?",
    "difficulty": "middle",
    "answer": { "text": ["eslint ./src"], "code": [], "link": [] },
    "competence": ["javascript", "frontend"],
    "popularity": "3",
    "type": "question",
    "description": "запустить проверку линта"
  },
  {
    "id": "DaPTOayYXGDTkfHA1buy",
    "difficulty": "junior",
    "tableIndex": 60,
    "question": "Что такое HTTP-методы? (REST)",
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee480" },
    "type": "question",
    "description": "Перечислите все HTTP-методы, которые вы знаете, и объясните их. REST RESTFull",
    "answer": {
      "code": [
        "/UserService/users\n/UserService/addUser\n/UserService/getUser/:id"
      ],
      "link": [
        "https://www.tutorialspoint.com/restful/restful_introduction.htm",
        "https://restfulapi.net/rest-architectural-constraints/",
        "https://restfulapi.net/"
      ],
      "text": [
        "GET — получение ресурса\nPOST — создание ресурса\nPUT — обновление ресурса\nDELETE — удаление ресурса\nREST (Representational State Transfer)\n "
      ]
    },
    "competence": ["javascript"]
  },
  {
    "id": "E3L8GfBg2r8MQvFrO92u",
    "competence": ["common questions", "javascript"],
    "tableIndex": 61,
    "_id": { "$oid": "60de0704e2c8c53194aee4c4" },
    "answer": {
      "code": [
        "// Вспомогательная функция, которая создаёт объект для хранения данных\nconst buildCharObject = (str) => {\n  const charObj = {};\n  for (let char of str.replace(/[^\\w]/g).toLowerCase()) {\n    // Если объект уже содержит пару ключ-значение равную значению в цикле,\n    // увеличиваем значение на 1, в противном случае добавляем букву в качестве ключа\n    // и 1 в качестве значения\n    charObj[char] = charObj[char] + 1 || 1;\n  }\n  return charObj;\n};\n\n// Главная функция\nconst anagram = (strA, strB) => {\n  // Создаём объект для хранения strA\n  const aCharObject = buildCharObject(strA);\n  // Создаём объект для хранения strB\n  const bCharObject = buildCharObject(strB);\n  // Сравниваем количество ключей в обоих объектах\n  // (анаграммы должны иметь одинаковое количество букв)\n  if (Object.keys(aCharObject).length !== Object.keys(bCharObject).length) {\n    return false;\n  }\n  // Если оба объекта имеют одинаковое количество ключей, мы можем быть уверены,\n  // что обе строки имеют одинаковое количество символов. Теперь мы можем сравнить;\n  // оба объекта, чтобы увидеть, имеют ли они одинаковые буквы в одинаковом количестве;\n  for (let char in aCharObject) {\n    if (aCharObject[char] !== bCharObject[char]) {\n      return false;\n    }\n  }\n  // Если проверка успешна, строки являются анаграммами — возвращаем true\n  return true;\n};\n"
      ],
      "text": [
        "Надо подсчитать общее количество символом и сколько раз они встречаются в строке. Если все равно - то они анаграммы."
      ],
      "link": []
    },
    "popularity": "5",
    "type": "exercise",
    "difficulty": "junior",
    "question": "Напишите функцию, проверяющая являются ли строки анаграммами друг друга.",
    "description": "Анаграмма - из символов одной строки создается другая строка с этими же символами."
  },
  {
    "id": "ESGRBYueW6u458mCQniV",
    "popularity": "5",
    "tableIndex": 62,
    "description": "конструктор функция",
    "_id": { "$oid": "60de0704e2c8c53194aee49b" },
    "answer": {
      "link": [],
      "code": [
        "function Book(name, author) {\n  this.name = name;\n  this.author = author;\n  return this;\n}\n\nfunction Foo(Cclass, name, author) {\n  return Cclass.call({}, name, author);\n}\n\nvar book = Foo(Book, \"js\", \"petr\");\nconsole.log(book.name);"
      ],
      "text": ["Сразу через call вызываем функцию внутри и врзвращаем ответ."]
    },
    "question": "Реализовать Foo, которая будет принимать в себя функцию конструктор и параметры.",
    "type": "question",
    "difficulty": "junior",
    "competence": ["javascript"]
  },
  {
    "id": "EZxaqmQ5fwemdl0JtJsh",
    "answer": {
      "link": [
        "https://itnext.io/lazy-evaluation-in-javascript-62b8ec45e0f6",
        "https://www.codementor.io/@agustinchiappeberrini/lazy-evaluation-and-javascript-a5m7g8gs3",
        "https://stackoverflow.com/questions/37888881/are-javascript-arguments-lazily-evaluated"
      ],
      "text": [
        "Загружается и запрашивается только тогда, когда возникает в этом необходимость. Не сразу."
      ],
      "code": []
    },
    "tableIndex": 63,
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "question": "Что такое lazily evaluated?",
    "_id": { "$oid": "60de0704e2c8c53194aee4f2" },
    "difficulty": "junior",
    "type": "question",
    "description": "lazy loading, lazily evaluated, ленивая загрузка"
  },
  {
    "id": "Fv2FymfW9EUO1illJseR",
    "question": "Что такое наследование?",
    "type": "question",
    "difficulty": "junior",
    "description": "наследование ооп",
    "answer": {
      "text": [
        "Один из основных принципов ООП. ПОдразумевает возможность расширения классов путем наследования осново и добавления туда дополниптельных свойств."
      ],
      "link": ["https://habr.com/ru/post/463125/"],
      "code": []
    },
    "competence": ["common questions"],
    "popularity": "5"
  },
  {
    "id": "FyniKBNg0qsPKigT4jAh",
    "tableIndex": 65,
    "popularity": "5",
    "description": "Надо смотреть код",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4bf" },
    "answer": {
      "link": [],
      "code": [
        "var obj = {};\nfunction func(x) {\n  x = 1;\n  return x;\n}\n\nfunc(obj); // ?\nconsole.log(obj); // ?"
      ],
      "text": [
        "Функция вернёт 1, obj при этом не изменится; Несмотря на то, что объекты в JavaScript передаются в параметры функций по ссылке, obj не изменится. Внутри функции создаётся локальная переменная x, в которую изначально попадет ссылка на obj, но позже эта переменная переписывается на числовое значение 1. Т.е. меняется само значение переменной x, но меняется значение, которое находится по ссылке, переданной изначально в функцию."
      ]
    },
    "difficulty": "junior",
    "type": "question",
    "question": "Что получится в результате выполнения кода и почему?"
  },
  {
    "id": "GRtIYxEvdOQJK3VPSJvy",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee440" },
    "type": "question",
    "description": "ajax XMLHttpRequest fetch API",
    "question": "Расскажите об Ajax как можно более подробно.",
    "answer": {
      "code": [],
      "link": [
        "https://en.wikipedia.org/wiki/Ajax_(programming)",
        "https://developer.mozilla.org/en-US/docs/AJAX"
      ],
      "text": [
        "Ajax (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью Ajax веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, Ajax позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных JSON вместо XML из-за того, что JSON основан на JavaScript.\n\nРаньше для асинхронного взаимодействия использовали XMLHttpRequest API, а сейчас принято использовать fetch API."
      ]
    },
    "difficulty": "junior",
    "popularity": "3",
    "tableIndex": 66
  },
  {
    "id": "Ghei604jqu37fNcSz4pG",
    "competence": ["javascript"],
    "difficulty": "junior",
    "tableIndex": 67,
    "answer": {
      "text": ["Проходим по всей строке и заменяем"],
      "link": [],
      "code": [
        "function rle(str) {\n  const result = [str[0]];\n  let count = 1;\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] === str[i - 1]) {\n      count++;\n      if (i === str.length - 1) {\n        result.push(str[i]);\n        if (count > 1) {\n          result.push(count);\n        }\n      }\n    } else {\n      if (i > 1) {\n        result.push(str[i - 1]);\n      }\n      if (i === str.length - 1) {\n        result.push(str[i]);\n      }\n      if (count > 1) {\n        result.push(count);\n      }\n      count = 1;\n    }\n  }\n  return result.join(\"\");\n}"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4be" },
    "type": "exercise",
    "question": "«Сжатие строк»",
    "popularity": "2",
    "description": "Необходимо реализовать функцию, принимающую в аргументах строку, состоящую из букв и вернуть новую строку, в которой повторяющиеся буквы заменены количеством повторений.\n\nНапример: compress('AVVVBBBVVXDHJFFFFDDDDDDHAAAAJJJDDSLSSSDDDD'); \n > 'AV3B3V2XDHJF4D6HA4J3D2SLS3D4'\n\n"
  },
  {
    "id": "Gi5Wxu2haYcHaidvt0Sa",
    "tableIndex": 68,
    "answer": { "text": ["б) и в)\n "], "link": [], "code": [] },
    "_id": { "$oid": "60de0704e2c8c53194aee4ac" },
    "difficulty": "junior",
    "question": "Что можно сказать об этих переменных?\na=3; b=«hello»;\n ",
    "type": "question",
    "popularity": "3",
    "description": "Укажите правильные утверждения.\n а) создаются в локальном контексте\n б) создаются в глобальном контексте\n в) создание переменной без ключевого слова var — синтаксическая ошибка.",
    "competence": ["javascript"]
  },
  {
    "id": "H9nxep6x8M2pxQyNtSjh",
    "difficulty": "junior",
    "description": "@media",
    "question": "Можете ли вы привести пример свойства @media, отличного от screen?",
    "popularity": "1",
    "competence": ["javascript"],
    "type": "question",
    "answer": { "link": [], "code": [], "text": ["print\nspeech"] },
    "_id": { "$oid": "60de0704e2c8c53194aee475" },
    "tableIndex": 69
  },
  {
    "id": "HW8iih6qjGR1npLsyhz9",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee45f" },
    "description": "каррирование curry",
    "answer": {
      "code": [
        "function curry(fn) {\n    if (fn.length === 0) { \n     return fn; \n    } \n\n    function _curried(depth, args) {\n      return function(newArgument) { \n        if ((depth - 1) === 0) { \n          return fn(…args, newArgument); \n        } else {\n          return _curried(depth - 1, […args, newArgument]); \n        }\n        \n        }; \n    } \n\n    return _curried(fn.length, []); \n  } \n\n  function add(a, b) { \n    return a + b; \n  } \n\n  var curriedAdd = curry(add);\n  var addFive = curriedAdd(5);\n  var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10] ",
        "function curry(f) { // curry(f) does the currying transform\n  return function(a) {\n    return function(b) {\n      return f(a, b);\n    };\n  };\n}\n\n// usage\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1)(2) ); // 3"
      ],
      "link": [
        "https://hackernoon.com/currying-in-js-d9ddc64f162e",
        "https://javascript.info/currying-partials"
      ],
      "text": [
        "Каррирование — это паттерн, где функция с более чем одним параметром разбивается на несколько функций, которые при последовательном вызове будут накапливать все необходимые параметры по одному. Этот метод может быть полезен для облегчения чтения и написания кода, написанного в функциональном стиле. Важно отметить, что каррированная функция должна начинаться как одна функция, а затем разбиваться на последовательность функций, каждая из которых принимает один параметр.\n "
      ]
    },
    "tableIndex": 70,
    "difficulty": "junior",
    "competence": ["javascript"],
    "question": "Можете ли вы привести пример каррированной функции (curry function) и в чем их преимущество?",
    "popularity": "3"
  },
  {
    "id": "HdoUxyx7Y516ILbe45IC",
    "question": "На каком ресурсе удобно рисовать моковый дизайн?",
    "popularity": "1",
    "type": "question",
    "description": "Просто схематичное описание дизайна.",
    "difficulty": "beginner",
    "answer": { "link": [], "code": [], "text": ["draw.io"] },
    "competence": ["common questions"]
  },
  {
    "id": "HzrXIhWqjVhq4CiFqb2u",
    "type": "exercise",
    "difficulty": "junior",
    "competence": ["javascript"],
    "description": "Копирование элементов массива",
    "answer": {
      "code": [
        " function duplicate(arr) {\n   return arr.concat(arr);\n }\n\n duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]"
      ],
      "text": ["Берем массив и к нему конкатинируем еще же."],
      "link": []
    },
    "popularity": "4",
    "tableIndex": 72,
    "question": "Сделайте так, чтобы этот код работал: duplicate([1, 2, 3, 4, 5]); > [1,2,3,4,5,1,2,3,4,5]",
    "_id": { "$oid": "60de0704e2c8c53194aee44a" }
  },
  {
    "id": "IsSMKuaRbQFhtexYXzMc",
    "popularity": "2",
    "type": "question",
    "tableIndex": 73,
    "question": "Что означает CORS и какую проблему решает?",
    "_id": { "$oid": "60de0704e2c8c53194aee467" },
    "difficulty": "junior",
    "answer": {
      "link": [
        "https://habr.com/ru/company/macloud/blog/553826/",
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS",
        "https://ru.wikipedia.org/wiki/Cross-origin_resource_sharing"
      ],
      "text": ["Политика одинакового источника"],
      "code": []
    },
    "description": "CORS Cross-Origin Resource Sharing",
    "competence": ["common questions", "javascript", "frontend", "backend"]
  },
  {
    "id": "ItXYrb6Xh63Y2Flpctva",
    "difficulty": "junior",
    "question": "Что такое Promise?",
    "description": "Promise ромис",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee515" },
    "type": "question",
    "answer": {
      "text": [
        "Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»)."
      ],
      "code": [
        "let myFirstPromise = new Promise((resolve, reject) => {\n  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.\n  // In this example, we use setTimeout(...) to simulate async code.\n  // In reality, you will probably be using something like XHR or an HTML5 API.\n  setTimeout( function() {\n    resolve(\"Success!\")  // Yay! Everything went well!\n  }, 250)\n})\n\nmyFirstPromise.then((successMessage) => {\n  // successMessage is whatever we passed in the resolve(...) function above.\n  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.\n  console.log(\"Yay! \" + successMessage)\n})"
      ],
      "link": [
        "https://learn.javascript.ru/promise-basics",
        "https://frontend-stuff.com/blog/javascript-promises/",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise?retiredLocale=uk",
        "https://prognote.ru/textbook/javascript-promise/"
      ]
    },
    "popularity": "5",
    "tableIndex": 74
  },
  {
    "id": "Iw6hdzmcjGd3Z0zCZrgJ",
    "question": "В чем разница @Self, @Optional, @Host, @SkipSelf() и простым DI? (Resolution Modifiers)",
    "type": "question",
    "difficulty": "middle",
    "answer": {
      "code": [],
      "text": [
        "При инициализации приложения создаются деревья зависимостей ElementInjector для компонентов и ModuleInjector для модулей.\nПо умолчанию компонент смотрит сервис у себя, если нет, идет вверх по родителям пока не найдет.\n\n@Self - Ищет сервис только у родителя.\n\n@Optional - не вызывает ошибку, если сервис не найден.\n\n@Host - Ищет только в темлейте родителя.(It looks somewhat similar to @Self. But @Self only checks in the Injector of the current component. But the @Host checks for the dependency in the current template.)\n\n@SkipSelf() - идет почти как обычно, но пропускает первый родительский элемент."
      ],
      "link": [
        "https://medium.com/frontend-coach/self-or-optional-host-the-visual-guide-to-angular-di-decorators-73fbbb5c8658",
        "https://www.tektutorialshub.com/angular/self-skipself-optional-decorators-angular/",
        "https://stackblitz.com/edit/angular-self-optional-skipself-example?file=src/app/app.component.ts"
      ]
    },
    "popularity": "4",
    "description": "DI Dependency injection Resolution Modifiers",
    "tableIndex": 76,
    "competence": ["angular"]
  },
  {
    "id": "JFtybyPf91Xg3kdxBkfB",
    "type": "question",
    "question": "Можете ли вы привести пример деструктуризации объекта или массива?",
    "description": "Деструктуризация",
    "tableIndex": 76,
    "difficulty": "junior",
    "answer": {
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",
        "https://ponyfoo.com/articles/es6-destructuring-in-depth"
      ],
      "text": [
        "Деструктуризация — это выражение, доступное в ES6, которое предоставляет краткий и удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные.\n\n Деструктуризация массива\n // Присваивание переменной\n const foo = [‘one’, ‘two’, ‘three’];\n const [one, two, three] = foo;\n console.log(one); // “one”\n console.log(two); // “two”\n console.log(three); // “three”\n // Перестановка переменных местами\n let a = 1;\n let b = 3;\n [a, b] = [b, a];\n console.log(a); // 3\n console.log(b); // 1\n\n Деструктуризация объекта\n // Присваивание переменной\n const o = { p: 42, q: true };\n const { p, q } = o;\n console.log(p); // 42\n console.log(q); // true\n "
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee45d" },
    "competence": ["javascript"],
    "popularity": "5"
  },
  {
    "id": "JPHYu3QKa4LMysIkdaJr",
    "description": "HOF High order functions функции высшего порядка map filter reduce",
    "_id": { "$oid": "60de0704e2c8c53194aee520" },
    "answer": {
      "code": [
        "const strArray = ['JavaScript', 'Python', 'PHP', 'Java', 'C'];\n\nfunction mapForEach(arr, fn) {\n  const newArray = [];\n  for(let i = 0; i < arr.length; i++) {\n    newArray.push(\n      fn(arr[i])\n    );\n  }\n  return newArray;\n}\nconst lenArray = mapForEach(strArray, function(item) {\n  return item.length;\n});\n// выводит [ 10, 6, 3, 4, 1 ]\nconsole.log(lenArray);"
      ],
      "text": [
        "Функции высшего порядка — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.\n\nНапример, встроенные функции JavaScript Array.prototype.map, Array.prototype.filter и Array.prototype.reduce являются функциями высшего порядка."
      ],
      "link": [
        "https://frontend-stuff.com/blog/higher-order-functions/",
        "https://habr.com/ru/company/ruvds/blog/428570/",
        "https://medium.com/webbdev/func-1afa4a8220a7"
      ]
    },
    "question": "Что такое High order functions?",
    "difficulty": "junior",
    "tableIndex": 77,
    "type": "question",
    "popularity": "4",
    "competence": ["javascript"]
  },
  {
    "id": "JSVczdxBDyp5u1FK2ClZ",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection",
        "https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th",
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent"
      ],
      "text": [
        "Feature\n detection (определение возможностей браузера) <br>\n Определение возможностей браузера заключается в определении, поддерживает\n ли браузер определенный блок кода - и если нет, то будет выполняться другой\n код, так что браузер всегда сможет обеспечить работоспособность и\n предотвратить сбои/ошибки в некоторых браузерах. Например: <br>\n if ('geolocation' in navigator) { <br>\n // Можно использовать navigator.geolocation <br>\n } else { <br>\n // Обработка отсутствия возможности <br>\n } <br>\n Modernizr - отличная библиотека для обработки таких функций. <br>\n Feature inference (предположение возможностей) <br>\n Предположение возможностей проверяет на наличие определенных возможностей,\n как и предыдущий подход, но использует другую функцию, которая предполагает,\n что определенная возможность уже существует, например: <br>\n if (document.getElementsByTagName) { <br>\n element = document.getElementById(id); <br>\n } <br>\n Этот подход не рекомендуется. Первый подход более надежен. <br>\n Строка User Agent <br>\n Это строка, сообщаемая браузером, которая позволяет узлам сетевого\n протокола определить тип приложения, операционную систему, поставщика\n программного обеспечения или версию программного обеспечения пользователя от\n которого исходит запрос. Доступ к ней можно получить через\n navigator.userAgent. Тем не менее, строка User Agent сложна для обработки и\n может быть подделана. Например, браузер Chrome идентифицируется как Chrome,\n так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны\n проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте\n этого метода."
      ],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee43f" },
    "difficulty": "junior",
    "popularity": "3",
    "description": "",
    "question": "В\n чем разница между feature detection (определение возможностей браузера),\n feature inference (предположение возможностей) и анализом строки user-agent?",
    "type": "question",
    "competence": ["common questions"]
  },
  {
    "id": "K1Q2gEnciu6dCfSN5U6w",
    "_id": { "$oid": "60de0704e2c8c53194aee44b" },
    "popularity": "2",
    "description": "condition ? true : false",
    "type": "question",
    "question": "Почему тернарный оператор так называется?",
    "tableIndex": 80,
    "competence": ["javascript"],
    "answer": {
      "code": [],
      "text": [
        "“Тернарный” означает три. Троичное выражение принимает три операнда: условие, выражение “then” и выражение “else”. Тернарные операторы не являются исключительными для JavaScript, и я не знаю, почему подобный вопрос был добавлен в этот список."
      ],
      "link": [
        "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"
      ]
    },
    "difficulty": "junior"
  },
  {
    "id": "KIyKy6lHaUwRmHMDZGyQ",
    "competence": ["javascript", "html", "frontend"],
    "_id": { "$oid": "60de0704e2c8c53194aee46f" },
    "tableIndex": 81,
    "popularity": "3",
    "question": "Что такое прогрессивный рендеринг?",
    "description": "Прогрессивный рендеринг. Progressive rendering.",
    "type": "question",
    "answer": {
      "text": [
        "Progressive\nWeb App\nProgressive Loading\nИдея прогрессивной загрузки достаточно простая:\n1. Сделать первоначальную загрузку как можно быстрее\n2. Загружать UI компоненты только по мере надобности",
        "Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.\n\nДо того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.\n\nПримеры подобных технологий:\n\nЛенивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.\n\nПриоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.\n\nАсинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать в этой статье."
      ],
      "link": [
        "https://stackoverflow.com/questions/33651166/what-is-progressive-rendering",
        "http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/"
      ],
      "code": []
    },
    "difficulty": "junior"
  },
  {
    "id": "KON9zLObxM9gMwGvnKFP",
    "tableIndex": 82,
    "type": "question",
    "description": "opacity, visible: hidden, overflow: hidden",
    "competence": ["javascript", "html", "css", "frontend"],
    "answer": {
      "text": [
        "opacity отвечает за прозрачность элемента. Принимает значения от 0 до 1, при 0 — элемент не виден, .5 — полупрозрачен, 1 — полностью виден. Даже при 0 занимает место на странице.\n\nЭлемент со стилями visible: hidden так же занимает место, не видим. Но в отличие от элемента с opacity, js-события на нем не срабатывают.\n\ndisplay: none — полностью скрывает элемент, он не видим и не занимает место на странице. javascript не может получить ни width, height.\n\noverflow: hidden; — скрывает все, что попадет за его пределы.\n "
      ],
      "link": [],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee49d" },
    "question": "Чем opacity отличается от visible: hidden и что это такое, отличие от overflow: hidden?",
    "difficulty": "junior",
    "popularity": "3"
  },
  {
    "id": "Kcgo1MqGhzDW7vee07vG",
    "tableIndex": 83,
    "question": "Задача: Реализовать аналог Promise.all.",
    "type": "exercise",
    "_id": { "$oid": "60de0704e2c8c53194aee4b2" },
    "competence": ["javascript", "frontend"],
    "difficulty": "middle",
    "answer": {
      "link": [],
      "code": [
        "promiseAll([\n  new Promise((resolve) => {\n    setTimeout(() => resolve(\"foo\"), 5000);\n  }),\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"bar\"), 1000);\n  }),\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      Math.round(Math.random() * 10) % 2 === 0\n        ? resolve(\"baz\")\n        : reject(new Error());\n    }, 300);\n  }),\n])\n  .then((res) => console.log(\"RESOLVED: \", res))\n  .catch((err) => console.log(\"REJECTED: \", err));\n"
      ],
      "text": ["Надо написать"]
    },
    "popularity": "5",
    "description": "Promise.all промис"
  },
  {
    "id": "KnpKpqDU6JwxksbxyPBM",
    "popularity": "1",
    "tableIndex": 84,
    "difficulty": "middle",
    "competence": ["common questions"],
    "type": "question",
    "answer": {
      "code": [],
      "link": [
        "https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE",
        "https://habr.com/ru/post/198682/",
        "https://algorithmica.org/ru/trie",
        "https://brestprog.by/topics/trie/",
        "https://neerc.ifmo.ru/wiki/index.php?title=%D0%91%D0%BE%D1%80",
        "https://www.youtube.com/watch?v=XRZjEBoEWXk"
      ],
      "text": [
        "Что же такое бор? Строго говоря, бор — это дерево, в котором каждая вершина обозначает какую-то строку (корень обозначает нулевую строку — ε). На ребрах между вершинами написана 1 буква (в этом его принципиальное различие с суффиксными деревьями и др.), таким образом, добираясь по ребрам из корня в какую-нибудь вершину и контангенируя буквы из ребер в порядке обхода, мы получим строку, соответствующую этой вершине. Из определения бора как дерева вытекает также единственность пути между корнем и любой вершиной, следовательно — каждой вершине соответствует ровно одна строка (в дальнейшем будем отождествлять вершину и строку, которую она обозначает)."
      ]
    },
    "description": "Префиксное дерево , бор, Trie",
    "_id": { "$oid": "60de0704e2c8c53194aee4fc" },
    "question": "Что такое боры?"
  },
  {
    "id": "KpqNTPSUC4rPY7JBY7Ax",
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "description": "Factory Pattern",
    "question": "Что такое Factory Pattern в Javascript?",
    "answer": {
      "code": [
        "class BallFactory {\n  constructor() {\n    this.createBall = function(type) {\n      let ball;\n      if (type === 'football' || type === 'soccer') ball = new Football();\n      else if (type === 'basketball') ball = new Basketball();\n      ball.roll = function() {\n        return `The ${this._type} is rolling.`;\n      };\n\n      return ball;\n    };\n  }\n}\n\nclass Football {\n  constructor() {\n    this._type = 'football';\n    this.kick = function() {\n      return 'You kicked the football.';\n    };\n  }\n}\n\nclass Basketball {\n  constructor() {\n    this._type = 'basketball';\n    this.bounce = function() {\n      return 'You bounced the basketball.';\n    };\n  }\n}\n\n// creating objects\nconst factory = new BallFactory();\n\nconst myFootball = factory.createBall('football');\nconst myBasketball = factory.createBall('basketball');\n\nconsole.log(myFootball.roll()); // The football is rolling.\nconsole.log(myBasketball.roll()); // The basketball is rolling.\nconsole.log(myFootball.kick()); // You kicked the football.\nconsole.log(myBasketball.bounce()); // You bounced the basketball."
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Фабрика это способ создавать инстансы классов, используя общий промежуточный класс и определенные настройки[0]."
      ]
    },
    "type": "question",
    "difficulty": "middle"
  },
  {
    "id": "KuvFIW7XQSJjksPXCMKo",
    "answer": {
      "link": [
        "https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3",
        "https://stackoverflow.com/a/3127440/1751946"
      ],
      "code": [],
      "text": [
        "Нельзя\n в двух словах объяснить работу ключевого слова this; это одно из самых\n запутанных понятий в JavaScript. Говоря максимально простым языком, значение\n this зависит от того, как вызывается функция. Я прочитал много объяснений о\n работе this, и считаю объяснение Arnav Aggrawal наиболее понятным.\n Применяются следующие правила:<br>\n 1. Если ключевое слово new используется при вызове функции, this внутри\n функции является совершенно новым объектом.<br>\n 2. Если для вызова/создания функции используются apply, call или bind, то\n this внутри функции — это объект, который передается в качестве\n аргумента.<br>\n 3. Если функция вызывается как метод, например, obj.method(), то this — это\n объект, к которому принадлежит функция.<br>\n 4. Если функция вызывается без контекста, то есть она вызывается без\n условий, описанных в пунктах выше, то this является глобальным объектом. В\n браузере это объект window. В строгом режиме (’use strict’), this будет\n undefined вместо глобального объекта.<br>\n 5. Если применяются несколько из вышеперечисленных правил, то правило,\n которое выше выигрывает и устанавливает значение this.<br>\n 6. Если функция является стрелочной функцией, то она игнорирует все\n вышеописанные правила и получает значение this из лексического окружения во\n время ее создания.<br>\n "
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee431" },
    "competence": ["javascript", "typescript"],
    "difficulty": "junior",
    "description": "",
    "question": "Объясните,\n как this работает в JavaScript",
    "popularity": "5",
    "type": "question"
  },
  {
    "id": "Lbp2IhRGlHsoNfTL5Hg2",
    "difficulty": "junior",
    "popularity": "3",
    "description": "хэш-таблица, ассоциативный массив",
    "type": "question",
    "competence": ["common questions", "javascript"],
    "tableIndex": 87,
    "answer": {
      "link": [],
      "text": [
        "Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: \"словарь\", \"мап\" (от слова map). В разных языках ему соответствуют разные типы данных. В JavaScript — это Object, в других языках:\n\nСтруктура данных, которая позволяет хранить пары ключ-значение и выполнять три операции над ними: добавление новой пары, поиск значение по ключу и удаление пары по ключу.\n "
      ],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4cb" },
    "question": "Что-такое хэш-таблица?"
  },
  {
    "id": "MDQhdrkfb6wyPacu02x1",
    "_id": { "$oid": "60de0704e2c8c53194aee4a8" },
    "difficulty": "junior",
    "type": "exercise",
    "answer": {
      "code": [
        "function getObj(arr) {\n  var obj = {};\n  arr.forEach(function (item) {\n    obj[item.name] = item.value;\n  });\n  return obj;\n}"
      ],
      "link": [],
      "text": [""]
    },
    "tableIndex": 88,
    "popularity": "5",
    "competence": ["javascript"],
    "description": "let arr = [\n  { name: \"width\", value: 10 },\n  { name: \"height\", value: 20 },\n];\n\n// на выходе объект  {width: 10, height: 20}",
    "question": "Напишите код, который сделает из массива объект."
  },
  {
    "id": "MTt6Tugu4g1G2hXUuURl",
    "answer": {
      "text": [
        "Полиморфизм — свойство системы, позволяющее иметь множество реализаций одного интерфейса. Ничего непонятно. Обратимся к трансформерам.\n\nПоложим, у нас есть три трансформера: Оптимус, Мегатрон и Олег. Трансформеры боевые, стало быть обладают методом attack(). Игрок, нажимая у себя на джойстике кнопку «воевать», сообщает игре, чтобы та вызвала метод attack() у трансформера, за которого играет игрок. Но поскольку трансформеры разные, а игра интересная, каждый из них будет атаковать каким-то своим способом. Скажем, Оптимус — объект класса Автобот, а Автоботы снабжаются пушками с плутониевыми боеголовками (да не прогневаются фанаты трансформеров). Мегатрон — Десептикон, и стреляет из плазменной пушки. Олег — басист, и он обзывается. А в чем польза?\n\nПольза полиморфизма в данном примере заключается в том, что код игры ничего не знает о реализации его просьбы, кто как должен атаковать, его задача просто вызвать метод attack(), сигнатура которого одинакова для всех классов персонажей. Это позволяет добавлять новые классы персонажей, или менять методы существующих, не меняя код игры. Это удобно."
      ],
      "link": ["https://habr.com/ru/post/463125/"],
      "code": []
    },
    "question": "Что такое полиморфизм?",
    "description": "Полиморфизм ооп",
    "competence": ["common questions", "javascript"],
    "popularity": "5",
    "difficulty": "junior",
    "type": "question"
  },
  {
    "id": "MwxMKWUO5kGqvKtYZMjR",
    "question": "Что такое Façade Pattern в Javascript?",
    "description": "Façade Pattern - Facade - Fasade - Фасад",
    "answer": {
      "text": [
        "Это шаблон структурного проектирования, который широко используется в библиотеках JavaScript. \n\nОн используется для предоставления унифицированного и более простого общедоступного интерфейса для простоты использования, который защищает от сложностей его подсистем или подклассов.\n\nИспользование этого шаблона очень распространено в таких библиотеках, как jQuery.\nВ этом примере мы создаем общедоступный API с классом ComplaintRegistry. Он предоставляет только один метод для использования клиентом, то есть registerComplaint. Он внутренне обрабатывает создание экземпляров необходимых объектов ProductComplaint или ServiceComplaint на основе аргумента типа. Он также выполняет все другие сложные функции, такие как создание уникального идентификатора, сохранение жалобы в памяти и т. д. Но все эти сложности скрыты с помощью шаблона фасада."
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "code": [
        "let currentId = 0;\n\nclass ComplaintRegistry {\n  registerComplaint(customer, type, details) {\n    const id = ComplaintRegistry._uniqueIdGenerator();\n    let registry;\n    if (type === 'service') {\n      registry = new ServiceComplaints();\n    } else {\n      registry = new ProductComplaints();\n    }\n    return registry.addComplaint({ id, customer, details });\n  }\n\n  static _uniqueIdGenerator() {\n    return ++currentId;\n  }\n}\n\nclass Complaints {\n  constructor() {\n    this.complaints = [];\n  }\n\n  addComplaint(complaint) {\n    this.complaints.push(complaint);\n    return this.replyMessage(complaint);\n  }\n\n  getComplaint(id) {\n    return this.complaints.find(complaint => complaint.id === id);\n  }\n\n  replyMessage(complaint) {}\n}\n\nclass ProductComplaints extends Complaints {\n  constructor() {\n    super();\n    if (ProductComplaints.exists) {\n      return ProductComplaints.instance;\n    }\n    ProductComplaints.instance = this;\n    ProductComplaints.exists = true;\n    return this;\n  }\n\n  replyMessage({ id, customer, details }) {\n    return `Complaint No. ${id} reported by ${customer} regarding ${details} have been filed with the Products Complaint Department. Replacement/Repairment of the product as per terms and conditions will be carried out soon.`;\n  }\n}\n\nclass ServiceComplaints extends Complaints {\n  constructor() {\n    super();\n    if (ServiceComplaints.exists) {\n      return ServiceComplaints.instance;\n    }\n    ServiceComplaints.instance = this;\n    ServiceComplaints.exists = true;\n    return this;\n  }\n\n  replyMessage({ id, customer, details }) {\n    return `Complaint No. ${id} reported by ${customer} regarding ${details} have been filed with the Service Complaint Department. The issue will be resolved or the purchase will be refunded as per terms and conditions.`;\n  }\n}\n\n// usage\nconst registry = new ComplaintRegistry();\n\nconst reportService = registry.registerComplaint('Martha', 'service', 'availability');\n// 'Complaint No. 1 reported by Martha regarding availability have been filed with the Service Complaint Department. The issue will be resolved or the purchase will be refunded as per terms and conditions.'\n\nconst reportProduct = registry.registerComplaint('Jane', 'product', 'faded color');\n// 'Complaint No. 2 reported by Jane regarding faded color have been filed with the Products Complaint Department. Replacement/Repairment of the product as per terms and conditions will be carried out soon.'"
      ]
    },
    "popularity": "4",
    "type": "question",
    "difficulty": "middle",
    "competence": ["common questions", "javascript"]
  },
  {
    "id": "NU4LB9xHGMiX8YLrLBZ3",
    "competence": ["javascript"],
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee4eb" },
    "difficulty": "junior",
    "question": "Что такое  __proto__ ?",
    "description": "__proto__  Class.prototype prototype",
    "type": "question",
    "tableIndex": 91,
    "answer": {
      "text": [
        "reference to Class.prototype\n\nЕсть свойство prototype - оно смотрит на родителя, есть __proto__, которое смотрит на родительский класс."
      ],
      "code": [],
      "link": [
        "https://frontend-stuff.com/blog/object-oriented-programming/",
        "https://www.tutorialsteacher.com/javascript/prototype-in-javascript",
        "https://habr.com/ru/post/518360/",
        "https://overcoder.net/q/25088/proto-vs-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF-%D0%B2-javascript",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto#browser_compatibility",
        "https://www.youtube.com/watch?v=b55hiUlhAzI"
      ]
    }
  },
  {
    "id": "NqxkaRrDoLbicn9dYTsI",
    "answer": {
      "text": [
        "Это важнейший поведенческий шаблон проектирования, который определяет зависимости типа «один ко многим» между объектами, так что, когда один объект (издатель) меняет свое состояние, все остальные зависимые объекты (подписчики) получают уведомление и автоматически обновляются. Это также называется шаблоном PubSub (издатель/подписчики) или диспетчером событий/прослушивателями. Издателя иногда называют субъектом, а подписчиков иногда называют наблюдателями.\n\nСкорее всего, вы уже немного знакомы с этим шаблоном, если использовали addEventListener или jQuery .on для написания кода обработки даже. Это также оказывает влияние на реактивное программирование (вспомните RxJS).\n\nВ примере мы создаем простой класс Subject, который имеет методы для добавления и удаления объектов класса Observer из коллекции подписчиков. Кроме того, метод огня для распространения любых изменений в объекте класса Subject подписанным наблюдателям. Класс Observer, с другой стороны, имеет свое внутреннее состояние и метод для обновления своего внутреннего состояния на основе изменений, распространяемых от субъекта, на который он подписан."
      ],
      "code": [
        "class Subject {\n  constructor() {\n    this._observers = [];\n  }\n\n  subscribe(observer) {\n    this._observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n    this._observers = this._observers.filter(obs => observer !== obs);\n  }\n\n  fire(change) {\n    this._observers.forEach(observer => {\n      observer.update(change);\n    });\n  }\n}\n\nclass Observer {\n  constructor(state) {\n    this.state = state;\n    this.initialState = state;\n  }\n\n  update(change) {\n    let state = this.state;\n    switch (change) {\n      case 'INC':\n        this.state = ++state;\n        break;\n      case 'DEC':\n        this.state = --state;\n        break;\n      default:\n        this.state = this.initialState;\n    }\n  }\n}\n\n// usage\nconst sub = new Subject();\n\nconst obs1 = new Observer(1);\nconst obs2 = new Observer(19);\n\nsub.subscribe(obs1);\nsub.subscribe(obs2);\n\nsub.fire('INC');\n\nconsole.log(obs1.state); // 2\nconsole.log(obs2.state); // 20"
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ]
    },
    "difficulty": "middle",
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "type": "question",
    "description": "Observer Pattern",
    "question": "Что такое Observer Pattern в Javascript?"
  },
  {
    "id": "Ny0dOVaPgf0I3ItMuzLx",
    "answer": {
      "text": [
        "Это как в rxjs Observable Subject BehaviourSubject\nМожно подписать компоненты, они наблюдают за изменениями и изменения прокидывается ко всем, кто за ними наблюдает"
      ],
      "link": [],
      "code": []
    },
    "question": "Что такое observer pattern?",
    "competence": ["common questions", "javascript"],
    "description": "observer ",
    "popularity": "4",
    "type": "question",
    "difficulty": "senior"
  },
  {
    "id": "NzAPv7lDVHU8aBmTTuiy",
    "difficulty": "middle",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "text": [
        "async => asyncGeneratorStep in Babel (так асинхронная функция отображается в файле после пропуск через полифил)"
      ],
      "code": []
    },
    "question": "Как в Babel выглядит async функция?",
    "type": "question",
    "popularity": "1",
    "description": "Как в Babel выглядит async функция?"
  },
  {
    "id": "OFOpmVC70kOrPuPWCeJi",
    "answer": {
      "text": [
        "свойство прописать в div и можно писать прямо в диве как в инпуте(spellcheck=\"false\" убирает проверку на ввоимые слова)"
      ],
      "code": [],
      "link": []
    },
    "description": "contenteditable in html",
    "competence": ["html", "css", "frontend"],
    "type": "question",
    "difficulty": "beginner",
    "question": "Что за свойство contenteditable?",
    "popularity": "1"
  },
  {
    "id": "OOZumNsxsf2CMYgiJSKl",
    "question": "Насколько вы опытны в работе с промисами (promises) и/или их полифилами?",
    "popularity": "3",
    "competence": ["javascript"],
    "tableIndex": 96,
    "description": "промис promise полифил",
    "_id": { "$oid": "60de0704e2c8c53194aee451" },
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "text": [
        "Обладаю практическими знаниями о них. Промис — это объект, который может вернуть одно значение в будущем: либо выполненное значение, либо причина, по которой оно не было выполнено (например, произошла ошибка сети). Промис может находиться в одном из 3 возможных состояний: выполнено, отклонено или ожидает выполнения. При использовании промисов можно добавлять callback-функции для обработки выполненного значения или причины отказа.\n\nНекоторыми распространенными полифилами являются $.deferred, Q и Bluebird, но не все они соответствуют спецификации. ES2015 поддерживает промисы “из коробки”, и в настоящее время полифилы обычно не нужны.\n "
      ],
      "code": [],
      "link": [
        "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261"
      ]
    }
  },
  {
    "id": "OV2Bul5DgPjOIY0CGoQl",
    "competence": ["javascript"],
    "popularity": "5",
    "difficulty": "middle",
    "answer": {
      "code": [
        "// we have an array with the name and surname\nlet arr = [\"John\", \"Smith\"]\n\n// destructuring assignment\n// sets firstName = arr[0]\n// and surname = arr[1]\nlet [firstName, surname] = arr;\n\nalert(firstName); // John\nalert(surname);  // Smith"
      ],
      "text": [
        "Раскрывает массив или обьект и присваивает значения из массива"
      ],
      "link": [
        "https://dmitripavlutin.com/javascript-object-destructuring/",
        "https://javascript.info/destructuring-assignment"
      ]
    },
    "question": "Что такое деструктулизация?",
    "description": "Деструктивное присваивание",
    "type": "question"
  },
  {
    "id": "OZ02wMlKxpHqt27XJk0R",
    "_id": { "$oid": "60de0704e2c8c53194aee499" },
    "answer": {
      "text": [
        "Пройти массив циклом и сложить все имеющиеся там цифры и вычесть из числа, полученного по формуле (n + 1) / (n / 2)."
      ],
      "code": [],
      "link": []
    },
    "difficulty": "junior",
    "competence": ["javascript"],
    "tableIndex": 98,
    "popularity": "3",
    "type": "exercise",
    "question": "Числа от 1 до 100 лежат в массиве, они хаотично перемешанные, оттуда изъяли одно число, надо найти, что это за число. Алгоритм не должен превышать O(n^2) сложности.",
    "description": "Найти число"
  },
  {
    "id": "Oz3DOPJuQ5JCy6pAspQY",
    "answer": {
      "text": [
        "Ее можно решать прямо в лоб, перебирая в цикле все аргументы, но мы поступим умнее.\n\n\n "
      ],
      "link": ["https://itnan.ru/post.php?c=1&p=351874"],
      "code": [
        "function getStr() {\n\treturn [].slice.call(arguments, 1).join(arguments[0])\n}"
      ]
    },
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee48b" },
    "difficulty": "junior",
    "popularity": "3",
    "question": "Дана функция, она принимает в качестве аргументов строки '*', '1', 'b', '1c', реализуйте ее так, что бы она вернула строку '1*b*1c'",
    "tableIndex": 99,
    "type": "exercise",
    "description": "1*b*1c"
  },
  {
    "id": "PPNVLsLJp1YaBIxIuKut",
    "competence": ["javascript", "html"],
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "(data-attr, getAttribute(attr) | DOMStringMap{resize: col} e.target.dataset.resize)"
      ]
    },
    "question": "Что такое data атрибуты?",
    "description": "Как они используются и для чего? data",
    "difficulty": "junior",
    "type": "question",
    "tableIndex": 100,
    "popularity": "4"
  },
  {
    "id": "PUD6Y8wlnEaUSAq92Z6v",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const"
      ],
      "text": [
        "Переменные, объявленные при помощи ключевого слова var, относятся к области видимости функции, в которой они созданы. Или, если они созданы вне какой-либо функции — к глобальному объекту. let и const относятся к блочной области видимости — это означает, что они доступны только в пределах ближайшего набора фигурных скобок (функция, блок if-else или цикл for)."
      ],
      "code": [
        "function foo() {\n  // Все переменные доступны внутри функции.\n  var bar = \"bar\";\n  let baz = \"baz\";\n  const qux = \"qux\";\n  console.log(bar); // bar\n  console.log(baz); // baz\n  console.log(qux); // qux\n}\n\nconsole.log(bar); // ReferenceError: bar is not defined\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\nif (true) {\n  var bar = \"bar\";\n  let baz = \"baz\";\n  const qux = \"qux\";\n}\n// переменные, объявленные при помощи var, доступны в любом месте функции.\n\nconsole.log(bar); // bar\n// переменные, объявленные при помощи let и const не доступны вне блока, в котором были определены.\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\n\n// var позволяет поднимать переменные, что означает, что на них можно\n// ссылаться в коде до их объявления. let и const не позволяют этого, и выдают\n// ошибку.\n\nconsole.log(foo); // undefined\nvar foo = \"foo\";\nconsole.log(baz); // ReferenceError: can’t access lexical declaration 'baz' before initialization\nlet baz = \"baz\";\nconsole.log(bar); // ReferenceError: can’t access lexical declaration 'bar' before initialization\nconst bar = \"bar\";\n// Переопределение переменной с помощью var не вызовет ошибку, в отличие от let и const.\nvar foo = \"foo\";\nvar foo = \"bar\";\nconsole.log(foo); // “bar”\nlet baz = \"baz\";\nlet baz = \"qux\"; // Uncaught SyntaxError: Identifier ‘baz’ has already been declared\n// let отличается от const тем, что изменять значение const нельзя.\n// Это нормально.\nlet foo = \"foo\";\nfoo = \"bar\";\n// Это вызывает исключение.\nconst baz = \"baz\";\nbaz = \"qux\";"
      ]
    },
    "popularity": "5",
    "description": "let var const",
    "_id": { "$oid": "60de0704e2c8c53194aee458" },
    "question": "В чем различие между переменными, созданными при помощи `let`, `var` и `const`?",
    "competence": ["javascript"],
    "type": "question",
    "tableIndex": 101,
    "difficulty": "junior"
  },
  {
    "id": "PtApcR5V8eemQbgkcjLr",
    "type": "question",
    "description": "var foo = 10 + '20'",
    "tableIndex": 102,
    "answer": { "text": ["1020"], "link": [], "code": [] },
    "question": "Чему равно foo? var foo = 10 + '20'",
    "competence": ["javascript"],
    "popularity": "4",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee481" }
  },
  {
    "id": "Pxsh7XJOa8BTiWofuAZ2",
    "popularity": "2",
    "type": "question",
    "question": "Что такое величина rem?",
    "description": "root em",
    "difficulty": "junior",
    "competence": ["html", "css"],
    "answer": {
      "text": ["размер шрифта относительный использовать root em"],
      "code": [],
      "link": []
    }
  },
  {
    "id": "QAtNMBy6kgEzejh94eYW",
    "question": "Как работает optimizing compiler в js?",
    "tableIndex": 104,
    "popularity": "3",
    "answer": {
      "text": [
        "AST Abstract syntax tree, tree shaking, все лишнее и неиспользуемое сбрасывается во время компиляции"
      ],
      "link": [
        "https://codeburst.io/javascript-compiler-optimization-techniques-only-for-experts-58d6f5f958ca",
        "https://blog.logrocket.com/how-javascript-works-optimizing-the-v8-compiler-for-efficiency/",
        "https://en.wikipedia.org/wiki/Abstract_syntax_tree",
        "https://leaningtech.com/a-javascript-optimising-compiler/"
      ],
      "code": []
    },
    "type": "question",
    "description": "optimizing compiler  AST",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4e8" },
    "difficulty": "middle"
  },
  {
    "id": "QNnCoC8TiIqRypaUSwOy",
    "answer": {
      "link": [],
      "text": [
        "Семантика. Позволяет более точно описать из чего состоит контент.\n\nСвязанность. Позволяет общаться с сервером новыми и инновационными способами.\n\nОфлайн и хранилище. Позволяют страницам хранить данные локально на клиентской стороне и более эффективно работать в офлайне.\n\nМультимедиа. Ставит создание видео и аудио на первое место в вебе. 2D- и 3D-графика и эффекты. Позволяет расширить возможности презентации.\n\nПроизводительность и интеграция. Обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.\n\nДоступ к устройствам. Позволяет взаимодействовать с различными устройствами ввода и вывода.\n\nСтилизация. Позволяет создавать более сложные темы оформления.\n "
      ],
      "code": []
    },
    "description": "HTML5",
    "question": "Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?",
    "difficulty": "junior",
    "type": "question",
    "tableIndex": 105,
    "popularity": "3",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4d2" }
  },
  {
    "id": "QWnIdqdjuKLPnu329EoI",
    "type": "question",
    "competence": ["javascript"],
    "answer": {
      "code": [],
      "text": [
        "== - нестрогое равенство\n=== - строгое равенство (приводит к типу)"
      ],
      "link": ["https://learn.javascript.ru/comparison"]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee50d" },
    "popularity": "3",
    "difficulty": "middle",
    "tableIndex": 106,
    "description": "== ===",
    "question": "Различие операторов сравнения == ===?"
  },
  {
    "id": "QkM5mFj3BNZLnFiCIE4U",
    "description": "heap ",
    "question": "Что такое heap в js?",
    "answer": {
      "text": [
        "Есть 2 области памяти - куча и стек. Куча - это просто память из которой можно выделять сколько-то байт под ваши объекты. Где они будут в куче вы заранее знать не можете. Стек же используется для вызовов функций, передачи параметров и для локальных переменных. В стеке нельзя выделить байты из середины - байты всегда выделяются с одного конца и освобождать можно только крайнюю (последнюю выделенную) область. Стек - он как тупиковая ветка железной дороги. Можно туда загонять новые вагоны и удалять оттуда, но только с конца.\n\nТут должно быть понятно, что у стека есть какая-то структура, а у кучи никакой структуры нет - поэтому она \"не структурированная\" область памяти."
      ],
      "code": [],
      "link": [
        "https://qna.habr.com/q/843499",
        "https://ru.wikipedia.org/wiki/%D0%9A%D1%83%D1%87%D0%B0_(%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C)"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4d7" },
    "tableIndex": 107,
    "popularity": "3",
    "type": "question",
    "difficulty": "junior",
    "competence": ["javascript"]
  },
  {
    "id": "QxUkf5SX5v5wsdkiorjp",
    "question": "Что выведется в результате?",
    "popularity": "5",
    "type": "question",
    "tableIndex": 108,
    "_id": { "$oid": "60de0704e2c8c53194aee4a9" },
    "answer": {
      "text": [""],
      "link": [],
      "code": [
        "var i = 10;\n\nvar array = [];\n\nwhile (i--) {\n  (function (i) {\n    var i = i;\n    array.push(function () {\n      return i + i;\n    });\n  })(i);\n}\n\nconsole.log([array[0](),array[1](),])\n\n// [18, 16], так как за счет функции\n// (function (i) {})(i); создает замыкание, var i = i — уже принадлежат областям видимости в замыканиях.\n\n// function() { return i + i; }\n// в начале поищет в своей области видимости i, не найдя, подымется на уровень\n// выше и там найдет его. Из функции вернется сумма, которая будет положена в\n// массив последним элементом."
      ]
    },
    "competence": ["javascript"],
    "description": "замыкание closure",
    "difficulty": "junior"
  },
  {
    "id": "REc4jqjCIcc7wLnvZKg5",
    "popularity": "5",
    "question": "Найдите сумму вершин дерева.",
    "competence": ["javascript"],
    "answer": {
      "text": [
        "// Очень похоже на предыдущую задачу, только требуется найти сумму значений.  Через рекурсию:\nfunction getTreeSum(node) {\n  let sum = node.value;\n  if (Array.isArray(node.children)) {\n    node.children.forEach((item) => (sum += getTreeSum(item)));\n  }\n  return sum;\n}\n// Как видно не только задача, но и её решение практически идентичны\n// предыдущей задаче.\n// Также, как и предыдущую её можно решить без рекурсии, обойдясь циклом,\n// приводить его не буду, т.к. оно тоже практически идентично предыдущей задаче.\n"
      ],
      "code": [],
      "link": []
    },
    "tableIndex": 109,
    "_id": { "$oid": "60de0704e2c8c53194aee4ba" },
    "type": "exercise",
    "difficulty": "middle",
    "description": "Сумма вершины дерева"
  },
  {
    "id": "RIWB91aVtLtPlyWVuwWH",
    "difficulty": "middle",
    "popularity": "5",
    "type": "question",
    "answer": {
      "code": [],
      "link": [],
      "text": ["В одном логика, в другом отображение"]
    },
    "question": "В чем разлиция Dump components/smart components?",
    "description": "Глупый и умный компоненты",
    "competence": ["common questions", "javascript", "frontend"]
  },
  {
    "id": "RKykKx8IpQoDHQLI8Bty",
    "tableIndex": 111,
    "answer": {
      "text": [""],
      "code": [
        ".clear {\n  clear: both;\n  font-size: 0;\n  overflow: hidden; /* для IE */\n}",
        ".wraprightcol:after {\n  content: \".\";\n  display: block;\n  height: 0;\n  clear: both;\n  visibility: hidden;\n}"
      ],
      "link": []
    },
    "type": "question",
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee473" },
    "question": "Какие вы знаете методы запрета обтекания (clearing) и в каких случаях они применяются?",
    "competence": ["javascript"],
    "description": "обтекание clearing",
    "difficulty": "junior"
  },
  {
    "id": "Rg7UphtQow2bbE66VC4H",
    "competence": ["javascript"],
    "answer": {
      "code": [
        "let arr = [\"kot\", \"tok\", \"okt\"],\n  arr1 = [\"kot\", \"tok\", \"ott\"];\n\nfunction sameWords(arr) {\n  let word1, word2;\n  for (let i = 0; i < arr.length - 1; i++) {\n    word1 = 0;\n    word2 = 0;\n    if (arr[i].length !== arr[i + 1].length) {\n      return false;\n    } else {\n      for (let j = 0; j < arr[i].length; j++) {\n        word1 += arr[i][j].charCodeAt(0);\n        word2 += arr[i + 1][j].charCodeAt(0);\n      }\n      if (word1 !== word2) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nconsole.log(sameWords(arr));\nconsole.log(sameWords(arr1));\n"
      ],
      "text": [""],
      "link": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee493" },
    "description": "анаграмма",
    "tableIndex": 112,
    "question": "Есть несколько слов. Определить состоят ли они из одних и тех же букв('кот','ток', 'окт').",
    "type": "exercise",
    "difficulty": "junior",
    "popularity": "4"
  },
  {
    "id": "RqDGmtmHF4si2DEiK495",
    "answer": {
      "code": [
        "function isEqualSymbols(str1, str2) {\n  if (str1.length !== str2.length) {\n    return false;\n  }\n  if (str1.split(\"\").sort().join(\"\") === str2.split(\"\").sort().join(\"\")) {\n    return true;\n  }\n  return false;\n}"
      ],
      "text": [
        "Необходимо написать функцию, принимающую в аргументах две строки и возвращающую true, если эти строки состоят из идентичных букв и false в противном случае.\n\nНапример:\n  isEqualSymbols('кот', 'ток'); // =&gt; true\n  isEqualSymbols('кот', 'тик'); // =&gt; false",
        "  Этот вариант решения исходит из того, что каждый символ уникален сам по\n  себе и если в одной из строк встречаются повторяющиеся символы, а в другой\n  нет, то это разные наборы символов и в результате должно вернуться false.\n  Если же будет необходимо исходить из того, что символы не уникальны сами по\n  себе и повторные символы должны игнорироваться, то можно предварительно\n  уникализировать символы в обоих строках, воспользовавшись одним из решений из\n  задачи об уникализации значений в массиве."
      ],
      "link": []
    },
    "tableIndex": 113,
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4bc" },
    "popularity": "4",
    "type": "exercise",
    "difficulty": "junior",
    "description": "Типа анаграммы тоже. Проверить равны ли алфавиты.",
    "question": "Идентичный алфавит."
  },
  {
    "id": "RrNUIEE4Z0zrCLtpygqB",
    "description": "Компиляторы: AOT ahead-of-time , JIT - Just-in-time",
    "question": "Что такое AOT, JIT?",
    "answer": {
      "code": [],
      "link": [
        "https://blog.bitsrc.io/the-jit-in-javascript-just-in-time-compiler-798b66e44143",
        "https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/",
        "https://notes.eatonphil.com/aot-compilation-of-javascript-with-v8.html",
        "https://betterprogramming.pub/a-brief-intro-to-ahead-of-time-aot-compilation-in-angular-f13517592cce",
        "https://itsobes.ru/JavaSobes/v-chyom-raznica-mezhdu-interpretatorom-aot-i-jit-kompilyatorom/"
      ],
      "text": [
        "AOT-компиляция происходит перед выполнением программы, не требует выделения дополнительной памяти и проходит с минимальной нагрузкой на систему.\n\n\nJIT vs AOT\nРаспространённое заблуждение в различии ahead-of-time и just-in-time рантаймов состоит в том, что во внимание берётся только время генерации нативного кода. JIT-компилирующая среда выполнения сгенерирует нативный код по запросу, когда приложение развёрнуто и запущено в целевом окружении. AOT-компилирующий рантайм формирует нативный код предварительно, как часть сборки приложения.\n\nИсточник заблуждения кроется в старом способе реализации AOT-компиляции в мейнстримных рантаймах. Они добавляли нативный код в сборку .NET считая это хорошей практикой. AOT-компилятор способен на большее.",
        "JIT и AOT - как бензиновый и электрический двигатели\nХарактеристики производительности AOT- и JIT-компиляций можно сравнить с характеристиками электрического и бензинового двигателей в машинах.\n\nЭлектрические двигатели производят движение, не тепло. JIT-скомпилированное приложение .NET затратит значительное количество ресурсов для поддержки вещей, необходимых для запуска кода, но не для самого запуска.\nНа низкой скорости электродвигатели обеспечивают больший крутящий момент, чем бензиновые, что даёт лучшее ускорение. В AOT-компилированном приложении пик производительности доступен сразу. Ваше приложение работает на полной скорости с самого начала. Однако, в конце бензиновый двигатель превзойдёт электрический также, как время исполнения JIT-компиляции опередит AOT.\nЭлектрические двигатели проще. При замене стека технологий появляется много сложностей с JIT-компиляцией. Эти сложности затрагивают разработчиков среды выполнения и её пользователей. Направление запуска нативного кода определяется динамической настройкой, которую производил рантайм на основании предыдущих характеристик программы.\nБензиновый и электрический двигатели имеют своё собственное место. Всегда приятно иметь возможность выбора, и хорошо что в .NET есть такая возможность"
      ]
    },
    "type": "question",
    "tableIndex": 114,
    "popularity": "4",
    "competence": ["common questions", "javascript"],
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee4fe" }
  },
  {
    "id": "Rtwe49c4cPQM9fnDdgz5",
    "competence": ["javascript"],
    "description": "вывести значение объекта, объект, значение",
    "popularity": "4",
    "question": "Есть функция и объект. Напишите все известные вам способы, чтобы вывести в консоли значение x из объекта используя функцию.",
    "tableIndex": 115,
    "answer": {
      "code": [
        "function f() { console.log(this.x); } \n\nlet obj = {x: 'bar'}; \n\nf.call(obj, a, b); \nf.apply(obj, [a, b]); \n\nobj.funk = function f() { console.log(this.x); } \nobj.funk(); \n\nfunction f() { console.log(this.x); }.bind(obj, a, b); \nf();"
      ],
      "text": ["\n "],
      "link": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4aa" },
    "difficulty": "junior",
    "type": "exercise"
  },
  {
    "id": "S0q7lzF1EcXNgChtwzag",
    "answer": {
      "code": [
        "//Данный объект мы будем использовать в качестве прототипа\nconst Person = {\n  name: null,\n  age: null,\n  sayHi() {\n    return `Hi! My name is ${this.name}. I'm ${this.age} years old.`\n }\n}\n\nconst Tom = {\n  //Какие-то специфичные для Тома свойства и методы\n}\n\nTom.__proto__ = Person;"
      ],
      "link": ["https://habr.com/ru/post/468157/"],
      "text": [
        "Ключевой концепцией прототипной организации является Динамически Изменяемый Объект(dynamic mutable object, dmo). DMO не нужен класс. Он сам может хранить все свои свойства и методы.",
        "На этом мы на сегодня закончим. Надеюсь, что мне удалось донести мысль о том, что отличие между классическими языками и JavaScript связано не с наличием/отсутствием классов и присутствием/отсутствием прототипов, а именно со статическим/динамическим характером организации."
      ]
    },
    "popularity": "3",
    "competence": ["common questions", "javascript"],
    "description": "класс прототип",
    "_id": { "$oid": "60de0704e2c8c53194aee522" },
    "question": "В чем заключается отличие классов в JS от классов в других языках.",
    "difficulty": "junior",
    "type": "question",
    "tableIndex": 116
  },
  {
    "id": "S9XIZVzXtSNTGWwgNAEt",
    "question": "В чем отличие null и undefined?",
    "description": "null undefined",
    "difficulty": "junior",
    "tableIndex": 117,
    "competence": ["javascript"],
    "answer": {
      "text": [
        "null - пустое значение (явно присваивается)\n\nundefined - неприсвоенное значение (по-умолчанию)\n\nВ то же время, null и undefined будут считать равными, напр.:"
      ],
      "link": [
        "https://ru.stackoverflow.com/questions/2019/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-null-%D0%B8-undefined",
        "https://senior.ua/articles/javascript--raznica-mezhdu-null-i-undefined"
      ],
      "code": [
        "var x = null;\nvar y;\nif (x == y) {\n    // выполнится\n}",
        "null >= 0 -> true\nnull == 0 -> false\nnull <= 0 -> true\n\nnull > 0 -> false\nnull < 0 -> false\n\nnull - 0 = 0\n\nundefined >= 0 -> false\nundefined == 0 -> false\nundefined <= 0 -> false\n\nundefined > 0 -> false\nundefined < 0 -> false\n\nundefined - 0 = NaN\n\nundefined >= null -> false\nundefined == null -> true\nundefined <= null -> false"
      ]
    },
    "type": "question",
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee50b" }
  },
  {
    "id": "SAjvSulUD0s19gaomdwi",
    "difficulty": "middle",
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "type": "question",
    "description": "Command Pattern",
    "answer": {
      "code": [
        "class SpecialMath {\n  constructor(num) {\n    this._num = num;\n  }\n\n  square() {\n    return this._num ** 2;\n  }\n\n  cube() {\n    return this._num ** 3;\n  }\n\n  squareRoot() {\n    return Math.sqrt(this._num);\n  }\n}\n\nclass Command {\n  constructor(subject) {\n    this._subject = subject;\n    this.commandsExecuted = [];\n  }\n  execute(command) {\n    this.commandsExecuted.push(command);\n    return this._subject[command]();\n  }\n}\n\n// usage\nconst x = new Command(new SpecialMath(5));\nx.execute('square');\nx.execute('cube');\n\nconsole.log(x.commandsExecuted); // ['square', 'cube']"
      ],
      "text": [
        "Это шаблон поведенческого проектирования, целью которого является инкапсуляция действий или операций в виде объектов. Этот шаблон допускает слабое связывание систем и классов, отделяя объекты, запрашивающие операцию или вызывающие метод, от тех, которые выполняют или обрабатывают реальную реализацию.\n\nAPI взаимодействия с буфером обмена чем-то напоминает шаблон команды. Если вы являетесь пользователем Redux, вы уже сталкивались с шаблоном команды. Действия, обеспечивающие замечательную функцию отладки с перемещением во времени, представляют собой не что иное, как инкапсулированные операции, которые можно отслеживать для повторения или отмены операций. Следовательно, путешествия во времени стали возможными.\n\nВ этом примере у нас есть класс с именем SpecialMath, который имеет несколько методов, и класс Command, который инкапсулирует команды, которые должны выполняться над его субъектом, то есть объектом класса SpecialMath. Класс Command также отслеживает все выполненные команды, что можно использовать для расширения его функциональности, включая операции типа отмены и повтора."
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ]
    },
    "question": "Что такое Chain of Command Pattern в Javascript?"
  },
  {
    "id": "SJfN776ZphQm0ecma3wC",
    "_id": { "$oid": "60de0704e2c8c53194aee4c1" },
    "answer": {
      "text": [
        "Про HTTP-методы и CRUD: \nGET — read — используется только для получения данных. \nPOST — create — создание новых сущностей. \nPUT/PATCH — update — обновление данных. \nDELETE — delete — удаление. \n\nВообще HTTP-методов сильно больше, помимо выше перечисленных есть OPTIONS,\nHEAD, TRACE и др. "
      ],
      "code": [],
      "link": []
    },
    "difficulty": "junior",
    "type": "question",
    "tableIndex": 119,
    "question": "Назовите известные вам HTTP-методы. Что такое CRUD?",
    "competence": ["javascript"],
    "description": "HTTP-метод CRUD",
    "popularity": "4"
  },
  {
    "id": "SuWzKPWtDqZdedCDgAns",
    "answer": {
      "text": [
        "Функция должна удовлетворять двум условиям, чтобы считаться «чистой»:\n\n— Каждый раз функция возвращает одинаковый результат, когда она вызывается с тем же набором аргументов\n\n— Нет побочных эффектов"
      ],
      "link": [
        "https://habr.com/ru/post/437512/",
        "https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"
      ],
      "code": []
    },
    "competence": ["common questions", "javascript"],
    "type": "question",
    "question": "Что такое чистая функция?",
    "description": "чистая функция, pure function",
    "difficulty": "junior",
    "tableIndex": 120,
    "_id": { "$oid": "60de0704e2c8c53194aee517" },
    "popularity": "5"
  },
  {
    "id": "T32KrdVYwNTq8qqpADfz",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "LocalStorage:\n Хранит данные постоянно, так как дата истечения срока хранения информации\n не устанавливается. Очищается исключительно через средства, предоставляемые\n JavaScript или посредством очистки кэша браузера и локально сохраненных\n данных в настройках браузера. \n Самый большой объем хранения данных среди всех трех технологий \n\n SessionStorage: \n Объект sessionStorage хранит данные только в рамках сессии, т.е. это\n означает, что данные сохраняются до тех пор пока не закрыт браузер или\n вкладка браузера. \n Данные никогда не отправляются на сервер. \n Объем для сохранения данных намного больше чем у Cookie - по крайней мере\n 5MB. \n \n Cookie: \n Хранит данные, которые должны быть отправлены на сервер с последующими\n запросами. Срок экспирации различающийся, в зависимости от типа и\n продолжительности срока хранения, может быть установлен либо на стороне\n сервера или на стороне клиента (хотя, как правило, на стороне сервера).\n \n Cookie, в первую очередь, предназначены для чтения на стороне сервера,\n однако могут быть прочитаны и на стороне клиента. В свою очередь localStorage\n и sessionStorage могут быть прочитаны только на стороне клиента. \n Размер должен быть менее 4KB. \n Cookie можно сделать защищенными, установив флаг httpOnly равным true. Это\n приведет к недоступности Cookie на стороне клиента. \n "
      ]
    },
    "tableIndex": 121,
    "question": "Объясните разницу между cookie, sessionStorage и localStorage.",
    "_id": { "$oid": "60de0704e2c8c53194aee46c" },
    "difficulty": "junior",
    "competence": ["javascript"],
    "description": "sessionStorage localStorage",
    "type": "question",
    "popularity": "3"
  },
  {
    "id": "T6OPQ2651SVw9XCpVQZH",
    "answer": {
      "code": [],
      "link": [
        "https://habr.com/ru/company/ruvds/blog/428566/",
        "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
        "https://learn.javascript.ru/arrow-functions-basics"
      ],
      "text": [
        "У стрелочных функций есть два основных преимущества перед традиционными функциями. Первое — это очень удобный и компактный синтаксис. Второе заключается в том, что подход к работе со значением this в стрелочных функциях выглядит интуитивно понятнее, чем в обычных функциях.\n\nВыражения стрелочных функций имеют более короткий синтаксис по сравнению с функциональными выражениями и лексически привязаны к значению this (но не привязаны к собственному this, arguments, super, или new.target). Выражение стрелочных функций не позволяют задавать имя, поэтому стрелочные функции анонимны, если их ни к чему не присвоить."
      ]
    },
    "question": "Зачем нужны стрелочные функции.",
    "_id": { "$oid": "60de0704e2c8c53194aee51a" },
    "competence": ["common questions", "javascript"],
    "tableIndex": 122,
    "description": "стрелочные функции, fat arrow function, лямбда-функция",
    "difficulty": "junior",
    "type": "question",
    "popularity": "4"
  },
  {
    "id": "T9EdVPQ9uYvl6PtjOrtL",
    "tableIndex": 123,
    "popularity": "4",
    "competence": ["javascript"],
    "question": "Какое значение возвращает данное выражение?",
    "type": "question",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee484" },
    "answer": {
      "text": ["Оно отобразится в перевернутом виде.\n\ngoh angasal a m'i"],
      "code": [],
      "link": []
    },
    "description": "\"i'm a lasagna hog\".split(\"\").reverse().join(\"\");"
  },
  {
    "id": "TIGgG2CATdxrDTOhP1Xp",
    "popularity": "4",
    "competence": ["typescript"],
    "description": "override setup() {}",
    "question": "Что такое override modifier?",
    "type": "question",
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://www.typescriptlang.org/tsconfig#noImplicitOverride",
        "https://medium.com/javascript-everyday/tip-32-ts-override-keyword-79de6341db8c",
        "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html#override-and-the---noimplicitoverride-flag"
      ],
      "text": [
        "Ситуация - у нас есть базовый класс от которого наследуется другой класс. В базовом есть метод с определенным названием. Если мы захотим переписать метод в дочернем классе, нужно использовать модификатор override. Так же можно проверять наличие этого метода в базовом.\n\nКогда метод помечен override, TypeScript всегда будет проверять, существует ли метод с таким же именем в базовом классе."
      ],
      "code": [
        "class Album {\n  setup() {}\n}\n \nclass MLAlbum extends Album {\n  override setup() {}\n}\n \nclass SharedAlbum extends Album {\n  setup() {}\nThis member must have an 'override' modifier because it overrides a member in the base class 'Album'.\n}"
      ]
    }
  },
  {
    "id": "TYcFcGe1tRmFXE6TV5tZ",
    "_id": { "$oid": "60de0704e2c8c53194aee4c2" },
    "tableIndex": 125,
    "competence": ["javascript"],
    "popularity": "5",
    "question": "Напишите функцию, проверяющую на палиндром.",
    "type": "exercise",
    "answer": {
      "code": [
        "const palindrome = str => { \n  // Меняем регистр строки на нижний \n  str = str.toLowerCase();\n  // Переворачиваем строку и возвращаем результат сравнения \n  return str === str.split('').reverse().join('');\n }"
      ],
      "link": [],
      "text": [""]
    },
    "difficulty": "junior",
    "description": "Число, буквосочетание, слово или текст, одинаково читающееся в обоих направлениях."
  },
  {
    "id": "TZudOEUrffTB5VTPbJbh",
    "tableIndex": 126,
    "question": "Функция для сортировки нечётных чисел.",
    "popularity": "4",
    "type": "question",
    "description": "Необходимо написать функцию, принимающую в аргументах массив и возвращающую новый массив, в котором отсортированы все нечетные числа по возрастанию, в то время как чётные остаются на своих местах. \nНапример: oddSort([7, 3, 4, 9, 5, 2, 17]); // => [3, 5, 4, 7, 9, 2, 17] \nНечетные числа.",
    "competence": ["javascript"],
    "difficulty": "junior",
    "answer": {
      "code": [
        "function oddSort(arr) {\n  arr.forEach((item, index) => {\n    if (item % 2 === 1) {\n      let sortNumber = item;\n      for (let i = 0; i < index; i++) {\n        if (arr[i] % 2 === 1) {\n          if (arr[i] > sortNumber) {\n            const tmp = sortNumber;\n            sortNumber = arr[i];\n            arr[i] = tmp;\n          }\n        }\n      }\n      arr[index] = sortNumber;\n    }\n  });\n  return arr;\n}"
      ],
      "text": [""],
      "link": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4bb" }
  },
  {
    "id": "TvjoTPf1M4A8tCS2bQT1",
    "type": "question",
    "competence": ["javascript"],
    "answer": { "link": [], "text": ["bar"], "code": [] },
    "difficulty": "junior",
    "popularity": "4",
    "tableIndex": 127,
    "question": "Чему равно window.foo?",
    "_id": { "$oid": "60de0704e2c8c53194aee485" },
    "description": "(window.foo || ( window.foo = \"bar\" ) )"
  },
  {
    "id": "U4CpZFMrXIlowyFMu6Gn",
    "tableIndex": 128,
    "type": "exercise",
    "_id": { "$oid": "60de0704e2c8c53194aee4c5" },
    "answer": {
      "code": [
        "const findVowels = (str) => {\n  let count = 0;\n  const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n  for (let char of str.toLowerCase()) {\n    if (vowels.includes(char)) {\n      count++;\n    }\n  }\n  return count;\n};",
        "const findVowels = (str) => {\n  const matches = str.match(/[aeiou]/gi);\n  return matches ? matches.length : 0;\n};"
      ],
      "text": [""],
      "link": []
    },
    "description": "Найти гласные.",
    "competence": ["javascript"],
    "question": "Напишите функцию, которая посчитает все гласные.",
    "difficulty": "junior",
    "popularity": "4"
  },
  {
    "id": "UhBzHD9HIzRruSCG2TOJ",
    "_id": { "$oid": "60de0704e2c8c53194aee47e" },
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events",
        "http://html5doctor.com/server-sent-events/#api",
        "https://www.html5rocks.com/en/tutorials/eventsource/basics/",
        "https://jaxenter.com/tutorial-jsf-2-and-html5-server-sent-events-104548.html"
      ],
      "code": [],
      "text": [
        "Ajax Long-Polling\n\nКлиент запрашивает веб-страницу с сервера, используя обычный HTTP.\nКлиент получает запрошенную веб-страницу и выполняет JavaScript на странице, которая запрашивает файл с сервера.\nСервер не сразу отвечает запрошенной информацией, а ждёт, пока не появится новая информация.\nКогда появляется новая информация, сервер отвечает новой информацией.\nКлиент получает новую информацию и немедленно отправляет другой запрос на сервер, перезапуская процесс.\n\nHTML Websockets\n\nКлиент запрашивает веб-страницу с сервера, используя обычный HTTP.\nКлиент получает запрошенную веб-страницу и выполняет JavaScript на странице, которая открывает соединение с сервером.\nСервер и клиент теперь могут отправлять друг другу сообщения, когда доступны новые данные (с обеих сторон).\nТрафик в реальном времени от сервера к клиенту и от клиента к серверу.\nС помощью WebSocket можно подключиться к серверу из другого домена.\nТакже можно использовать сторонний сервер веб-сокетов. Таким образом, вам нужно будет реализовать только клиентскую часть.\n\nServer-Sent Events\n\nКлиент запрашивает веб-страницу с сервера, используя обычный HTTP.\nКлиент получает запрошенную веб-страницу и выполняет JavaScript на странице, которая открывает соединение сервером.\nСервер отправляет событие клиенту, когда появляется новая информация.\nТрафик в реальном времени от сервера к клиенту.\nСоединения с серверами из других доменов возможны только при правильных настойках CORS."
      ]
    },
    "description": "Long-Polling Websockets Server-Sent Events",
    "popularity": "5",
    "type": "question",
    "question": "В чём различия между Long-Polling, Websockets и Server-Sent Events?",
    "difficulty": "junior",
    "competence": ["javascript"],
    "tableIndex": 129
  },
  {
    "id": "UnabASaTYucvVPyMNeX2",
    "question": "«Расплющивание» массива.",
    "competence": ["javascript"],
    "type": "question",
    "answer": {
      "code": [
        "function flat(arr) {\n  let res = [];\n  arr.forEach((item) => {\n    if (Array.isArray(item)) {\n      res = res.concat(flat(item));\n    } else {\n      res.push(item);\n    }\n  });\n  return res;\n}"
      ],
      "link": [],
      "text": [
        "Есть нативный метод — Array.prototype.flat. Я считаю, что именно с него надо начать ответ на этот вопрос, и только когда (именно когда, а не если) интервьюер скажет, что такое решение ему не подходит и нужно всё сделать руками, приниматься за вышеупомянутое решение через рекурсию. \n\n[1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]].flat(Infinity);"
      ]
    },
    "popularity": "4",
    "tableIndex": 130,
    "_id": { "$oid": "60de0704e2c8c53194aee4b7" },
    "difficulty": "junior",
    "description": "Необходимо написать функцию, принимающую в аргументах многомерный массив неограниченной вложенности и возвращающую новый одномерный массив, состоящий из элементов со всех уровней вложенности исходного массива. \nНапример: flat([1, [2, [3, [4,5]]]]); // => [1, 2, 3, 4, 5] "
  },
  {
    "id": "V585k3vhnoPhqMdEgeLI",
    "type": "question",
    "popularity": "4",
    "competence": ["common questions", "javascript"],
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "code": [
        "// old interface\nclass OldCalculator {\n  constructor() {\n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return term1 + term2;\n        case 'sub':\n          return term1 - term2;\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n\n// new interface\nclass NewCalculator {\n  constructor() {\n    this.add = function(term1, term2) {\n      return term1 + term2;\n    };\n    this.sub = function(term1, term2) {\n      return term1 - term2;\n    };\n  }\n}\n\n// Adapter Class\nclass CalcAdapter {\n  constructor() {\n    const newCalc = new NewCalculator();\n\n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          // using the new implementation under the hood\n          return newCalc.add(term1, term2);\n        case 'sub':\n          return newCalc.sub(term1, term2);\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n\n// usage\nconst oldCalc = new OldCalculator();\nconsole.log(oldCalc.operations(10, 5, 'add')); // 15\n\nconst newCalc = new NewCalculator();\nconsole.log(newCalc.add(10, 5)); // 15\n\nconst adaptedCalc = new CalcAdapter();\nconsole.log(adaptedCalc.operations(10, 5, 'add')); // 15;"
      ],
      "text": [
        "От слова адаптировать. Это промежуточный компонент, который позволяет, при изменении взаимодействия между другими компонентами, создать прослойку, в которой сохраняется поддержка старых взаимодействий. Например, у нас было апи. Оно устарело и появилось новое. Но существует необходимость стучаться в новое апи, используя старые методы. В этом слечае между бэком и фронтом пишется адаптер, который с фронта принимает данные по старому способу, обрабатывает их и отправляет в новое апи. Таким образом сохраняется поддержка старых вещей при появлении новых."
      ]
    },
    "difficulty": "middle",
    "description": "Adapter Pattern",
    "question": "Что такое Adapter Pattern в Javascript?"
  },
  {
    "id": "VAoQ7mMDCeDzrpwbd7Zm",
    "difficulty": "middle",
    "type": "question",
    "description": "Strategy Pattern",
    "question": "Что такое Strategy Pattern в Javascript?",
    "popularity": "4",
    "competence": ["common questions", "javascript"],
    "answer": {
      "code": [
        "// encapsulation\nclass Commute {\n  travel(transport) {\n    return transport.travelTime();\n  }\n}\n\nclass Vehicle {\n  travelTime() {\n    return this._timeTaken;\n  }\n}\n\n// strategy 1\nclass Bus extends Vehicle {\n  constructor() {\n    super();\n    this._timeTaken = 10;\n  }\n}\n\n// strategy 2\nclass Taxi extends Vehicle {\n  constructor() {\n    super();\n    this._timeTaken = 5;\n  }\n}\n\n// strategy 3\nclass PersonalCar extends Vehicle {\n  constructor() {\n    super();\n    this._timeTaken = 3;\n  }\n}\n\n// usage\nconst commute = new Commute();\n\nconsole.log(commute.travel(new Taxi())); // 5\nconsole.log(commute.travel(new Bus())); // 10"
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Это поведенческий шаблон проектирования, который позволяет инкапсулировать альтернативные алгоритмы для конкретной задачи. Он определяет семейство алгоритмов и инкапсулирует их таким образом, чтобы они были взаимозаменяемыми во время выполнения без вмешательства или ведома клиента.\n\nВ приведенном ниже примере мы создаем класс Commute для инкапсуляции всех возможных стратегий поездок на работу. Затем мы определяем три стратегии, а именно Bus, PersonalCar и Taxi. Используя этот шаблон, мы можем поменять реализацию, чтобы использовать ее для метода перемещения объекта Commute во время выполнения."
      ]
    }
  },
  {
    "id": "VIK0KX8Q1CwLcOENLY0u",
    "popularity": "4",
    "answer": {
      "link": [],
      "text": [
        "Особенности SEO-оптимизации мультиязычных ресурсов.\nПереключение языка.\nДомены поддомены и т.д.\n "
      ],
      "code": []
    },
    "question": "На что необходимо обратить внимание при разработке мультиязычных сайтов?",
    "description": "Мультиязычность",
    "difficulty": "junior",
    "competence": ["javascript"],
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee469" },
    "tableIndex": 133
  },
  {
    "id": "VWapaAyfOMLCU5w44XAg",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4a3" },
    "difficulty": "junior",
    "popularity": "5",
    "answer": {
      "text": [""],
      "link": [],
      "code": [
        "let m = [1, 7, 5, 13, 8],\n  count = m.length - 1,\n  max;\n\nfor (var i = 0; i < count; i++) {\n  for (var j = 0; j < count - i; j++) {\n    if (m[j] > m[j + 1]) {\n      max = m[j];\n      m[j] = m[j + 1];\n      m[j + 1] = max;\n    }\n  }\n}"
      ]
    },
    "question": "Сортировка пузырьком.",
    "type": "exercise",
    "tableIndex": 134,
    "description": "Сортировка пузырьком."
  },
  {
    "id": "VsLryjhw5GhFf8xnDzly",
    "_id": { "$oid": "60de0704e2c8c53194aee47a" },
    "competence": ["javascript"],
    "question": "Что вы думаете о AMD против CommonJS?",
    "type": "question",
    "tableIndex": 135,
    "answer": {
      "code": [],
      "text": [
        "Asynchronous Module Definition или AMD\n//Вызов функции define с массивом зависимостей и фабричной функцией\ndefine(['dep1', 'dep2'], function (dep1, dep2) {\n  //Определение модуля с помощью возвращаемого значения\n  return function () {};\n});\n\nCommonJS \nФормат CommonJS применяется в Node.js и использует для определения зависимостей и модулей require и module.exports:\nvar dep1 = require('./dep1');\nvar dep2 = require('./dep2');\nmodule.exports = function(){ \n  // ...\n}"
      ],
      "link": []
    },
    "difficulty": "junior",
    "description": "AMD CommonJS",
    "popularity": "2"
  },
  {
    "id": "WFjL8rcGHJpVMEG8TYaY",
    "competence": ["javascript"],
    "difficulty": "junior",
    "tableIndex": 136,
    "description": "setTimeout  setInterval",
    "question": "Какое минимальное время можно задать? (setTimeout и setInterval)",
    "_id": { "$oid": "60de0704e2c8c53194aee497" },
    "popularity": "3",
    "answer": {
      "text": [""],
      "code": [
        "// В каждом браузере есть свой минимум, если вы указываете меньше него, то все равно задержка будет не меньше минимуму. Иногда даже и больше указанного времени, так как задача попадает в очередь и время складывается из заданного плюс затраты в на выполнение на задач в очереди перед ней.\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100);\n}",
        "// Что будет выведено в консоль, как можно модифицировать пример что бы он возвращал правильный результат(назовите как можно больше способов)?\n\nfor (var i = 0; i < 10; i++) {\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100);\n  })(i);\n}",
        "// es6\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100);\n}"
      ],
      "link": []
    },
    "type": "question"
  },
  {
    "id": "WNryGHLapTlPcip1CXIX",
    "question": "Объясните, почему это не является IIFE: `function foo(){ }();`. Что необходимо изменить, чтобы это стало IIFE??",
    "popularity": "5",
    "answer": {
      "link": [
        "http://lucybain.com/blog/2014/immediately-invoked-function-expression/",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void",
        "https://developer.mozilla.org/en-US/docs/Glossary/IIFE"
      ],
      "code": [],
      "text": [
        "IIFE расшифровывается как Immediately Invoked Function Expression — немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает function foo(){ } (); как function foo(){ } и ();, где первое выражение — это объявление функции, а второе (пара скобок) — попытка вызова функции, но так как имя не указано, он выдает ошибку Uncaught SyntaxError: Unexpected token.\n\nВот два способа исправить это, которые заключаются добавление дополнительных скобок: \n(function foo(){ })() и (function foo(){ }()).\n\nВыражения, начинающиеся с function, считаются объявлениями функций.\n\nОборачивая эту функцию внутри (), она становится функциональным выражением, которое затем может быть выполнено с последующим (). Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.\n\nВы также можете использовать оператор void — void function foo(){ }(). К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает undefined, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать. Пример: \nconst foo = void function bar() { return ‘foo’; }(); \nconsole.log(foo); // undefined \n "
      ]
    },
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee434" },
    "difficulty": "junior",
    "description": "IIFE Immediately-invoked function expression",
    "competence": ["javascript"],
    "tableIndex": 137
  },
  {
    "id": "WQwbUHRepRXAfn9xNahh",
    "tableIndex": 138,
    "question": "Что такое run-to-completion model?",
    "answer": {
      "text": [
        "Планирование выполнения до завершения или упреждающее планирование - это модель планирования, в которой каждая задача выполняется до тех пор, пока она либо не завершится, либо явно не вернет управление планировщику.[1] Системы запуска до завершения обычно имеют очередь событий, которая обслуживается либо в строгом порядке приема циклом событий, либо планировщиком приема, который способен планировать события не по порядку, основываясь на других ограничениях, таких как крайние сроки."
      ],
      "link": [
        "https://en.wikipedia.org/wiki/Run_to_completion_scheduling",
        "https://plashless.wordpress.com/2018/04/25/using-a-run-to-completion-task-model-in-embedded-programming/"
      ],
      "code": []
    },
    "description": "run-to-completion model",
    "popularity": "4",
    "competence": ["javascript", "frontend"],
    "difficulty": "middle",
    "_id": { "$oid": "60de0704e2c8c53194aee4ee" },
    "type": "question"
  },
  {
    "id": "WX2pmUi8XHMnQbbHjTPQ",
    "popularity": "3",
    "question": "Что такое service worker?",
    "_id": { "$oid": "60de0704e2c8c53194aee4e1" },
    "type": "question",
    "tableIndex": 139,
    "description": "service worker",
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://developers.google.com/web/fundamentals/primers/service-workers/",
        "https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers",
        "https://habr.com/ru/company/2gis/blog/345552/",
        "https://github.com/mdn/sw-test"
      ],
      "text": [
        "Нужен для работы в офлайн режиме. Создан из-за проблемы с плохой сетью. Создает кэш, в котором хранит данные, необходимые для работы. Подгружает их по необходимости.\n\nЭтапы:\ninstall\noninstall\nonactivate\nregister()\n\n\nРаботает практически также как прокси.\n\nОсобенности:\n1. Работает в https\n2. Единый origin\n3. localStorage работает схожим образом, но в синхронном режиме, поэтому запрещён в сервис-воркерах.\n4. При необходимости хранить данные в сервис-воркерах вы можете использовать IndexedDB."
      ],
      "code": []
    },
    "competence": ["javascript", "frontend"]
  },
  {
    "id": "Wgasyfk7YnSpOLtE1Sx8",
    "question": "Для чего используются статические члены класса?",
    "_id": { "$oid": "60de0704e2c8c53194aee462" },
    "type": "question",
    "tableIndex": 140,
    "answer": {
      "link": [
        "https://stackoverflow.com/questions/21155438/when-to-use-static-variables-methods-and-when-to-use-instance-variables-methods"
      ],
      "code": [],
      "text": [
        "Члены статических классов (свойства/методы) не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того, какой экземпляр ссылается на них. Статические свойства обычно являются конфигурационными переменными, а статические методы обычно являются чисто служебными функциями, которые не зависят от состояния экземпляра."
      ]
    },
    "popularity": "3",
    "description": "статические , static",
    "competence": ["javascript"],
    "difficulty": "junior"
  },
  {
    "id": "Wj7XJ1xQQ6MmxPsGsde9",
    "question": "Что такое Composite Pattern в Javascript?",
    "type": "question",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Чтобы лучше всего представить себе этот паттерн, лучше всего представить дерево. Есть базовый компонент, от которого все наследуются. В каждый элемент можно добавить подобный себе элемент. Если у него нет наследников - значит он конечный лист, если наследники есть - то это ветка. Все лежат внутри друг друга, создают композицию."
      ],
      "code": [
        "class Component {\n  constructor(name) {\n    this._name = name;\n  }\n\n  getNodeName() {\n    return this._name;\n  }\n\n  // abstract methods that need to be overridden\n  getType() {}\n\n  addChild(component) {}\n\n  removeChildByName(componentName) {}\n\n  removeChildByIndex(index) {}\n\n  getChildByName(componentName) {}\n\n  getChildByIndex(index) {}\n\n  noOfChildren() {}\n\n  static logTreeStructure(root) {\n    let treeStructure = '';\n    function traverse(node, indent = 0) {\n      treeStructure += `${'--'.repeat(indent)}${node.getNodeName()}\\n`;\n      indent++;\n      for (let i = 0, length = node.noOfChildren(); i < length; i++) {\n        traverse(node.getChildByIndex(i), indent);\n      }\n    }\n\n    traverse(root);\n    return treeStructure;\n  }\n}\n\nclass Leaf extends Component {\n  constructor(name) {\n    super(name);\n    this._type = 'Leaf Node';\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  noOfChildren() {\n    return 0;\n  }\n}\n\nclass Composite extends Component {\n  constructor(name) {\n    super(name);\n    this._type = 'Composite Node';\n    this._children = [];\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  addChild(component) {\n    this._children = [...this._children, component];\n  }\n\n  removeChildByName(componentName) {\n    this._children = [...this._children].filter(component => component.getNodeName() !== componentName);\n  }\n\n  removeChildByIndex(index) {\n    this._children = [...this._children.slice(0, index), ...this._children.slice(index + 1)];\n  }\n\n  getChildByName(componentName) {\n    return this._children.find(component => component.name === componentName);\n  }\n\n  getChildByIndex(index) {\n    return this._children[index];\n  }\n\n  noOfChildren() {\n    return this._children.length;\n  }\n}\n\n// usage\nconst tree = new Composite('root');\ntree.addChild(new Leaf('left'));\nconst right = new Composite('right');\ntree.addChild(right);\nright.addChild(new Leaf('right-left'));\nconst rightMid = new Composite('right-middle');\nright.addChild(rightMid);\nright.addChild(new Leaf('right-right'));\nrightMid.addChild(new Leaf('left-end'));\nrightMid.addChild(new Leaf('right-end'));\n\n// log\nconsole.log(Component.logTreeStructure(tree));\n/*\nroot\n--left\n--right\n----right-left\n----right-middle\n------left-end\n------right-end\n----right-right\n*/"
      ]
    },
    "description": "Composite Pattern",
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "difficulty": "middle"
  },
  {
    "id": "Ww5uR6yI6DwW8eTrhGjN",
    "description": "shift alt ",
    "answer": {
      "text": [
        "При нажатии на блок и получении эвента эта информация хранится в window.event"
      ],
      "code": [
        "let onkeydown = (function (ev) {\n  var key;\n  var isShift;\n  if (window.event) {\n    key = window.event.keyCode;\n    isShift = !!window.event.shiftKey; // typecast to boolean\n  } else {\n    key = ev.which;\n    isShift = !!ev.shiftKey;\n  }\n  if ( isShift ) {\n    switch (key) {\n      case 16: // ignore shift key\n        break;\n      default:\n        alert(key);\n        // do stuff here?\n        break;\n    }\n  }\n});"
      ],
      "link": []
    },
    "type": "question",
    "competence": ["javascript", "html", "css"],
    "popularity": "3",
    "question": "Как определить нажат ли shift или alt при щелчке на элемент?",
    "difficulty": "junior"
  },
  {
    "id": "XCa3SCIWkZrjlLXwYtFM",
    "competence": ["javascript"],
    "type": "question",
    "answer": {
      "link": [
        "https://www.w3schools.com/js/js_strict.asp",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode",
        "https://medium.com/nuances-of-programming/%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-strict-mode-%D0%B2-javascript-79bdc1aff8af",
        "https://codernet.ru/articles/js/use_strict_chto_eto_zachem_v_javascript_nuzhen_strogij_rezhim/"
      ],
      "text": [
        "При режиме «strict» к неопределенной переменной не присваивается значение.\n\nНельзя применить инструкцию «with».\n\nНет возможности добавить повторяющиеся свойства в литерале объекта.\n\nНет возможности добавить дополнительные параметры формальной функции.\n\nКогда изменяется объект «arguments», не изменяются аргументы.\n\nКогда аргумент является неизменяемым свойством объекта, то «delete» выдаст ошибку.\n\nНет возможности преобразовать «this» в объект.\n\nНет возможности изменять «eval» и «arguments», а также применять их в качестве имени.\n\nУвеличенное количество слов, которые зарезервировали для будущего применения.\n\nНет возможности использовать восьмеричную систему.\n\nНет возможности применять конструкции кода, которые могут затруднить оптимизацию самого кода.\n\nНельзя объявить переменную в коде, который был передан методу «eval».\n\nНельзя удалить обычные переменные."
      ],
      "code": []
    },
    "difficulty": "junior",
    "tableIndex": 143,
    "_id": { "$oid": "60de0704e2c8c53194aee51e" },
    "popularity": "2",
    "question": "Зачем нужен use strict?",
    "description": "strict mode"
  },
  {
    "id": "XcRb3oIp67RTnu3s9bou",
    "difficulty": "middle",
    "question": "Что вы думаете о AMD против CommonJS?",
    "_id": { "$oid": "60de0704e2c8c53194aee433" },
    "answer": {
      "text": [
        "Оба являются способами реализации системы модулей, которая изначально не присутствовала в JavaScript до появления ES2015. \n\nCommonJS является синхронным, в то время как AMD (Asynchronous Module Definition, асинхронное определение модуля) — соответственно, асинхронным. CommonJS разработан с учетом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначена для браузеров. \nЯ считаю синтаксис AMD довольно многословным, а CommonJS ближе к стилю, который используется в выражениях импорта в других языках. В большинстве случаев я считаю AMD ненужным, потому что если вы разместите весь свой код в одном объединенном файле, то вы не сможете воспользоваться свойствами асинхронной загрузки. \nКроме того, синтаксис CommonJS ближе к стилю написания модулей Node, и поэтому происходит меньше путаницы при переключении между клиентской и серверной разработкой на JavaScript.\nЯ рад, что с появлением модулей ES2015, которые поддерживают как синхронную, так и асинхронную загрузку, мы, наконец, можем придерживаться одного подхода. Несмотря на то, что они не полностью поддерживаются во всех браузерах и Node, мы можем использовать транспайлеры для преобразования нашего кода."
      ],
      "code": [],
      "link": [
        "https://auth0.com/blog/javascript-module-systems-showdown/",
        "https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs"
      ]
    },
    "type": "question",
    "description": "AMD CommonJS",
    "competence": ["javascript", "typescript"],
    "popularity": "5",
    "tableIndex": 144
  },
  {
    "id": "Xf8FEbaV4AThhZz3ah0U",
    "tableIndex": 145,
    "question": "Как можно оптимизировать загрузку внешних ресурсов на странице?",
    "_id": { "$oid": "60de0704e2c8c53194aee464" },
    "competence": ["javascript"],
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Уменьшите размер страниц сайта Слишком «тяжелый» контент долго загружается.\n\nСнизьте «вес» графики\n\nУпростите код JavaScript и CSS.\n\nУменьшите число запросов браузера\n\nСократите расстояние между сайтом и пользователями \n \nFOUC \nFlash of unstyled content"
      ]
    },
    "description": "размер страницы",
    "type": "question",
    "popularity": "1",
    "difficulty": "junior"
  },
  {
    "id": "XpP7FIlYR1Od177wi3Or",
    "tableIndex": 146,
    "question": "Напишите простую функцию, чтобы узнать равен ли один из входных параметров 3.",
    "_id": { "$oid": "60de0704e2c8c53194aee4c8" },
    "description": "равно ли 3, arguments",
    "answer": {
      "text": [
        "// Тут делается упор на проверку знаний об arguments, но иногда заходят ещё дальше и просят рассказать каким образом работает\n// Array.prototype.slice.call(arguments). \n// Ответ: \nfunction isThreePassed(){\n  const args = Array.prototype.slice.call(arguments);\n  return args.indexOf(3) != -1; \n} \n\nisThreePassed(1,2) //false \nisThreePassed(9,3,4,9) //true \n\n// Как мы знаем, arguments не массив, а обычный объект, поэтому у него нет такого полезного метода как indexOf. Для этого используется\n// Array.prototype.slice.call(arguments), который делает из argument — &gt;\n// array. \n// .call() и .apply() позволяют явно установить this в функции. И если\n// передать argument как this, то slice будет работать с ним как с обычным массивом.\n \n // А вот интересный эксперимент: \n const o = {\n '0': 'zero',\n '1': 'one'\n };\n\n [].slice.call(o); // []; \n\n const oo = {\n  '0': 'zero', \n  '1': 'one', \n  length: 2 \n }; \n\n [].slice.call(oo); // [\"zero\", \"one\"]; "
      ],
      "link": [],
      "code": []
    },
    "competence": ["javascript"],
    "difficulty": "junior",
    "type": "exercise",
    "popularity": "4"
  },
  {
    "id": "Xu6eYCpTWqAJfO7CG0y6",
    "competence": ["javascript", "frontend"],
    "description": "Inline caches, inline caching",
    "type": "question",
    "popularity": "1",
    "difficulty": "middle",
    "_id": { "$oid": "60de0704e2c8c53194aee4ff" },
    "tableIndex": 147,
    "question": "Что такое Inline caches?",
    "answer": {
      "link": [
        "https://javascript.plainenglish.io/v8-engine-and-inline-caching-in-javascript-fef80054a551",
        "https://medium.com/faster-javascript/hidden-classes-in-javascript-and-inline-caching-6bc2a318c4b4",
        "https://mathiasbynens.be/notes/shapes-ics",
        "https://en.wikipedia.org/wiki/Inline_caching"
      ],
      "code": [],
      "text": [""]
    }
  },
  {
    "id": "XveGPjVwrTQWsnKM3WOl",
    "tableIndex": 148,
    "answer": { "link": [], "code": [], "text": ["нет"] },
    "_id": { "$oid": "60de0704e2c8c53194aee495" },
    "type": "question",
    "competence": ["javascript"],
    "popularity": "1",
    "description": "promise",
    "difficulty": "junior",
    "question": "У нас есть три запроса к серверу, один возвращает нам имя пользователя, второй его данные, а третий изображение для аватарки, мы для каждого запроса используем по промису, объединяя их в цепочку, что будет если в одном из запросов произойдет ошибка, довыполнится ли цепочка?"
  },
  {
    "id": "Y6frOvSNhI909hurbqh6",
    "difficulty": "junior",
    "description": "hello world",
    "type": "exercise",
    "popularity": "1",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee498" },
    "tableIndex": 149,
    "answer": {
      "text": [
        "var zero = [].length,\n     one = [{}].length,\n     two = [,,].length,\n    seven = [,,,,,,,].length;\n\nconsole.log(String.fromCharCode(Number(String(seven) + String(two))));"
      ],
      "link": ["https://habr.com/ru/post/351874/"],
      "code": []
    },
    "question": "Напишите функцию, которая вернет «hello world», но при этом в теле функции нельзя использовать ни цифры, ни буквы, а циклы, массивы, объекты можно, но без цифр."
  },
  {
    "id": "YBcCK2OYgvctae57UV2V",
    "_id": { "$oid": "60de0704e2c8c53194aee447" },
    "competence": ["javascript"],
    "description": "load, DOMContentLoaded",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded",
        "https://developer.mozilla.org/en-US/docs/Web/Events/load"
      ],
      "code": [],
      "text": [
        "Событие DOMContentLoaded вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.\n\nСобытие load происходит только после загрузки DOM и всех зависимых ресурсов."
      ]
    },
    "type": "question",
    "question": "В чем разница между событием `load` и событием `DOMContentLoaded`?",
    "popularity": "3",
    "difficulty": "junior",
    "tableIndex": 150
  },
  {
    "id": "YEi4lssbwoXnDN7a8iHG",
    "popularity": "3",
    "competence": ["javascript"],
    "question": "Для чего используется атрибут srcset в теге изображения? Опишите процесс, который использует браузер при оценке содержимого этого атрибута.",
    "difficulty": "junior",
    "answer": {
      "code": [
        "<img\n srcset=\"elva-fairy-320w.jpg 320w, elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w\" \n sizes=\"(max-width: 320px) 280px, (max-width: 480px) 440px, 800px\"\n src=\"elva-fairy-800w.jpg\" \n alt=\"Elva dressed as a fairy\"\n>"
      ],
      "text": [
        "Однако есть два новых атрибута — srcset and sizes — позволяющих добавить дополнительные изображения с пометками, чтобы браузер выбрал подходящее.\n"
      ],
      "link": []
    },
    "description": "srcset, sizes ",
    "tableIndex": 151,
    "_id": { "$oid": "60de0704e2c8c53194aee470" },
    "type": "question"
  },
  {
    "id": "YJbnA0B81yan73vwuF1f",
    "description": "function Declaration  Expression",
    "competence": ["javascript"],
    "tableIndex": 152,
    "type": "question",
    "difficulty": "junior",
    "question": "Объясните разницу при использовании `foo` в `function foo() {}` и `var foo = function() {}`.",
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee457" },
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function",
        "https://medium.com/@raviroshan.talk/javascript-function-declaration-vs-expression-f5873b8c7b38"
      ],
      "text": [
        "Первое — объявление функции, а второе — функциональное выражение.\n\nКлючевое отличие состоит в том, что тело функции при объявлении поднимается наверх, а тело функциональных выражений — нет (они имеют такое же поведение поднятия, что и переменные). Для получения более подробной информации, обратитесь к вопросу выше о поднятии. \nЕсли вы попытаетесь вызвать выражение функции до того, как оно будет определено, вы получите ошибку Uncaught TypeError: XXX is not a function. \n\nОбъявление функции:\nfoo(); // 'FOOOOO' \n  function foo() { \n  console.log('FOOOOO'); \n}\n\nФункциональное выражение \nfoo(); // Uncaught TypeError: foo is not a function \nvar foo = function() { \n  console.log('FOOOOO'); \n};"
      ],
      "code": []
    }
  },
  {
    "id": "YNlFSfIcpydHvv4cqJS4",
    "popularity": "4",
    "question": "Как сделать, чтобы работал position:absolute ?",
    "difficulty": "beginner",
    "type": "question",
    "description": "Абсолютное позиционирование",
    "competence": ["css"],
    "answer": {
      "text": [
        "чтобы работал position: absolute надо чтобы парент был в position: relative"
      ],
      "link": [],
      "code": []
    }
  },
  {
    "id": "YTjeq3XdngVd4X0dnOOa",
    "competence": ["typescript"],
    "answer": {
      "text": [
        "document.write() - \n\nзаписывает строку текста в поток документа, открытого при помощи\ndocument.open(). Когда document.write() выполняется после загрузки страницы,\nон вызывает document.open, который очищает весь документ\n(<head><body> будут удалены!) и заменяет содержимое на заданное\nзначение параметра. Подобный подход считается опасным и не рекомендуется его\nиспользовать.\n\nВ Интернете есть несколько ответов, которые объясняют, что document.write()\nиспользуется в коде отслеживания или когда вы хотите добавить стили, которые\nдолжны работать только при включенном JavaScript. Он даже используется в\nшаблоне HTML5 для параллельной загрузки скриптов и сохранения порядка\nвыполнения! Тем не менее, я подозреваю, что эти причины могут быть устаревшими,\nи в наши дни они могут быть достигнуты без использования document.write()."
      ],
      "code": [],
      "link": [
        "https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html",
        "https://github.com/h5bp/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag"
      ]
    },
    "difficulty": "junior",
    "description": "document.write",
    "tableIndex": 154,
    "popularity": "3",
    "question": "В каких случаях используется `document.write()`?",
    "_id": { "$oid": "60de0704e2c8c53194aee43e" },
    "type": "question"
  },
  {
    "id": "YZx5Im7LiUTnEKSpL0vp",
    "difficulty": "senior",
    "answer": {
      "link": [],
      "code": [],
      "text": ["jest test => describe(test(expect()))"]
    },
    "description": "Порядок, обертки, jest",
    "popularity": "5",
    "tableIndex": 155,
    "type": "question",
    "competence": ["javascript", "typescript", "frontend"],
    "question": "Какая очередности написания тестов функций в jest?"
  },
  {
    "id": "Z5m64K7GZVSkPBZcNXtD",
    "difficulty": "junior",
    "competence": ["typescript"],
    "question": "В\n чем разница между host-объектами и нативными объектами?",
    "type": "question",
    "description": "",
    "answer": {
      "text": [
        "В\n чем разница между host-объектами и нативными объектами? <br>\n Нативные объекты — это объекты, которые являются частью языка JavaScript,\n определенного в спецификации ECMAScript, такие как String, Math, RegExp,\n Object, Function и т.д. <br>\n Хост-объекты предоставляются средой выполнения (браузером или Node), такие\n как `window`, `XMLHTTPRequest` и т.д. <br>\n "
      ],
      "code": [],
      "link": [
        "https://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee43a" },
    "popularity": "4"
  },
  {
    "id": "ZZoezCwPkb44QGkK6NGY",
    "question": "Как использовать Performance в консоли браузера и зачем он нужен?",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Записывает все действия и насколько они нагружают систему. Служит для оптимизации."
      ]
    },
    "type": "question",
    "competence": ["common questions", "javascript"],
    "difficulty": "junior",
    "popularity": "4",
    "description": "Performance "
  },
  {
    "id": "ZfFB49EfJ3wmeYAB11ox",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "text": [""],
      "code": [
        "function promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    const results = [];\n    let resolvedCount = 0;\n\n    promises.forEach((promise, index) => {\n      promise\n        .then((result) => {\n          results[index] = result;\n\n          resolvedCount++;\n\n          if (resolvedCount === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch((err) => reject(err));\n    });\n    \n  });\n}"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4b1" },
    "difficulty": "middle",
    "tableIndex": 158,
    "popularity": "4",
    "description": "promiseAll",
    "type": "exercise",
    "question": "Реализовать аналог Promise.all."
  },
  {
    "id": "ZhZw7sjo59IxcQUDTzBd",
    "answer": {
      "code": [
        "import { zip, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n \nlet age$ = of<number>(27, 25, 29);\nlet name$ = of<string>('Foo', 'Bar', 'Beer');\nlet isDev$ = of<boolean>(true, true, false);\n \nzip(age$, name$, isDev$).pipe(\n  map(([age, name, isDev]) => ({ age, name, isDev })),\n)\n.subscribe(x => console.log(x));\n \n// outputs\n// { age: 27, name: 'Foo', isDev: true }\n// { age: 25, name: 'Bar', isDev: true }\n// { age: 29, name: 'Beer', isDev: false }",
        "import { combineLatest, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n \nconst amount = of(70, 72, 76, 79, 75);\nconst conversionRate = of(0.06, 0.07, 0.08);\nconst fees = combineLatest(amount, fees).pipe(\n  map(([a, r]) => (a * r)),\n);\nfees.subscribe(x => console.log('commission is ' + x));"
      ],
      "text": [
        "jorkJoin - ждет когда все закончатся и отдает.\n\nzip - Отдает то что приходит в массиве массивов. Какой по порядку идет поток, такой и имеет индекс. Ждет, пока отдадут все хотя бы один элемент.\n\nCombineLatest - отдает массив, в котором лежат ответы потоков в том порядке, в котором были запущены. Хранит одно последнее значение с каждого потока."
      ],
      "link": [
        "https://rxjs.dev/api/index/function/forkJoin",
        "https://rxjs.dev/api/index/function/zip",
        "https://rxjs.dev/api/index/function/combineLatest",
        "https://www.techgeeknext.com/angular/angular-rxjs-combine-latest-zip"
      ]
    },
    "question": "В чем разница между forkJoin, zip, combineLatest?",
    "competence": ["javascript", "typescript", "angular", "frontend"],
    "difficulty": "middle",
    "type": "question",
    "description": "rxjs combine operators",
    "popularity": "5"
  },
  {
    "id": "ZpzCEjbkhLvGtuxegn8u",
    "question": "Как ускорить загрузку страницы?",
    "difficulty": "junior",
    "description": "скорость загрузки",
    "type": "question",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4a1" },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "1. минимизировать и склеить в один все js-файлы \n\n2. то же и с css \n\n3. собрать изображения в спрайты \n\n4. кеширование \nа) файлы js и css кешируются навсегда( или на длительный период, к примеру\nна год), когда в них вносятся какие-то изменения, в результате разработки,\nменяется номер версии, браузер считает, что это новые файлы и закачивает их.\nВремя кеширование содержится в заголовке expires.\n\nб) файл кешируется до тех пор, пока в нем не произошли изменения. Когда\nпользователь в первый раз заходит на сайт, у него еще нет кеша, файлы\nзакачиваются и в следующий раз, когда происходит обмен заголовками происходит\nанализ ETag(хеш суммы содержимого содержимого файла или хеш последнего\nвремени изменения, или номер версии) Если он изменился, то закачивается, в\nпротивном случае, берется из хеша.\nТак же можно брать заголовки с датой последней модификации(Last_Modifed),\nно это менее надежно.\n\nв) можно сжать данные перед отправкой, решается настройкой конфига в nginx.\nПример. Content-Encoding: gzip\n\nг) можно разбить js на модули и на разных страницах подключать по мере\nнеобходимости."
      ]
    },
    "tableIndex": 160,
    "popularity": "4"
  },
  {
    "id": "aKrG2dSTvtNfcr3XwByE",
    "_id": { "$oid": "60de0704e2c8c53194aee525" },
    "popularity": "2",
    "difficulty": "junior",
    "type": "question",
    "description": "модуль",
    "answer": {
      "code": [
        "(function (exports, require, module, __filename, __dirname) {\n  module.exports = exports = {};\n\n  // Your module code ...\n\n});"
      ],
      "link": [
        "https://coderoad.ru/39516623/%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D1%8C%D1%82%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C-%D0%B2-ES6-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-import-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-require",
        "https://wsofter.com/nachalo-raboty-s-moduljami-node-js-require-exports-imports-i-ne-tolko/"
      ],
      "text": ["Можно разнести js по разным файлам, закрыть в функциях"]
    },
    "tableIndex": 161,
    "competence": ["javascript"],
    "question": "Как мы можем эмулировать модули не используя ES modules/require?"
  },
  {
    "id": "aMEmlUXXtsD0FhPIx62Z",
    "type": "question",
    "tableIndex": 162,
    "_id": { "$oid": "60de0704e2c8c53194aee443" },
    "difficulty": "junior",
    "answer": {
      "text": [
        "Да. Handlebars, Underscore, Lodash, AngularJS, и JSX. Мне не нравилась шаблонизация в AngularJS, потому что там активно использовались строки в директивах и легко допустить ошибку при опечатке. JSX - мой новый фаворит, так как он ближе к JavaScript и почти не имеет дополнительного синтаксиса. В настоящее время вы даже можете использовать строковые литералы шаблонов\nES2015 в качестве быстрого способа создания шаблонов, не полагаясь на сторонний код.\n\nconst template = `<div>My name is: ${name}</div>`;\n\nОднако следует помнить о возможном XSS в вышеприведенном подходе, поскольку содержимое не экранируется, в отличие от библиотек шаблонизации."
      ],
      "link": [],
      "code": []
    },
    "popularity": "5",
    "question": "Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?",
    "competence": ["typescript"],
    "description": "es2015 шаблоны"
  },
  {
    "id": "aQcU4eB1x1sj4BMLdeoY",
    "competence": ["javascript"],
    "popularity": "3",
    "tableIndex": 163,
    "_id": { "$oid": "60de0704e2c8c53194aee4cc" },
    "type": "question",
    "question": "Как получить параметры из URL’а текущего окна?",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "window.location.href\n\nКак отмечено в комментариях, строка ниже работает, но она содержит ошибки для Firefox.\ndocument.URL;\n "
      ]
    },
    "difficulty": "junior",
    "description": "url"
  },
  {
    "id": "aZThdlLVdtas9AWaLqcP",
    "difficulty": "middle",
    "type": "question",
    "popularity": "4",
    "answer": {
      "code": [
        "// using Object.create as was recommended by ES5 standard\nconst car = {\n  noOfWheels: 4,\n  start() {\n    return 'started';\n  },\n  stop() {\n    return 'stopped';\n  },\n};\n\n// Object.create(proto[, propertiesObject])\n\nconst myCar = Object.create(car, { owner: { value: 'John' } });\n\nconsole.log(myCar.__proto__ === car); // true"
      ],
      "text": [
        "Прототип отличается от фабрики тем, что в качестве начального \"класса\" используется определенный обьект, который является скелетом(классом-прототипом) для создания последующих обьектов."
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ]
    },
    "competence": ["common questions", "javascript"],
    "question": "Что такое Prototype Pattern в Javascript?",
    "description": "Prototype Pattern"
  },
  {
    "id": "afqu7q3fcYHlmhdxMGS8",
    "type": "question",
    "competence": ["javascript"],
    "tableIndex": 165,
    "popularity": "5",
    "difficulty": "junior",
    "description": "ресет стилей, style reset",
    "question": "Что такое ресет стилей? (css style reset)",
    "_id": { "$oid": "60de0704e2c8c53194aee48f" },
    "answer": {
      "link": [],
      "text": [
        "Многим тегам стили прописаны по умолчанию, в процессе верстке нам приходится переопределять их. Что бы не делать это каждый раз, мы «скидываем» их «массово». Для этого заводим файл под стили, подключаем его первым или в первом стилевом файле, в самом верху указываем наши стили для базовых тегов.\n\nК примеру. Мы часто используем список ul для верстки меню, для этого мы каждый раз вынуждены обнулять padding, margin и list-style-type. Можно один раз задать стили, и списки станут без внешней и внутренней границы, а так же без маркеров."
      ],
      "code": []
    }
  },
  {
    "id": "b10OcxRi0wgeFDXEAP74",
    "_id": { "$oid": "60de0704e2c8c53194aee453" },
    "competence": ["javascript"],
    "description": "компилируемые языки в javascript",
    "answer": {
      "text": [
        "Вот несколько языков, которые компилируются в JavaScript: CoffeeScript, Elm, ClojureScript, PureScript и TypeScript.\n\nПреимущества:\n\nИсправляют некоторые давние проблемы в JavaScript и препятствует использованию анти-паттернов в JavaScript. \nПозволяют писать более короткий код, предоставляя синтаксический сахар поверх JavaScript, которого, как мне кажется, не хватало в ES5, но с приходом ES2015 все изменилось.\n\nСтатическая типизация идеальна (в случае TypeScript) для больших проектов, которые необходимо поддерживать с течением времени. \n\nНедостатки:\n\nНеобходима сборка/компиляция кода, так как браузеры запускают только JavaScript, и ваш код должен быть скомпилирован в JavaScript перед тем, как он будет передан в браузеры.\n\nОтладка может быть трудной, если карты кода (source maps) плохо сопоставляются с исходным кодом.\n\nБольшинство разработчиков не знакомы с этими языками и должны будут изучить их. Если ваша команда будет использовать их для своих проектов, это приведет к увеличению затрат.\n\nМеньшее сообщество (зависит от языка), что означает, что будет труднее найти ресурсы, учебные пособия, библиотеки и инструменты.\n\nМожет отсутствовать поддержка в IDE/редакторе.\n\nЭти языки всегда будут позади последнего стандарта JavaScript. \n\nРазработчики должны знать, во что компилируется их код — потому что это то, что будет запускаться в браузере, и это наиболее важно.\n\nПо большому счету, ES2015 значительно улучшил JavaScript и сделал разработку на нем намного удобнее. Я не вижу причин использовать CoffeeScript в наши дни."
      ],
      "code": [],
      "link": [
        "https://softwareengineering.stackexchange.com/questions/72569/what-are-the-pros-and-cons-of-coffeescript"
      ]
    },
    "popularity": "4",
    "question": "Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?",
    "tableIndex": 166,
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "bW3Aa4QbC6vTf8QWILak",
    "answer": {
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"
      ],
      "text": [
        "arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end."
      ]
    },
    "difficulty": "middle",
    "popularity": "4",
    "description": "Очень интересный метод в js",
    "type": "question",
    "question": "Для чего используется метод .fill(\"\")?",
    "tableIndex": 167,
    "competence": ["javascript"]
  },
  {
    "id": "cCSDpoNw5Aq9HsJokfvo",
    "tableIndex": 168,
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee4ce" },
    "question": "Чему равно foo.length?\n\n\n ",
    "description": "let foo = {};\nfoo.bar = 'hello';",
    "popularity": "2",
    "competence": ["javascript"],
    "answer": { "link": [], "code": [], "text": ["Ответ: undefined"] },
    "type": "question"
  },
  {
    "id": "cDMLvv0UTZ4wQD4kdEg1",
    "question": "Что такое очереди в javascript?",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee4f8" },
    "description": "очередь FIFO LIFO стэк",
    "answer": {
      "link": ["https://www.telerik.com/blogs/stack-queue-javascript"],
      "code": [],
      "text": [
        "Структура данных. Первый пришел - первый вышел (FIFO)\nПротивоположность стэк - последний зашел, первый вышел (LIFO)"
      ]
    },
    "competence": ["common questions", "javascript"],
    "popularity": "3",
    "type": "question",
    "tableIndex": 169
  },
  {
    "id": "cJLCRpQMlePmmVnvXstv",
    "answer": { "code": [], "link": [], "text": ["2"] },
    "difficulty": "junior",
    "description": "var foo = [];\nfoo.push(1);\nfoo.push(2);",
    "question": "Чему равно foo.length?",
    "_id": { "$oid": "60de0704e2c8c53194aee487" },
    "popularity": "3",
    "type": "question",
    "competence": ["javascript"],
    "tableIndex": 170
  },
  {
    "id": "cM3MJeuMM83z9xgwz4XS",
    "popularity": "5",
    "competence": ["common questions"],
    "description": "DI - Dependency Inversion Principle - Принцип инверсии зависимостей",
    "question": "Что такое DIP? (пятая в SOLID)",
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "text": [
        "Объектом зависимости должна быть абстракция, а не что-то конкретное.\n\nМодули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\n\nАбстракции не должны зависеть от деталей. Детали должны зависеть от абстракций."
      ],
      "link": [
        "https://stackify.com/dependency-inversion-principle/",
        "https://blog.logrocket.com/solid-principles-single-responsibility-in-javascript-frameworks/",
        "https://medium.com/webbdev/solid-4ffc018077da"
      ],
      "code": []
    }
  },
  {
    "id": "ccEybqz6Nk7mqHIbtIV4",
    "difficulty": "junior",
    "answer": {
      "link": ["https://habr.com/ru/post/463125/"],
      "code": [],
      "text": [
        "publiс — к атрибуту может получить доступ любой желающий\nprivate — к атрибуту могут обращаться только методы данного класса\nprotected — то же, что и private, только доступ получают и наследники класса в том числе\nstatic — метод или свойство доступно напрямую из класса, без создания экземпляра"
      ]
    },
    "popularity": "5",
    "competence": ["common questions", "javascript"],
    "question": "Какая разница между static, private, protected, public?",
    "type": "question",
    "description": "static private protected public"
  },
  {
    "id": "ctWOJraQWirvFeNvKjkN",
    "type": "question",
    "question": "Перечислите логические операторы в javascript.",
    "tableIndex": 173,
    "answer": {
      "text": ["|| && !"],
      "code": [],
      "link": ["https://learn.javascript.ru/logical-ops"]
    },
    "difficulty": "junior",
    "competence": ["javascript"],
    "description": "и или не",
    "popularity": "1",
    "_id": { "$oid": "60de0704e2c8c53194aee50c" }
  },
  {
    "id": "dEGmPez38M6jlhnseqLy",
    "type": "question",
    "answer": {
      "code": [
        "// Function Declaration\nfunction sum(a, b) {\n  return a + b;\n}\n\n// Function Expression\nlet sum = function(a, b) {\n  return a + b;\n};"
      ],
      "text": [
        "function declaration - Объявление Функции, функция объявляется отдельной конструкцией «function…» в основном потоке кода..\n\nFunction Expression - функция, созданная внутри другого выражения или синтаксической конструкции.\n\nРазница в том, что функция при function declaration вызывается из любого места, потому что происходит поднятие. А Function Expression может вызваться только после объявления, потому что она как бы лежит в переменной, а переменная не поднимается. Ее видно только после объявления."
      ],
      "link": ["https://learn.javascript.ru/function-expressions"]
    },
    "question": "В чем разница между function expression и function declaration?",
    "difficulty": "junior",
    "tableIndex": 174,
    "description": "function expression, function declaration",
    "competence": ["javascript"],
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee518" }
  },
  {
    "id": "dJqOteNwiJ3R8HaIeeLh",
    "type": "question",
    "description": "CORS",
    "answer": {
      "text": [
        "Same-origin policy (принцип одинакового источника) не позволяет JavaScript выполнять запросы за границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа этой страницы."
      ],
      "code": [],
      "link": ["https://en.wikipedia.org/wiki/Same-origin_policy"]
    },
    "popularity": "4",
    "_id": { "$oid": "60de0704e2c8c53194aee449" },
    "difficulty": "junior",
    "competence": ["javascript"],
    "tableIndex": 175,
    "question": "Объясните same-origin policy в контексте JavaScript."
  },
  {
    "id": "dPDSwD5hUUjVMBLGcCqY",
    "answer": {
      "code": [
        "function f(a, b) {\n  if (b !== undefined) {\n    return a + b;\n  } else {\n    return function (b) {\n      return a + b;\n    };\n  }\n}\n\n// f(1)(2)(3)() -> 6, f(0)(3)(1)(5)() ->; 8\nfunction f(arg) {\n  var value = arg;\n  return function (arg) {\n    if (arg !== undefined) {\n      return f(value + arg);\n    } else {\n      return value;\n    }\n  };\n}\n\n// foo(1)(2)(3) -> 6\nfunction foo(value) {\n  var acc = value;\n  function addNext(next) {\n    acc += next;\n    return addNext;\n  }\n  addNext.toString = addNext.valueOf = function () {\n    return acc;\n  };\n  return addNext;\n}\n"
      ],
      "link": ["https://learn.javascript.ru/currying-partials"],
      "text": [""]
    },
    "question": "Реализовать функцию f: f(2, 3) => 5, при вызове f(2)(3), тоже вернет 5/",
    "_id": { "$oid": "60de0704e2c8c53194aee49e" },
    "tableIndex": 176,
    "competence": ["javascript"],
    "difficulty": "junior",
    "type": "exercise",
    "popularity": "5",
    "description": "Каррирование Currying"
  },
  {
    "id": "dddhyHmaVahewS2e5HKD",
    "_id": { "$oid": "60de0704e2c8c53194aee4bd" },
    "question": "Функция Бомба.",
    "type": "exercise",
    "description": "Надо реализовать «бомбу» (в виде функции-конструктора), которая получает на входе время, через которое взорвется и некоторый «звук взрыва» (строку, которую вернет через заданное время).",
    "difficulty": "junior",
    "answer": {
      "code": [
        "function Bomb(message, delay) {\n  this.message = message;\n  setTimeout(this.blowUp.bind(this), delay * 1000); // взрываем через delay sec;\n}\n\nBomb.prototype.blowUp = function () {\n  console.log(this.message);\n};\n\nnew Bomb(\"Explosion!\", 0.5);\n"
      ],
      "link": [],
      "text": [""]
    },
    "competence": ["javascript"],
    "popularity": "5",
    "tableIndex": 177
  },
  {
    "id": "e6hs9rqEGcHT8xdsAw9H",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee494" },
    "tableIndex": 178,
    "answer": {
      "code": [],
      "text": [
        "По старинке, вводили переменную-счетчик и как-только наступало окончание очередного асинхронного действия, сравнивали переменную с общем количеством."
      ],
      "link": []
    },
    "description": "without promise без промиса",
    "popularity": "5",
    "question": "Каким образом можно обойтись без промисов?",
    "difficulty": "junior",
    "competence": ["javascript"]
  },
  {
    "id": "e9ro78D0jT8BUcHqLkq6",
    "tableIndex": 179,
    "popularity": "5",
    "_id": { "$oid": "60de0704e2c8c53194aee4b6" },
    "description": "Необходимо написать функцию, принимающую в аргументах массив целых чисел и возвращающую новый массив, состоящий только из уникальных значений первого массива. ",
    "difficulty": "middle",
    "type": "exercise",
    "question": "Уникализация значений в массиве.",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "code": [
        "//  Например:  unique([1, 1, 2, 2, 4, 2, 3, 7, 3]); // => [1, 2, 4, 3, 7]\n//  Решение в лоб\nfunction unique(arr) {\n  const res = [];\n  arr.forEach((item) => {\n    if (res.indexOf(item) === -1) {\n      res.push(item);\n    }\n  });\n  return res;\n}\n\n//  Ожидания интервьюера\nfunction unique(arr) {\n  const res = {};\n  arr.forEach((item) => {\n    res[item] = \"\";\n  });\n  return Object.keys(res).map((item) => Number(item));\n}\n\n//  Решение в одну строку\nfunction unique(arr) {\n  return arr.filter((item, index, self) => self.indexOf(item) === index);\n}\n\n// Решение с Set\nlet myArray = ['c', 'b', 'c', 2, 'b'];\nlet uniqueArray = [...new Set(myArray)]"
      ],
      "text": [""]
    }
  },
  {
    "id": "eWNLFepOhJPX1dDa53gM",
    "type": "question",
    "answer": {
      "text": [
        "Вставляет текст именно как HTML, а не как безопасный переработанный текст.\n\nelement.insertAdjacentHTML(position, text);\ninsertAdjacentHTML ('afterbegin', 'afterend', 'beforeend', 'beforebegin')"
      ],
      "code": [
        "const insert = document.querySelector('#insert');\ninsert.addEventListener('click', () => {\n  const subject = document.querySelector('#subject');\n  const positionSelect = document.querySelector('#position');\n  subject.insertAdjacentHTML(positionSelect.value, '<strong>inserted text</strong>');\n});\n\nconst reset = document.querySelector('#reset');\nreset.addEventListener('click', () => {\n  document.location.reload();\n});"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML",
        "https://learn.javascript.ru/modifying-document#prepend-append-before-after"
      ]
    },
    "tableIndex": 180,
    "difficulty": "junior",
    "question": "Что такое insertAdjacentHTML?",
    "description": "insertAdjacentHTML",
    "competence": ["javascript"],
    "popularity": "3"
  },
  {
    "id": "ejiNxIeYxixPueXnnYcy",
    "description": "замыкание  closure",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee436" },
    "question": "Что такое замыкание и как/для чего его используют?",
    "tableIndex": 181,
    "difficulty": "junior",
    "type": "question",
    "popularity": "4",
    "answer": {
      "text": [
        "Замыкание — это комбинация функции и лексического окружения, в которой эта функция была объявлена.\n\nСлово “лексический” относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна.\n\nЗамыкания — это функции, которые имеют доступ к переменным внешней (замыкающей) функции — цепочке областей видимости даже после того, как внешняя функция вернулась.\n\nДля чего его используют? \nКонфиденциальность данных / эмуляция скрытых методов при помощи замыканий.\nОбычно используется в модульном паттерне. \nЧастичное применение функций или каррирование."
      ],
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
        "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36"
      ]
    }
  },
  {
    "id": "enAJmMeGp96TLghWYeAE",
    "difficulty": "middle",
    "answer": {
      "code": [
        "function Promise(fn) {\n  this.thenHandlers = [];\n  this.catchHandlers = [];\n  this.isResolved = false;\n  this.isRejected = false;\n  setTimeout(() =>\n    fn(this.applyResolve.bind(this), this.applyReject.bind(this))\n  );\n}\n\n\nPromise.prototype = {\n  applyResolve: function () {\n    this.thenHandlers.forEach((handler) => handler());\n    this.isResolved = true;\n  },\n  applyReject: function () {\n    this.catchHandlers.forEach((handler) => handler());\n    this.isRejected = true;\n  },\n  then: function (handler) {\n    if (this.isResolved) {\n      handler();\n    } else {\n      this.thenHandlers.push(handler);\n    }\n    return this;\n  },\n  catch: function (handler) {\n    if (this.isRejected) {\n      handler();\n    } else {\n      this.catchHandlers.push(handler);\n    }\n    return this;\n  },\n};\n\n\nconst p = new Promise((resolve, reject) =>\n  Math.round(Math.random() * 10) % 2 === 0 ? resolve() : reject()\n);\n\n\np.then(function () {\n  console.log(\"resolved\");\n}).catch(function () {\n  console.log(\"rejected\");\n});\n"
      ],
      "text": [""],
      "link": []
    },
    "type": "exercise",
    "tableIndex": 183,
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4b0" },
    "popularity": "5",
    "question": "Напишите полифилл для Promise.",
    "description": "Promise"
  },
  {
    "id": "eqkIB94DX6N4zaKbqlhN",
    "answer": {
      "code": [],
      "link": [
        "https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html",
        "http://theproactiveprogrammer.com/javascript/the-javascript-event-loop-a-stack-and-a-queue/"
      ],
      "text": [
        "Синхронные функции являются блокирующими, а асинхронные — нет. В синхронных функциях одна операция должна завершиться, прежде чем будет запущена следующая операция. В этом случае скрипт выполняется строго по порядку операций, и выполнение скрипта приостанавливается, если одна из операций занимает очень много времени.\n\nАсинхронные функции обычно принимают callback-функцию в качестве параметра, и выполнение продолжается на следующей строке сразу после вызова асинхронной функции. Callback-функция вызывается только тогда, когда асинхронная операция завершена и стек вызовов пуст. Ресурсоемкие операции, такие как загрузка данных с веб-сервера или запросы к базе данных, должны выполняться асинхронно, чтобы основной поток мог продолжать выполнять другие операции вместо блокировки до завершения этой долгой операции (в случае браузеров пользовательский интерфейс будет зависать). \n\nЧто такое цикл событий (event loop)? В чем разница между стеком вызовов (call stack) и очередью событий (task queue)? \nЦикл событий — это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается в стек вызовов для выполнения.\n\nРекомендую ознакомиться с докладом о цикле событий от Philip Robert. Это одно из самых популярных видео о JavaScript. \nhttps://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html"
      ]
    },
    "competence": ["javascript"],
    "difficulty": "junior",
    "type": "question",
    "description": "sync async",
    "popularity": "5",
    "tableIndex": 184,
    "_id": { "$oid": "60de0704e2c8c53194aee456" },
    "question": "Объясните разницу между синхронными и асинхронными функциями."
  },
  {
    "id": "f5SGK6pZ5eWxMdaK6YDJ",
    "description": "~",
    "question": "Какое значение возвращает данное предложение ~~3.14?",
    "popularity": "3",
    "_id": { "$oid": "60de0704e2c8c53194aee4cd" },
    "difficulty": "junior",
    "answer": {
      "code": [],
      "text": [
        "3\n ~~3.14\n ~ -> Округление вниз\n ~~ -> Преобразования строки в число\n "
      ],
      "link": []
    },
    "type": "question",
    "competence": ["javascript"],
    "tableIndex": 185
  },
  {
    "id": "fPN2p9v2JoquDobUCf5q",
    "competence": ["typescript"],
    "difficulty": "middle",
    "question": "Что такое тип type Record?",
    "answer": {
      "text": ["Construct a type with a set of properties K of type T"],
      "link": [
        "https://www.typescriptlang.org/docs/handbook/utility-types.html"
      ],
      "code": [
        "type Record<K extends keyof any, T> = {\n    [P in K]: T;\n};\n\ntabLoadData: Record<number, boolean> = {};"
      ]
    },
    "type": "question",
    "popularity": "4",
    "description": "Record"
  },
  {
    "id": "gdBpPzWVUU5gJjTnA9Ef",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "text": [
        "Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им\nпередаются.\n\nОбъект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования."
      ],
      "link": []
    },
    "popularity": "5",
    "description": "функциональное программирование",
    "type": "question",
    "tableIndex": 187,
    "_id": { "$oid": "60de0704e2c8c53194aee4d1" },
    "competence": ["javascript"],
    "question": "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?"
  },
  {
    "id": "ghgGe2nfLchfE0spkwqO",
    "popularity": "4",
    "description": "cypress",
    "type": "question",
    "question": "Что такое e2e тестирование?",
    "difficulty": "middle",
    "answer": {
      "link": ["https://www.cypress.io/how-it-works/"],
      "text": [
        "Имитирует действия пользователя и проверяет работоспособность системы."
      ],
      "code": []
    },
    "competence": ["common questions", "javascript"]
  },
  {
    "id": "goR56CVPUtgpuQ52jk5e",
    "difficulty": "junior",
    "tableIndex": 189,
    "popularity": "4",
    "description": "IIFE Immediately Invoked Function Expression",
    "answer": {
      "text": [
        "Все, что происходит внутри IIFE, остается внутри IIFE.\n\nСамовызывающиеся функции\n\nОбычно определение функции отделяется от ее вызова: сначала мы определяем функцию, а потом вызываем. Но это необязательно. Мы также можем создать такие функции, которые будут вызываться сразу при определении. Такие функции еще называют Immediately Invoked Function Expression (IIFE).\n\nПодобные функции заключаются в скобки, и после определения функции идет в скобках передача параметров."
      ],
      "code": [
        "(function(){\n    console.log(\"Привет мир\");\n}());\n \n(function (n){\n     \n    var result = 1;\n    for(var i=1; i<=n; i++)\n        result *=i;\n    console.log(\"Факториал числа \" + n + \" равен \" + result);\n}(4));"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Glossary/IIFE",
        "https://ru.stackoverflow.com/questions/414092/%d0%9a%d0%b0%d0%ba-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d1%8e%d1%82-%d0%b7%d0%b0%d0%bc%d1%8b%d0%ba%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2-javascript",
        "https://ru.stackoverflow.com/questions/485270/%D0%92-%D1%87%D0%B5%D0%BC-%D1%81%D0%BC%D1%8B%D1%81%D0%BB-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B9",
        "https://metanit.com/web/javascript/3.3.php",
        "https://learn.javascript.ru/closure#bloki-koda-i-tsikly-iife"
      ]
    },
    "competence": ["javascript"],
    "question": "Как работает замыкания и IIFE.",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee512" }
  },
  {
    "id": "hAEPs5SjZMCy1tXlsPp1",
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "text": [
        "Обычно используют два вида автоматических тестов:\n\nМодульное тестирование (тестирование отдельных частей продукта, обычно отдельных функций/методов)\n\nФункциональное тестирование — тестирование некого функционала продукта, при этом продукт воспринимается как единый «чёрный ящик»."
      ],
      "link": []
    },
    "tableIndex": 190,
    "description": "тест",
    "question": "В чём различие между юнит-тестами и функциональными/интеграционными тестами?",
    "popularity": "4",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee47c" }
  },
  {
    "id": "hKuzFra8P7bpLl8IRfFI",
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Это поведенческий шаблон проектирования, который инкапсулирует то, как набор объектов взаимодействует друг с другом. Он обеспечивает центральную власть над группой объектов, способствуя слабой связи, не позволяя объектам явно ссылаться друг на друга.\n\nВ этом примере у нас есть TrafficTower в качестве посредника, который управляет тем, как объекты Airplane взаимодействуют друг с другом. Все объекты Airplane регистрируются в объекте TrafficTower, и именно объект класса-посредника управляет тем, как объект Airplane получает данные о координатах всех других объектов Airplane."
      ],
      "code": [
        "class TrafficTower {\n  constructor() {\n    this._airplanes = [];\n  }\n\n  register(airplane) {\n    this._airplanes.push(airplane);\n    airplane.register(this);\n  }\n\n  requestCoordinates(airplane) {\n    return this._airplanes.filter(plane => airplane !== plane).map(plane => plane.coordinates);\n  }\n}\n\nclass Airplane {\n  constructor(coordinates) {\n    this.coordinates = coordinates;\n    this.trafficTower = null;\n  }\n\n  register(trafficTower) {\n    this.trafficTower = trafficTower;\n  }\n\n  requestCoordinates() {\n    if (this.trafficTower) return this.trafficTower.requestCoordinates(this);\n    return null;\n  }\n}\n\n// usage\nconst tower = new TrafficTower();\n\nconst airplanes = [new Airplane(10), new Airplane(20), new Airplane(30)];\nairplanes.forEach(airplane => {\n  tower.register(airplane);\n});\n\nconsole.log(airplanes.map(airplane => airplane.requestCoordinates())) \n// [[20, 30], [10, 30], [10, 20]]"
      ]
    },
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "type": "question",
    "description": "Mediator Pattern - Медиатор",
    "question": "Что такое Mediator Pattern в Javascript?"
  },
  {
    "id": "hiI1y5pPjRvjZ83YTu8q",
    "question": "В чем разница между строчным и блочно-строчным элементом?",
    "tableIndex": 192,
    "description": "строчные, блочные",
    "difficulty": "junior",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee479" },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно встроенному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде тега <img>). При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как встроенный."
      ]
    },
    "competence": ["html", "css", "frontend"],
    "popularity": "4"
  },
  {
    "id": "hiXj6O0OA6cwcga3bs0n",
    "question": "Как получить координаты объекта?",
    "difficulty": "junior",
    "description": "Как получить координаты объекта?",
    "answer": {
      "code": [
        "domRect = element.getBoundingClientRect();",
        "// This example demonstrates how bounding client rect is changing when document is scrolled.\nfunction update() {\n  const container = document.getElementById(\"controls\");\n  const elem = document.getElementById(\"example\");\n  const rect = elem.getBoundingClientRect();\n\n  container.innerHTML = '';\n  for (let key in rect) {\n    if(typeof rect[key] !== 'function') {\n      let para = document.createElement('p');\n      para.textContent  = `${ key } : ${ rect[key] }`;\n      container.appendChild(para);\n    }\n  }\n}\n\ndocument.addEventListener('scroll', update);\nupdate();"
      ],
      "text": ["element.getBoundingClientRect()"],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"
      ]
    },
    "competence": ["javascript"],
    "type": "question",
    "popularity": "4",
    "tableIndex": 193
  },
  {
    "id": "hofyoCOCszDAdhPJ4L4o",
    "_id": { "$oid": "60de0704e2c8c53194aee45a" },
    "question": "Можете ли вы привести пример использования стрелочных функции =>?\nЧем они отличаются от других функций?",
    "popularity": "5",
    "tableIndex": 194,
    "competence": ["javascript"],
    "answer": {
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"
      ],
      "text": [
        "Одним очевидным преимуществом стрелочных функций является упрощение синтаксиса, необходимого для создания функций, без необходимости использования ключевого слова function. This внутри стрелочных функций также привязано к замыкающей области видимости, в отличие от обычных функций, где this определяется контекстом, в котором они вызываются. Лексически привязанное this полезно при вызове callback-функций, особенно в компонентах React."
      ]
    },
    "difficulty": "junior",
    "type": "question",
    "description": "arrow function"
  },
  {
    "id": "iClWdAp6CpSc9iXyLK3M",
    "answer": {
      "code": [],
      "link": [
        "http://codenet.ru/progr/visualc/Hungarian-Notation.php",
        "https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%BD%D0%B3%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F"
      ],
      "text": [
        "Внутренний стандарт Microsoft для названия переменных. Для облегчения понимания что чем является и стандартизации написания кода.",
        "Префикс\tСокращение от\tСмысл\tПример\ns\tstring\tстрока\tsClientName\nsz\tzero-terminated string\tстрока, ограниченная нулевым символом\tszClientName\nn, i\tint\tцелочисленная переменная\tnSize, iSize\nl\tlong\tдлинное целое\tlAmount\nb\tboolean\tбулева переменная\tbIsEmpty\na\tarray\tмассив\taDimensions\nt, dt\ttime, datetime\tвремя, дата и время\ttDelivery, dtDelivery\np\tpointer\tуказатель\tpBox\nlp\tlong pointer\tдвойной (дальний) указатель\tlpBox\nr\treference\tссылка\trBoxes\nh\thandle\tдескриптор\thWindow\nm_\tmember\tпеременная-член\tm_sAddress\ng_\tglobal\tглобальная переменная\tg_nSpeed\nC\tclass\tкласс\tCString\nT\ttype\tтип\tTObject\nI\tinterface\tинтерфейс\tIDispatch\nv\tvoid\tотсутствие типа\tvReserved"
      ]
    },
    "popularity": "2",
    "competence": ["common questions"],
    "question": "Или что такое Венгерская нотация?\n",
    "description": "Что за штука такая?",
    "difficulty": "middle",
    "type": "question",
    "tableIndex": 195
  },
  {
    "id": "iNRhbjqMZlJtKSXt2vJv",
    "question": "Как следует оформлять страницу, содержимое которой может быть на разных языках?",
    "description": "multiple languages",
    "tableIndex": 196,
    "answer": {
      "text": [""],
      "link": [],
      "code": [
        "<html lang=\"fr\">\n<span title=\"Spanish\">\n  <a lang=\"es\" href=\"qa-html-language-declarations.es\">Español</a>\n</span>\n \n Это пример HTTP заголовка \n Content-Language: en, hi, pa"
      ]
    },
    "type": "question",
    "competence": ["javascript"],
    "popularity": "1",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee468" }
  },
  {
    "id": "ilGxYSK4w35lA3j6FKZF",
    "competence": ["javascript"],
    "type": "question",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Ширина — ширина площади содержимого элемента. Для блочных элементов значение по умолчанию равно 100%. У строчных элементов ширина зависит от содержимого.\n\nВысота — определяет высоту элемента. Как правило, она зависит от внутреннего содержимого, но при желании можно указать конкретную высоту. Опять же, это работает только с блочными элементами.\n\nГраницы — границы есть у каждого элемента, даже есливы их не видите. У них может быть разный размер, цвет и оформление.\n\nОтступы — они определяют расстояние между границей элемента и его содержимым. Их можно использовать, например, для того, чтобы текст внутри элемента оставался читаемым.\n\nПоля — они определяют расстояние между границей элемента и тем, что его окружает."
      ]
    },
    "description": "блочная модель",
    "popularity": "4",
    "_id": { "$oid": "60de0704e2c8c53194aee477" },
    "tableIndex": 197,
    "question": "Объясните своими словами, что такое блочная модель.",
    "difficulty": "junior"
  },
  {
    "id": "ipXEJgoCTFZzcWdbqrT3",
    "description": "ARIA role ",
    "popularity": "2",
    "competence": ["javascript", "html", "frontend"],
    "answer": {
      "code": [
        "Роли ARIA\n<header role=\"banner\">\n\n<div role=\"contentinfo\">\n    This website was built by Georgie.\n</div>\n\n<span class=\"frame-corner\" role=\"presentation\"></span>\n\nАтрибуты ARIA\nВсе атрибуты используют префикс aria- и делятся на две группы: состояния и свойства.\n\nЗначения атрибутов-состояний изменяются в результате взаимодействия с пользователем.\nЗначения атрибутов-свойств, как правило, остаются неизменны.\n\n<input type=\"radio\" aria-checked=\"true\">\n\n<label id=\"address\">Address</label>\n<input type=\"text\" aria-labelledby=\"address\">\n\n<figure aria-labelledby=\"operahouse_1\">\n    <img src=\"operahousesteps.jpg\" alt=\"The Sydney Opera House\">\n    <figcaption id=\"operahouse_1\">We saw the opera <cite>Barber of Seville</cite> here!</figcaption>\n</figure>"
      ],
      "link": [
        "https://prgssr.ru/development/ispolzovanie-aria-v-html5.html",
        "https://developer.mozilla.org/ru/docs/Web/Accessibility/ARIA",
        "https://www.internet-technologies.ru/articles/ispolzovanie-standartov-aria-v-html.html"
      ],
      "text": [
        "ARIA - Accessible Rich Internet Applications\n\nhtml role\n\nУ элемента может быть только одна роль\n\nАтрибут alt"
      ]
    },
    "type": "question",
    "question": "Что такое ARIA и скринридеры? Как сделать сайт доступным?",
    "_id": { "$oid": "60de0704e2c8c53194aee465" },
    "difficulty": "junior",
    "tableIndex": 198
  },
  {
    "id": "iy5h7zWBaC9TYFSpy1CN",
    "answer": {
      "code": [],
      "text": [
        "AST - это Abstract Syntax Tree, т.е. представление структуры программы в виде дерева объявлений, инструкций и выражений.\n\nТиповой императивный язык программирования (такой как C, C++, PASCAL, Java, JavaScript, C#) состоит из трёх синтаксических элементов:\n\nВыражения (expressions)\nИнструкции (statements)\nОбъявления (declarations)"
      ],
      "link": [
        "https://ps-group.github.io/compilers/ast",
        "https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE",
        "https://webformyself.com/sekret-proizvoditelnosti-javascript-v8-i-skrytye-klassy/",
        "https://webformyself.com/sekret-proizvoditelnosti-javascript-v8-i-skrytye-klassy/",
        "https://www.internet-technologies.ru/articles/strukturirovanie-dannyh-s-pomoschyu-javascript-derevo.html"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4e6" },
    "tableIndex": 199,
    "popularity": "4",
    "type": "question",
    "difficulty": "middle",
    "description": "AST дерево",
    "question": "Что такое Abstract Syntax Tree (AST)?",
    "competence": ["javascript", "html", "frontend"]
  },
  {
    "id": "j8C8R6aVYGtxVu5Y7MDu",
    "answer": {
      "link": ["https://learn.javascript.ru/bubbling-and-capturing"],
      "code": [],
      "text": [
        "Стандарт DOM Events описывает 3 фазы прохода события:\n\nФаза погружения (capturing phase) – событие сначала идёт сверху вниз.\nФаза цели (target phase) – событие достигло целевого(исходного) элемента.\nФаза всплытия (bubbling stage) – событие начинает всплывать.\n\nКогда событие срабатывает на элементе DOM, оно попытается обработать событие (еслипривязан обработчик), затем событие всплывет вверх к своему родителю и это повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть до `document`. Всплытие событий является механизмом, на котором основано делегирование событий. \n\n"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee445" },
    "question": "Что такое всплытие событий (event bubbling)?",
    "type": "question",
    "tableIndex": 200,
    "popularity": "5",
    "description": "всплытие event bubbling",
    "competence": ["common questions"],
    "difficulty": "junior"
  },
  {
    "id": "jHrY41nx0DU9nPGx47H3",
    "question": "Что делает и для чего нужна функция `Function.prototype.bind`?",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee43d" },
    "difficulty": "junior",
    "competence": ["javascript"],
    "popularity": "3",
    "answer": {
      "text": [
        "Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.\n\nПо моему опыту, это наиболее полезно для привязки значения this в методах классов, которые вы хотите передать в другие функции. Это часто делается в компонентах React."
      ],
      "link": [
        "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind"
      ],
      "code": []
    },
    "description": "bind",
    "tableIndex": 201
  },
  {
    "id": "jV37e9yguwftOoMjkEZG",
    "difficulty": "junior",
    "competence": ["javascript"],
    "question": "Какие типы данных вы знаете в javascript?",
    "_id": { "$oid": "60de0704e2c8c53194aee4d4" },
    "tableIndex": 202,
    "type": "question",
    "answer": {
      "code": [],
      "link": ["https://learn.javascript.ru/types"],
      "text": [
        "В JavaScript есть 8 основных типов.\n\nnumber для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).\nbigint для целых чисел произвольной длины.\nstring для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.\nboolean для true/false.\nnull для неизвестных значений – отдельный тип, имеющий одно значение null.\nundefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.\nobject для более сложных структур данных.\nsymbol для уникальных идентификаторов.\nОператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.\n\nИмеет две формы: typeof x или typeof(x).\nВозвращает строку с именем типа. Например, \"string\".\nДля null возвращается \"object\" – это ошибка в языке, на самом деле это не объект."
      ]
    },
    "description": "types типы",
    "popularity": "5"
  },
  {
    "id": "jiyaN7vUpK10tIF3QoZy",
    "tableIndex": 203,
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee448" },
    "description": "=== == ",
    "competence": ["javascript"],
    "difficulty": "beginner",
    "answer": {
      "text": ["=== более строгий, приводит к типу"],
      "code": [],
      "link": [
        "https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons"
      ]
    },
    "question": "В чем разница между `==` и `===`?",
    "popularity": "5"
  },
  {
    "id": "jkFvaZex9h4DGrC0Bk3h",
    "tableIndex": 204,
    "competence": ["javascript"],
    "type": "question",
    "difficulty": "junior",
    "answer": {
      "text": [
        "// ES5 функция-конструктор\n\nfunction Person(name) {\n  this.name = name;\n}\n\n// ES6 класс\n\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\nОсновное отличие в конструкторе возникает при использовании наследования. Если мы хотим создать класс Student (который будет являться подклассом класса Person) и добавить поле studentId, то в дополнение к вышеописанному мы должны сделать следующее:\n\n// ES5 функция-конструктор\n\nfunction Student(name, studentId) {\n  // Вызов конструктора суперкласса для инициализации производных от суперкласса членов.\n\n  Person.call(this, name);\n\n  // Инициализация собственных членов подкласса.\n\n  this.studentId = studentId;\n}\n\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\n// ES6 класс\n\nclass Student extends Person {\n  constructor (name, studentId) {\n    super(name);\n    this.studenId = studentId;\n  }\n}\nНаследование в синтаксисе ES5 является намного более многословным, а в ES6 более понятное и усваиваемое."
      ],
      "link": [
        "https://github.com/FedorovAlexander/Front-end-Job-Interview-Questions/blob/master/JavaScript/42.md",
        "http://jsraccoon.ru/es6-classes"
      ],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee47b" },
    "popularity": "5",
    "question": "В чём разница между классом в ES6 и функцией-конструктором в ES5?",
    "description": "class класс конструктор constructor"
  },
  {
    "id": "jkpoFbuLASvWEIqYnScu",
    "question": "Как появляется контекст у функции?",
    "_id": { "$oid": "60de0704e2c8c53194aee519" },
    "answer": {
      "text": [
        "Контекст выполнения функции — это одно из фундаментальных понятий в JavaScript. Контекстом еще часто называют значение переменной this внутри функции. Также иногда путают понятия «контекст выполнения» и «область видимости» — это не одно и то же. Давайте разберемся с этими понятиями.\n\nКаждый вызов функции имеет и область видимости, и переменную this, и контекст выполнения. Область видимости определяет доступ к переменным при вызове функции и является уникальной для каждого вызова. Значение переменной this — это ссылка на объект, который «вызывает» код в данный момент. Контекст выполнения содержит и область видимости, и аргументы функции, и переменную this."
      ],
      "code": [],
      "link": [
        "https://proweb63.ru/help/js/kontekst-vyipolneniya-funkczii-v-javascript",
        "https://hackerhelp.ru/js/Function_Context.html"
      ]
    },
    "popularity": "4",
    "competence": ["javascript"],
    "difficulty": "junior",
    "type": "question",
    "description": "контекст context",
    "tableIndex": 205
  },
  {
    "id": "jpszSo7cP5HKKGMgzM7o",
    "difficulty": "junior",
    "answer": {
      "text": [
        "Создает новую функцию, которая сохраняется в переменной, привязывает к ней объект. Вызываем через переменную и она вызывается с нужным контекстом."
      ],
      "link": [],
      "code": []
    },
    "tableIndex": 206,
    "competence": ["javascript"],
    "description": "bind",
    "question": "Как работает bind?",
    "type": "question",
    "popularity": "4"
  },
  {
    "id": "jyaXC5JjagVYx9gy3tec",
    "difficulty": "senior",
    "_id": { "$oid": "60de0704e2c8c53194aee4e3" },
    "answer": {
      "code": [],
      "text": [
        "Один из элементов-процессов в работе движка javascript v8, \nByte stream decoder создает токены из декодированного потока байтов, потом это уходит в парсер, где все это превращается в читаемое для машины месиво и обрабатывается дольше."
      ],
      "link": ["https://bool.dev/blog/detail/javascript-engine"]
    },
    "description": "JavaScript Engine byte stream decoder",
    "tableIndex": 207,
    "question": "Что такое byte stream decoder?",
    "competence": ["common questions", "javascript", "frontend"],
    "popularity": "2",
    "type": "question"
  },
  {
    "id": "kFq9jrYlIY7suOskfJDe",
    "_id": { "$oid": "60de0704e2c8c53194aee471" },
    "question": "Приходилось ли вам работать с языками HTML-шаблонизации?",
    "description": "HTML-шаблонизация",
    "answer": {
      "text": ["jade\nSWIG\nPug - на node.js\nTwig - на PHP"],
      "code": [],
      "link": ["https://htmlacademy.ru/blog/boost/tools/html-templates"]
    },
    "difficulty": "middle",
    "competence": ["javascript", "html", "css", "frontend"],
    "type": "question",
    "tableIndex": 208,
    "popularity": "1"
  },
  {
    "id": "kJAnifxxNC8XDunnCYmc",
    "description": "data",
    "popularity": "2",
    "type": "question",
    "tableIndex": 209,
    "answer": {
      "link": [
        "https://developer.mozilla.org/ru/docs/Learn/HTML/Howto/Use_data_attributes"
      ],
      "code": [],
      "text": [
        "В HTML5 для любого элемента можно использовать собственные атрибуты, начинающиеся с префикса data-. Это позволяет хранить разную информацию, которая может помочь в работе скриптов, а также для оформления элементов через CSS."
      ]
    },
    "difficulty": "beginner",
    "_id": { "$oid": "60de0704e2c8c53194aee46a" },
    "question": "Для чего нужны атрибуты, начинающиеся с data-?",
    "competence": ["javascript", "html", "css", "frontend"]
  },
  {
    "id": "kWbVcKflc3vaSYsQXSZZ",
    "answer": {
      "link": [
        "https://www.geeksforgeeks.org/software-design-patterns/",
        "https://www.patterns.dev/posts/classic-design-patterns/",
        "https://en.wikipedia.org/wiki/Design_Patterns",
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15",
        "https://www.educba.com/what-is-design-pattern/"
      ],
      "text": ["Определенный способ решения типовых задач."],
      "code": []
    },
    "competence": ["common questions", "javascript"],
    "question": "Что такое шаблоны - паттерны программирования?",
    "type": "question",
    "difficulty": "junior",
    "popularity": "5",
    "description": "pattern шаблон паттерн"
  },
  {
    "id": "kYZ1LJRU7QJKKK56Lis6",
    "tableIndex": 211,
    "question": "Можно ли из js менять значения в before, after?",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee48c" },
    "popularity": "3",
    "competence": ["javascript"],
    "answer": {
      "text": [
        "Нет, единственное что мы можем — это удалить класс, у которого указаны before или after, либо наоборот добавить."
      ],
      "code": [],
      "link": []
    },
    "difficulty": "junior",
    "description": "before after"
  },
  {
    "id": "kf3jnq3ucFantb51bk9E",
    "description": "Удвоенные значения",
    "question": "Написать функцию, принимающую аргументом массив чисел и возвращающую новый массив, состоящий из удвоенных значений первого.",
    "answer": {
      "text": ["\n "],
      "link": [],
      "code": [
        "f([1, 2, null, 7, 8, null, 3]); // => [2, 4, 14, 16, 6]\nfunction f(arr) {\n  return arr.filter((item) => item !== null).map((item) => item * 2);\n}"
      ]
    },
    "popularity": "5",
    "difficulty": "junior",
    "tableIndex": 212,
    "type": "exercise",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4b8" }
  },
  {
    "id": "kfQMp9LxefZ0LX8tPAUj",
    "question": "Что выведется в консоль ? Объясните почему.",
    "tableIndex": 213,
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4c7" },
    "difficulty": "junior",
    "popularity": "5",
    "type": "question",
    "answer": {
      "text": [
        "// Ответ: 456\n\n// Что же происходит? Когда у объекта устанавливается новое свойство, то JavaScript неявно сделает stringify значения. В коде выше b и c являются объектами, следовательно они оба конвертируются в \"[object Object]\" (String). Так как stringify значения равны, то получается, что мы присваиваем новое значение одному и тому же свойству.\n\n// Равносильно, что написать:\nlet a={},  b='object',  c='object';  a[b]=123;  a[c]=456;"
      ],
      "link": [],
      "code": []
    },
    "description": "let a={},  b={key:'b'},  c={key:'c'};\na[b]=123;\na[c]=456;\nconsole.log(a[b]);"
  },
  {
    "id": "kiDfh3Fe0cf41JN8wpgj",
    "competence": ["javascript", "frontend"],
    "question": "Как создавать окружения в вебпаке?",
    "difficulty": "middle",
    "answer": { "text": ["definePlugins"], "code": [], "link": [] },
    "type": "question",
    "description": "envinment",
    "popularity": "3"
  },
  {
    "id": "klqtMzpp4AQJWGdqgyXf",
    "difficulty": "junior",
    "tableIndex": 215,
    "description": "делегирование событий",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Делегирование событий — подход при работе с событиями DOM-дерева, при котором обработчики событий добавляются не на каждый конкретный элемент, а только на общий родительский, в то время как необходимость вызова это обработчика для конкретного интересующего нас элемента определяется через инициатора события, узнать который можно из свойства объекта события event.target.\n\nТакой подход возможен благодаря особенностям событийной модели DOM-дерева, а конкретно такой особенности, как всплытие событий. \n\nПлюсы\nТакой подход будет хорош, если элементы на странице или в какой-то области создаются динамически на протяжении какого-то промежутка времени. В этом случае, при использовании делегирования, мы можем позволить себе добавить обработчик события единожды и не отслеживать тот момент когда эти элементы будут созданы. \nКроме прочего это в лучшую сторону отразится на потреблении памяти, если таких элементов будет немало. На самом деле, подход с делегированием событием имеет право на жизнь даже если все элементы уже созданы в DOM и их состав не предполагает динамического изменения, но при этом их количество достаточно велико. \n\nМинусы  \nЧуть меньшая «прозрачность» и очевидность по сравнению с тем когда обработчик события добавляется непосредственно для нужного элемента.  Потенциально чуть больше нагрузки ложится на CPU, т.к. любое возникновения события внутри родительского элемента запускает обработчик и поиск необходимого элемента для проверки необходимости работы основного обработчика. Так что тут всё индивидуально, в каждом конкретном случае надо смотреть насколько вероятны возникновения событий, которые будут приходиться «мимо» целевых элементов и что нам более важно оптимизировать — память или CPU.\n\nПодводные камни  \nЛюбой неосторожный event.stopPropagation может прервать цепочку всплытия события и оно не дойдёт до родительского элемента, на котором установлен обработчик. Если реализуете делегирование собственноручно, а не используете готовое решение, то не стоит забывать про тот нюанс, что недостаточно проверить event.target на соответствие требуемому элементу. Необходимо искать по дереву вверх до тех пор пока либо не встретим либо этот элемент, либо родительский, либо дойдём до вершины дерева. Причиной тому служит всё то же всплытие событий — инициатором события может оказаться один из элементов, вложенных в наш, а не он сам. "
      ]
    },
    "question": "Что такое делегирование событий? Плюсы/минусы/подводные камни.",
    "popularity": "5",
    "type": "question",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4b4" }
  },
  {
    "id": "kmR4N3bKZVzvWYvJ0WtF",
    "competence": ["javascript"],
    "type": "question",
    "difficulty": "junior",
    "question": "Как проверить обьекты на равенство?",
    "popularity": "5",
    "description": "равны ли простые обьекты",
    "answer": {
      "link": [],
      "code": [],
      "text": ["JSON.stringify(0bj) === JSON.stringify(0bj)"]
    }
  },
  {
    "id": "ku6UsFeGl4dhM5iDje3k",
    "description": "// Дана структура данных в виде дерева:\nconst tree = {\n  value: 1,\n  children: [\n    {\n      value: 2,\n      children: [{ value: 4 }, { value: 5 }],\n    },\n    {\n      value: 3,\n      children: [{ value: 6 }, { value: 7 }],\n    },\n  ],\n};\n\n//  Необходимо написать функцию, возвращающую значения всех вершин дерева:\ngetTreeValues(tree); // => [1, 2, 3, 4, 5, 6, 7]",
    "popularity": "5",
    "question": "Обход дерева",
    "type": "exercise",
    "difficulty": "middle",
    "answer": {
      "link": [],
      "code": [
        "//  Через рекурсию:\nfunction getTreeValues(tree) {\n  let values = [tree.value];\n  if (Array.isArray(tree.children)) {\n    tree.children.forEach(\n      (item) => (values = values.concat(getTreeValues(item)))\n    );\n  }\n  return values;\n}",
        "//  Через цикл:\nfunction getTreeValues(tree) {\n  const tmpTree = [tree];\n  const res = [];\n  let current;\n  while (tmpTree.length > 0) {\n    current = tmpTree.shift();\n    res.push(current.value);\n    if (current.children) {\n      current.children.forEach((item) => tmpTree.push(item));\n    }\n  }\n  return res;\n}"
      ],
      "text": [""]
    },
    "tableIndex": 217,
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee4b9" }
  },
  {
    "id": "kzvjCu2ZJuwLdFbi6jeE",
    "popularity": "4",
    "answer": {
      "code": [
        "const Person = function(firstName) {\n  this.firstName = firstName; \n  this.sayName1 = function() { console.log(this.firstName); }; \n  this.sayName2 = () => { console.log(this.firstName); }; \n}; \n\nconst john = new Person(‘John’); \nconst dave = new Person(‘Dave’); \njohn.sayName1(); // John \njohn.sayName2(); // John \n\n// У обычной функции значение `this` может быть изменено, но у стрелочной функции нет \njohn.sayName1.call(dave); // Dave (потому что ‘this’ сейчас ссылается наобъект dave) \njohn.sayName2.call(dave); // John \njohn.sayName1.apply(dave); // Dave (потому что ‘this’ сейчас ссылается наобъект dave) \njohn.sayName2.apply(dave); // John \njohn.sayName1.bind(dave)(); // Dave (потому что ‘this’ сейчас ссылается наобъект dave) \njohn.sayName2.bind(dave)(); // John \n\nvar sayNameFromWindow1 = john.sayName1; \nsayNameFromWindow1(); // undefined (потому что ‘this’ сейчас ссылается наобъект window) \nvar sayNameFromWindow2 = john.sayName2; \nsayNameFromWindow2(); // John "
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
        "https://medium.com/@machnicki/handle-events-in-react-with-arro<span style=\"display:none\">w-functions-ede88184bbb</span>"
      ],
      "text": [
        "Основным преимуществом использования стрелочной функции в качестве метода внутри конструктора является то, что значение this устанавливается во время создания функции и не может измениться после этого. Таким образом, когда конструктор используется для создания нового объекта, this всегда будет ссылаться на этот объект. Например, допустим, у нас есть конструктор Person, который принимает имя в качестве аргумента, имеет два метода для вывода в консоль этого имени, один в качестве обычной функции, а другой в качестве стрелочной: ",
        "Смысл заключается в том, что this можно изменить для обычной функции, но\nдля стрелочных функций контекст всегда остается неизменным. Поэтому, даже\nесли вы передаете стрелочную функцию в разные части вашего приложения, вам не\nнужно беспокоиться об изменении контекста. \nЭто может быть особенно полезно в классовых React-компонентах. Если вы\nопределяете метод класса для чего-то такого, как обработчик клика, используя\nобычную функцию, а затем передаете этот обработчик в дочерний компонент в\nкачестве prop, вам также необходимо привязать this в конструкторе\nродительского компонента , Если вместо этого вы используете стрелочную\nфункцию, то нет необходимости привязывать this, так как метод автоматически\nполучит свое значение this из замыкающего лексического контекста. (Прочитайте\nэту статью о стрелочных функциях:\nhttps://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb)"
      ]
    },
    "description": "arrow function constructor",
    "question": "В чем преимущество использования стрелочных функций для метода в конструкторе?",
    "_id": { "$oid": "60de0704e2c8c53194aee45b" },
    "type": "question",
    "tableIndex": 218,
    "difficulty": "junior",
    "competence": ["javascript"]
  },
  {
    "id": "lMsMYvUOJPYzukgdXCvN",
    "type": "question",
    "answer": {
      "text": [
        "Делегирование\n событий — это приём, заключающийся в добавлении обработчиков событий к\n родительскому элементу, а не к дочерним элементам. Обработчик будет\n срабатывать всякий раз, когда событие будет запущено на дочерних элементах\n благодаря всплытию событий в DOM. Преимущества этого приёма:<br>\n Экономит объем используемой памяти, т.к. для родительского элемента\n требуется только один обработчик.<br>\n Не нужно привязывать или убирать обработчики при добавлении и удалении\n элементов.",
        "Еще многого много текста ответ"
      ],
      "link": [
        "https://davidwalsh.name/event-delegate",
        "https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation"
      ],
      "code": [
        " applyFilter(event: Event) {\n const filterValue = (event.target as HTMLInputElement).value;\n this.dataSource.filter = filterValue.trim().toLowerCase();\n }",
        " ngAfterViewInit() {\n this.dataSource.sort = this.sort;\n }",
        " // фильтруем таски как надо и выставляем в таблицу\n setTableData(config: ISobesConfigModel): void {\n let newDataSource: ITask[] = [];\n\n let matchedQuestions: ITask[] = [];\n let matchedExercises: ITask[] = [];\n let unmatchedQuestions: ITask[] = [];\n let unmatchedExercises: ITask[] = [];\n\n let questionNumber = Math.round(config.count * config.type / 100);\n let exerciseNumber = config.count - questionNumber;\n\n this.tasks.forEach((task: ITask) => {\n let taskChecker = (task: ITask, config: ISobesConfigModel) => {\n return task.competence.every(v => config.competence.includes(v));\n };\n if (config.difficulty.includes(task.difficulty) && config.popularity.includes(task.popularity) && taskChecker(task, config)) {\n if (task.type === 'question') {\n matchedQuestions.push(task)\n }\n if (task.type === 'exercise') {\n matchedExercises.push(task)\n }\n } else {\n if (task.type === 'question') {\n unmatchedQuestions.push(task)\n } else if (task.type === 'exercise') {\n unmatchedExercises.push(task)\n } else {\n unmatchedQuestions.push(task);\n }\n }\n });\n\n let matchedQuestionsRandom = [];\n for (let i = 0; i < matchedQuestions.length; i++) {\n let it = this.randomizer(matchedQuestions);\n matchedQuestionsRandom.push(it);\n }\n\n let matchedExercisesRandom = [];\n for (let i = 0; i < matchedExercises.length; i++) {\n let it = this.randomizer(matchedExercises);\n matchedExercisesRandom.push(it);\n }\n\n let unmatchedQuestionsRandom = [];\n for (let i = 0; i < unmatchedQuestions.length; i++) {\n let it = this.randomizer(unmatchedQuestions);\n unmatchedQuestionsRandom.push(it);\n }\n\n let unmatchedExercisesRandom = [];\n for (let i = 0; i < unmatchedExercises.length; i++) {\n let it = this.randomizer(unmatchedExercises);\n unmatchedExercisesRandom.push(it);\n }\n\n let questions: ITask[] = matchedQuestionsRandom.concat(unmatchedQuestionsRandom);\n let exercises: ITask[] = matchedExercisesRandom.concat(unmatchedExercisesRandom);\n\n newDataSource.push(...questions.slice(0, questionNumber));\n newDataSource.push(...exercises.slice(0, exerciseNumber));\n\n if (questionNumber > questions.length) {\n newDataSource.push(...exercises.slice(exerciseNumber, exerciseNumber + questionNumber - questions.length));\n }\n\n if (exerciseNumber > exercises.length) {\n newDataSource.push(...questions.slice(questionNumber, questionNumber + exerciseNumber - exercises.length));\n }\n newDataSource = this.setTableIndex(0, newDataSource);\n this.dataSource = new MatTableDataSource(newDataSource);\n }"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee430" },
    "question": "Объясните\n делегирование событий",
    "popularity": "5",
    "description": "Пожалуйста! Еще разик!",
    "competence": ["javascript", "html"],
    "difficulty": "junior"
  },
  {
    "id": "lbWxNrLHgkZKfSzFAfJG",
    "question": "Как быстрее всего найти сумму элементов массива?",
    "description": "сумма массива",
    "type": "question",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee49a" },
    "popularity": "4",
    "tableIndex": 220,
    "answer": {
      "text": [
        "var sum = 101*50, sumArr = eval([4, 2, ... 3, 7].join('+').replace('++', '+')), res;\n\nres = sum-sumArr;"
      ],
      "link": [],
      "code": []
    },
    "difficulty": "junior"
  },
  {
    "id": "lcvVPWE6lB3RCbmtAbcc",
    "popularity": "4",
    "difficulty": "junior",
    "competence": ["javascript", "html", "css"],
    "type": "question",
    "description": "getBoundingClientRect",
    "question": "Что такое .getBoundingClientRect()?",
    "tableIndex": 221,
    "answer": {
      "code": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"
      ],
      "text": ["Находит позицию элемента на странице с точками-вершинами"],
      "link": []
    }
  },
  {
    "id": "m3JByqTjWZhoWY4psE9F",
    "popularity": "4",
    "type": "question",
    "tableIndex": 222,
    "difficulty": "junior",
    "question": "Что такое execution context? (контекст выполнения)",
    "competence": ["javascript"],
    "answer": {
      "code": [],
      "link": [
        "https://medium.com/webbdev/js-a4a9dfed9782",
        "https://habr.com/ru/company/ruvds/blog/422089/",
        "http://jsflow.org/docs/exec-context-fundamentals/"
      ],
      "text": [
        "Контекст выполнения\nКонтекст выполнения (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста."
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee4df" },
    "description": "execution context, контекст выполнения"
  },
  {
    "id": "m6XVRIPFqHjPJHS3tdQt",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee51c" },
    "question": "Расскажите про свойство length у массива.",
    "type": "question",
    "competence": ["javascript"],
    "description": "length",
    "popularity": "1",
    "answer": {
      "link": [
        "https://flagman.top/about-business/php-i-t-p-uzelki/svojstvo-length-massivov",
        "https://www.internet-technologies.ru/articles/taynaya-sila-svoystva-array-length.html"
      ],
      "text": [
        "Очень интересное свойство. Читать по ссылкам подробнее. Объект, имеющий свойство length."
      ],
      "code": []
    },
    "tableIndex": 223
  },
  {
    "id": "mDvoQospWhIZZAhsfq85",
    "difficulty": "junior",
    "popularity": "1",
    "_id": { "$oid": "60de0704e2c8c53194aee486" },
    "type": "question",
    "tableIndex": 224,
    "competence": ["javascript"],
    "question": "Что покажут эти два alert?",
    "description": "alert",
    "answer": {
      "code": [
        "var foo = \"Hello\";\n(function () {\n  var bar = \" World\";\n  alert(foo + bar);\n})();\nalert(foo + bar);\n// Hello world \n// Uncaught ReferenceError: bar is not defined at <anonymous>:6:13\n"
      ],
      "link": [],
      "text": [""]
    }
  },
  {
    "id": "mHVoUjAobmw31yT7oA8p",
    "_id": { "$oid": "60de0704e2c8c53194aee489" },
    "difficulty": "junior",
    "question": "Что выводит код ниже?",
    "answer": {
      "text": [
        "console.log(\"one\");\nsetTimeout(function () {\n  console.log(\"two\");\n}, 0);\nconsole.log(\"three\");"
      ],
      "code": [],
      "link": []
    },
    "type": "question",
    "competence": ["javascript"],
    "tableIndex": 225,
    "description": "Что выведет console.log",
    "popularity": "5"
  },
  {
    "id": "mfFkHwdsQywjGLYKBDvC",
    "question": "Что такое Singleton Pattern в Javascript?",
    "difficulty": "middle",
    "answer": {
      "text": [
        "Паттерн подразумевает наличие только одного ЕДИНСТВЕННОГО инстанса класса, который используется по всему приложению и содержит в себе всю функциональность. Например, это mangoose, библиотека для использования монгоДБ. Она инициилизируется единожды во время создания приложения и потом уже используется. Или какие-нибудь mysql инстансы и другие для использования в БД."
      ],
      "code": [
        "class Database {\n  constructor(data) {\n    if (Database.exists) {\n      return Database.instance;\n    }\n    this._data = data;\n    Database.instance = this;\n    Database.exists = true;\n    return this;\n  }\n\n  getData() {\n    return this._data;\n  }\n\n  setData(data) {\n    this._data = data;\n  }\n}\n\n// usage\nconst mongo = new Database('mongo');\nconsole.log(mongo.getData()); // mongo\n\nconst mysql = new Database('mysql');\nconsole.log(mysql.getData()); // mongo"
      ],
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ]
    },
    "popularity": "4",
    "competence": ["common questions", "javascript"],
    "description": "Singleton Pattern",
    "type": "question"
  },
  {
    "id": "mvCNUPRa1ZW8Z2XxXtxh",
    "tableIndex": 227,
    "answer": {
      "code": [],
      "text": [
        "width: 100px;\nheight: 100px;\nborder-right: 1px solid #f00;\nborder-radius: 0 50% 50% 0;"
      ],
      "link": []
    },
    "competence": ["javascript"],
    "description": "полукруг",
    "question": "Нарисуйте стилями полукруг.",
    "popularity": "3",
    "type": "exercise",
    "_id": { "$oid": "60de0704e2c8c53194aee491" },
    "difficulty": "junior"
  },
  {
    "id": "mwblxGSefusnWXYPE2dU",
    "description": "типы данных, типы переменных",
    "competence": ["javascript"],
    "question": "Какие есть типы переменных?",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee50a" },
    "difficulty": "junior",
    "answer": {
      "text": [
        "После инициализации переменные могут получать значения следующих базовых (примитивных, простых) типов данных:\n\nNumber – тип данных, описывающий числа. Здесь нет строгого разделения на целые числа и числа с плавающей запятой как в других языках программирования;\nString – тип данных, описывающий текстовые данные. В языке JavaScript нет отдельного типа данных на отдельный символ (типа char нет);\nBoolean – логический тип данных. Переменные этого типа получают только два возможных значения: true (истина) или false (фальшь, не истина);\nNull – тип, который может принимать только одно значение null;\nUndefined – тип, устанавливаемый в случае, когда переменная объявлена ​​(var) но не инициализирована значением. Значение переменной будет присвоено позже;\nBigint – тип, предназначенный для представления больших целых чисел значения которых выходят далеко за значение типа Number;\nSymbol – определяет уникальное неизменное примитивное значение (атом)."
      ],
      "code": [],
      "link": [
        "https://www.bestprog.net/ru/2022/01/12/javascript-variables-primitive-data-types-comments-constants-ru/"
      ]
    },
    "tableIndex": 228,
    "popularity": "4"
  },
  {
    "id": "nH9TcyT5LCtlsKU4nmGN",
    "difficulty": "junior",
    "description": "интерпретатор Ignition",
    "question": "Что такое интерпретатор Ignition?",
    "popularity": "4",
    "competence": ["javascript"],
    "type": "question",
    "answer": {
      "text": [
        "Когда V8 компилирует JavaScript-код, парсер генерирует абстрактное синтаксическое дерево. Синтаксическое дерево — это древовидное представление синтаксической структуры JS-кода. Интерпретатор Ignition генерирует байт-код из этой структуры данных. Оптимизирующий компилятор TurboFan, в итоге, генерирует из байт-кода оптимизированный машинный код."
      ],
      "link": ["https://habr.com/ru/company/ruvds/blog/336294/"],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee504" },
    "tableIndex": 229
  },
  {
    "id": "nRom6LlWEOjbMWSMujOD",
    "popularity": "4",
    "competence": ["javascript"],
    "question": "Есть строка, состоящая из разных скобок, проверить закрыты ли все.",
    "_id": { "$oid": "60de0704e2c8c53194aee4a6" },
    "answer": {
      "text": [""],
      "link": [],
      "code": [
        "function validBraces(str) {\n  let arrOpenSymbols = [],\n    result = false,\n    countOpenSymbols;\n\n  if (str.length > 0) {\n    for (var i = 0; i < str.length; i++) {\n      if (str[i] === \"{\" || str[i] === \"[\" || str[i] === \"(\") {\n        arrOpenSymbols.push(str[i]);\n      } else {\n        countOpenSymbols = arrOpenSymbols.length;\n        if (\n          (str[i] === \"}\" && arrOpenSymbols[countOpenSymbols - 1] === \"{\") ||\n          (str[i] === \"]\" && arrOpenSymbols[countOpenSymbols - 1] === \"[\") ||\n          (str[i] === \")\" && arrOpenSymbols[countOpenSymbols - 1] === \"(\")\n        ) {\n          arrOpenSymbols.pop();\n        }\n      }\n    }\n\n    if (arrOpenSymbols.length === 0) {\n      result = true;\n    } else {\n      result = false;\n    }\n  }\n  return result;\n}\n\nconsole.log(\"\");\nconsole.log(validBraces(\"()\"));\nconsole.log(validBraces(\"[)\"));\nconsole.log(validBraces(\"{}[]()\"));\nconsole.log(validBraces(\"([{}])\"));\nconsole.log(validBraces(\"())({}}{()][][\"));\n"
      ]
    },
    "difficulty": "junior",
    "tableIndex": 230,
    "description": "Пример строки:\"())({}}{()][][\"",
    "type": "question"
  },
  {
    "id": "nUVdfehKohPLF1hzp8D9",
    "description": "Iterator Pattern - генератор - итератор",
    "popularity": "4",
    "competence": ["common questions", "javascript"],
    "question": "Что такое Iterator Pattern в Javascript?",
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Это поведенческий шаблон проектирования, который обеспечивает способ последовательного доступа к элементам агрегатного объекта без раскрытия его базового представления.\n\nИтераторы имеют особый вид поведения, когда мы последовательно проходим через упорядоченный набор значений, вызывая next(), пока не достигнем конца. Введение итераторов и генераторов в ES6 сделало реализацию шаблона итератора чрезвычайно простой.\n\nУ нас есть два примера ниже. Во-первых, один IteratorClass использует спецификацию итератора, а другой iteratorUsingGenerator использует функции генератора.\n\nSymbol.iterator ( Symbol — новый тип примитивного типа данных) используется для указания итератора по умолчанию для объекта. Чтобы коллекция могла использовать циклическую конструкцию for...of, она должна быть определена. В первом примере мы определяем конструктор для хранения некоторой коллекции данных, а затем определяем Symbol.iterator, который возвращает объект с методом next для итерации.\n\nВо втором случае мы определяем функцию генератора, передавая ей массив данных и итеративно возвращая его элементы, используя next и yield. Генераторная функция — это особый тип функции, которая работает как фабрика для итераторов и может явно поддерживать свое собственное внутреннее состояние и итеративно возвращать значения. Он может приостанавливать и возобновлять собственный цикл выполнения."
      ],
      "code": [
        "// using Iterator\nclass IteratorClass {\n  constructor(data) {\n    this.index = 0;\n    this.data = data;\n  }\n\n  [Symbol.iterator]() {\n    return {\n      next: () => {\n        if (this.index < this.data.length) {\n          return { value: this.data[this.index++], done: false };\n        } else {\n          this.index = 0; // to reset iteration status\n          return { done: true };\n        }\n      },\n    };\n  }\n}\n\n// using Generator\nfunction* iteratorUsingGenerator(collection) {\n  var nextIndex = 0;\n\n  while (nextIndex < collection.length) {\n    yield collection[nextIndex++];\n  }\n}\n\n// usage\nconst gen = iteratorUsingGenerator(['Hi', 'Hello', 'Bye']);\n\nconsole.log(gen.next().value); // 'Hi'\nconsole.log(gen.next().value); // 'Hello'\nconsole.log(gen.next().value); // 'Bye'"
      ]
    },
    "type": "question"
  },
  {
    "id": "nw3jTZUGQPxBpe9DeDxu",
    "tableIndex": 232,
    "answer": {
      "text": [
        "Outline differs from borders! Unlike border, the outline is drawn outside the element's border, and may overlap other content. Also, the outline is NOT a part of the element's dimensions; the element's total width and height is not affected by the width of the outline."
      ],
      "code": [
        "<divclass=\"wrap\">\n  <div class=\"block\"></div>\n  <div class=\"block\"></div>\n  <div class=\"block\"></div>\n</div>\n\n.wrap {\n  width: 600px; \n  height: 200px; \n  border: 1px solid green; \n}\n\n.block {\n  float: left; \n  width: 200px; \n  height: 200px; \n  outline: 1px solid black; \n}"
      ],
      "link": ["https://www.w3schools.com/css/css_outline.asp"]
    },
    "description": "outline",
    "difficulty": "junior",
    "competence": ["html", "css", "frontend"],
    "question": "Вместить три блока 20X20px в ряд, в блок шириной 60px, при этом у блоков должны быть границы.",
    "_id": { "$oid": "60de0704e2c8c53194aee48d" },
    "type": "question",
    "popularity": "3"
  },
  {
    "id": "nwC2bfXl8TOn2MjWWltT",
    "question": "Что такое Flyweight Pattern в Javascript?",
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "code": [
        "// flyweight class\nclass Icecream {\n  constructor(flavour, price) {\n    this.flavour = flavour;\n    this.price = price;\n  }\n}\n\n// factory for flyweight objects\nclass IcecreamFactory {\n  constructor() {\n    this._icecreams = [];\n  }\n\n  createIcecream(flavour, price) {\n    let icecream = this.getIcecream(flavour);\n    if (icecream) {\n      return icecream;\n    } else {\n      const newIcecream = new Icecream(flavour, price);\n      this._icecreams.push(newIcecream);\n      return newIcecream;\n    }\n  }\n\n  getIcecream(flavour) {\n    return this._icecreams.find(icecream => icecream.flavour === flavour);\n  }\n}\n\n// usage\nconst factory = new IcecreamFactory();\n\nconst chocoVanilla = factory.createIcecream('chocolate and vanilla', 15);\nconst vanillaChoco = factory.createIcecream('chocolate and vanilla', 15);\n\n// reference to the same object\nconsole.log(chocoVanilla === vanillaChoco); // true"
      ],
      "text": [
        "Это структурный шаблон проектирования, ориентированный на эффективное совместное использование данных через детализированные объекты. Он используется для повышения эффективности и экономии памяти.\nЭтот шаблон можно использовать для любых целей кэширования. На самом деле, современные браузеры используют вариант шаблона легковеса, чтобы предотвратить загрузку одних и тех же изображений дважды.\nВ этом примере мы создаем мелкомодульный класс Icecream для обмена данными о вкусах мороженого и фабричный класс IcecreamFactory для создания этих объектов-легковесов. Для сохранения памяти объекты перерабатываются, если один и тот же объект создается дважды. Это простой пример реализации легковеса."
      ]
    },
    "description": "Flyweight Pattern",
    "type": "question",
    "popularity": "4",
    "competence": ["common questions", "javascript"]
  },
  {
    "id": "nwK4HEpyzorKCnC8PMyD",
    "tableIndex": 234,
    "competence": ["javascript"],
    "answer": {
      "text": [""],
      "code": [
        "function test() {\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve(1);\n    });\n  });\n}\n\nasync function test1() {\n  var res = await test();\n  console.log(res + 1);\n}"
      ],
      "link": []
    },
    "type": "exercise",
    "difficulty": "junior",
    "popularity": "5",
    "description": "Сделайте промис и получите ответ. Promise",
    "question": "Промисы все разрастаются и на смену Callback Hell приходит Promise Hell. Что же делать?",
    "_id": { "$oid": "60de0704e2c8c53194aee496" }
  },
  {
    "id": "o9jxCs3lEdmz9fIRpdGo",
    "tableIndex": 235,
    "competence": ["javascript"],
    "type": "question",
    "answer": {
      "link": [
        "https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Loops_and_iteration",
        "https://habr.com/ru/post/481548/",
        "https://learn.javascript.ru/iterable",
        "https://webformyself.com/iteratory-i-generatory-javascript-polnoe-rukovodstvo/"
      ],
      "code": [
        "userNamesGroupedByLocation[Symbol.iterator] = function() {\n  const cityKeys = Object.keys(this);\n  let cityIndex = 0;\n  let userIndex = 0;\n \n  return {\n    next: () => {\n      // We already iterated over all cities\n      if (cityIndex > cityKeys.length - 1) {\n        return {\n          value: undefined,\n          done: true,\n        };\n      }\n \n      const users = this[cityKeys[cityIndex]];\n      const user = users[userIndex];\n \n      const isLastUser = userIndex >= users.length - 1;\n \n      userIndex++;\n      if (isLastUser) {\n        // Reset user index\n        userIndex = 0;\n        // Jump to next city\n        cityIndex++\n      }\n \n      return {\n        done: false,\n        value: user,        \n      };\n    },\n  };\n};\n\n\nfor (let name of userNamesGroupedByLocation) {\n  console.log('name', name);\n}\n\n// Output:\n// name Aiko\n// name Chizu\n// name Fushigi\n// name Santiago\n// name Valentina\n// name Lola\n// name Sonja\n// name Dunja\n// name Iwan\n// name Tanja\n"
      ],
      "text": [""]
    },
    "popularity": "3",
    "_id": { "$oid": "60de0704e2c8c53194aee4f0" },
    "difficulty": "middle",
    "question": "Что такое iterator?",
    "description": "iterator [Symbol.iterator]"
  },
  {
    "id": "oEoy0q7OhnMiRJFbQHM3",
    "tableIndex": 236,
    "question": "Требуется сверстать попап по центру, его размеры нам известны, но мы не хотим что бы он прокручивался вместе со страницей, причем по высоте может и не влезать в высоту экрана.",
    "popularity": "4",
    "description": "попап",
    "competence": ["html", "css", "frontend"],
    "_id": { "$oid": "60de0704e2c8c53194aee490" },
    "answer": {
      "text": [""],
      "link": [],
      "code": [
        "body {\n  overflow: hidden; \n} \n\n.wrap {\n  position: fixed; \n  top: 0; \n  left: 0; \n  width: 100%; \n  height: 100%; \n  overflow-y: auto; \n  background-color: rgba(230, 230, 230, .1); \n} \n\n.popup {\n  position: absolute; \n  width: 400px; \n  height: 300px; \n  right: 0; \n  left: 0; \n  top: 0; \n  bottom: 0; \n  margin: auto; \n} \n "
      ]
    },
    "difficulty": "junior",
    "type": "question"
  },
  {
    "id": "oyUbl6D4cQ1k90xnCBvQ",
    "tableIndex": 237,
    "competence": ["common questions"],
    "description": "граф",
    "type": "question",
    "question": "Что такое графы?",
    "answer": {
      "link": [
        "https://habr.com/ru/company/otus/blog/568026/",
        "https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D1%84_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)"
      ],
      "text": [
        "Граф - это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена."
      ],
      "code": []
    },
    "popularity": "3",
    "difficulty": "middle",
    "_id": { "$oid": "60de0704e2c8c53194aee4fb" }
  },
  {
    "id": "pK53IpxExhnWZLtyFjRr",
    "tableIndex": 238,
    "difficulty": "middle",
    "answer": {
      "text": [
        "Turbofan - JIT-компилятор для JavaScript-движка V8. Следующий после JIT-компилятор CrankShaft."
      ],
      "code": [],
      "link": [
        "https://medium.com/devschacht/v8-behind-the-scenes-7ff45a7134fd",
        "https://www.opennet.ru/opennews/art.shtml?num=42577",
        "https://habr.com/ru/company/google/blog/261951/"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee502" },
    "question": "Что такое Компилятор Turbofan?",
    "type": "question",
    "popularity": "3",
    "competence": ["javascript"],
    "description": "Turbofan Компилятор  v8"
  },
  {
    "id": "pg9rTD491JY0yBq0RGw2",
    "popularity": "4",
    "difficulty": "junior",
    "question": "Что такое IIFE? ",
    "description": "IIFE - immediately-invoked function expressions",
    "type": "question",
    "competence": ["javascript"],
    "answer": {
      "code": [
        "(function() {\n\n  let message = \"Hello\";\n\n  alert(message); // Hello\n\n})();"
      ],
      "text": [
        "Это не то, что мы должны использовать сегодня. Функция, которая исполняется сразу."
      ],
      "link": ["https://learn.javascript.ru/closure#okruzhenie-v-detalyah"]
    }
  },
  {
    "id": "phPZOGutvttB2n9Z5oe1",
    "difficulty": "senior",
    "popularity": "5",
    "competence": ["common questions", "javascript"],
    "type": "question",
    "description": "фасад pattern",
    "question": "Что такое фасад pattern?",
    "answer": { "text": ["Надо посомтреть получше"], "link": [], "code": [] }
  },
  {
    "id": "px1hzmlxhrPPkdgGKeRH",
    "question": "Есть div, в нем другой div, у второго задан padding 50%, как это все будет выглядеть?",
    "competence": ["html", "css", "frontend"],
    "answer": {
      "link": [],
      "code": [
        ".wrap {\n  width: 200px;\n  border: 1px solid green; \n}\n \n.block {\n  width: 200px;\n  padding-bottom: 50%;\n  border: 1px solid red;\n}\n "
      ],
      "text": ["Просто блок в блоке."]
    },
    "tableIndex": 241,
    "difficulty": "junior",
    "type": "question",
    "description": "div padding 50%",
    "_id": { "$oid": "60de0704e2c8c53194aee4a5" },
    "popularity": "3"
  },
  {
    "id": "q2dEawsu6PXHcbJwUfPv",
    "popularity": "4",
    "description": "Pull request",
    "difficulty": "junior",
    "question": "Что такое pr?",
    "answer": {
      "text": [
        "pull request (открываем ветку куда запушили, делаем пул реквест с коментарием в основную ветку, в основной ветке принимаем)"
      ],
      "code": [],
      "link": []
    },
    "type": "question",
    "competence": ["common questions"]
  },
  {
    "id": "qBqJ6wUx7rih3LPHWPaS",
    "popularity": "3",
    "answer": {
      "link": [],
      "text": [""],
      "code": [
        "function one(arg) {\n  if (typeof arg === \"function\") {\n    return arg(1);\n  } else {\n    return 1;\n  }\n}\n\nfunction seven(arg) {\n  if (typeof arg === \"function\") {\n    return arg(7);\n  } else {\n    return 7;\n  }\n}\n\nfunction plus(arg) {\n  return function (a) {\n    return a + arg;\n  };\n}"
      ]
    },
    "difficulty": "junior",
    "question": "Реализовать методы seven, plus, one, five, minus, two. seven(plus(one())) -> 8. five(minus(two())) -> 3.",
    "tableIndex": 243,
    "description": "seven, plus, one, five, minus, two",
    "competence": ["javascript"],
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee4a2" }
  },
  {
    "id": "qLqXPkb7KfK794wWUAGI",
    "competence": ["javascript"],
    "popularity": "5",
    "description": "spread  rest ",
    "question": "В чем преимущества использования spread оператора и чем он отличается от rest оператора?",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee460" },
    "tableIndex": 244,
    "answer": {
      "code": [
        "function putDookieInAnyArray(arr) {\n  return […arr, ‘dookie’];\n}\n\nconst result = putDookieInAnyArray([‘I’, ‘really’, “don’t”, ‘like’]); // [“I”, “really”, “don’t”, “like”, “dookie”]\nconst person = { name: ‘Todd’, age: 29,};\nconst copyOfTodd = { …person };",
        "function addFiveToABunchOfNumbers(…numbers) {\n  return numbers.map(x => x + 5);\n}\n\nconst result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15] \nconst [a, b, …rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4] \nconst { e, f, …others } = { e: 1, f: 2, g: 3, h: 4, }; // e: 1, f: 2, others: { g: 3, h: 4 }"
      ],
      "text": [
        "Spread оператор синтаксиса ES6 очень полезен при написании кода в функциональном стиле, поскольку мы можем легко создавать копии массивов или объектов, не прибегая к Object.create, slice или функции библиотеки. Эта языковая функция часто используется в проектах с Redux и rx.js.",
        " В свою очередь, rest оператор синтаксиса ES6 позволяет в сокращенном виде указывать неопределенное количество аргументов, передаваемых в функцию. Можно сказать, что он противоположен spread оператору: собирает данные и добавляет их в массив, вместо разделения массива данных. Он используется в аргументах функций, а также при деструктуризации массивов и объектов. "
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referenc<span style=\"display:none\">e/Functions/rest_parameters</span>",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referenc<span style=\"display:none\">e/Operators/Destructuring_assignment</span>"
      ]
    },
    "type": "question"
  },
  {
    "id": "qOmuMoCAPZ2zO587ux1S",
    "question": "Что такое нагрузочное тестирование?",
    "type": "question",
    "competence": ["common questions"],
    "difficulty": "junior",
    "answer": {
      "link": [],
      "text": [
        "Позволяет сымитировать большое количество пользователей, проверить нагрузочную способность приложения."
      ],
      "code": []
    },
    "description": "Apache JMeter",
    "popularity": "1"
  },
  {
    "id": "qZIvp4C8WCbaqJcM9b1F",
    "description": ".closest('.column')",
    "competence": ["javascript", "html", "css"],
    "difficulty": "junior",
    "answer": {
      "text": [
        "Он ищет ближайшего родителя по модификатору. Лучше чем parentNode"
      ],
      "code": [],
      "link": []
    },
    "popularity": "3",
    "type": "question",
    "question": "Что такое .closest('.column')?"
  },
  {
    "id": "r8eqKsGirIaIyryvjM6n",
    "_id": { "$oid": "60de0704e2c8c53194aee463" },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "graceful degradation — принцип сохранения работоспособности при потере части функциональности. Отказоустойчивость клиентских веб-интерфейсов.\n\nprogressive enhancement - Прогрессивное улучшение предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего. Можно сказать, что сейчас таких этапов четыре: \n  \n  «Старый-добрый-HTML» \n  «CSS» \n  «CSS3» \n  «JavaScript»\n  \n  отказоустойчивость клиентских веб-интерфейсов."
      ]
    },
    "description": "прогрессивное улучшение, деградация, graceful degradation, progressive enhancement",
    "question": "Можете ли вы описать разницу между прогрессивным улучшением и изящной деградацией?",
    "tableIndex": 247,
    "competence": ["javascript"],
    "difficulty": "junior",
    "type": "question",
    "popularity": "4"
  },
  {
    "id": "rA4o7abGgQ4ZlATYzbxk",
    "_id": { "$oid": "60de0704e2c8c53194aee459" },
    "tableIndex": 248,
    "difficulty": "junior",
    "question": "В чем разница между классом в ES6 и функцией-конструктором в ES5?",
    "answer": {
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance",
        "https://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5"
      ],
      "text": [
        "Для начала посмотрим на примеры: \n\n// ES5 функция-конструктор \nfunction Person(name) {\n  this.name = name; \n} \n\n// ES6 класс \nclass Person { \n constructor(name) { \n this.name = name; \n } \n} \n\nОни выглядят довольно похоже, если рассматривать простые конструкторы.\n \nОсновное отличие в конструкторе возникает при использовании наследования.\n\nЕсли мы хотим создать класс `Student` (который будет являться подклассом класса `Person`) и добавить поле `studentId`, то, в дополнение к вышеописанному, мы должны сделать следующее:\n\n// ES5 функция-конструктор \nfunction Student(name, studentId) {\n  // Вызов конструктора суперкласса для инициализации производных от суперкласса членов. \n  Person.call(this, name);\n  // Инициализация собственных членов подкласса. \n  this.studentId = studentId; \n}\n\nStudent.prototype = Object.create(Person.prototype); \nStudent.prototype.constructor = Student; \n\n// ES6 класс \nclass Student extends Person {\n  constructor(name, studentId) { \n    super(name); \n    this.studentId = studentId; \n  } \n}\n\nНаследование в синтаксисе ES5 является намного более многословным, а в ES6 более понятное и усваиваемое."
      ]
    },
    "popularity": "5",
    "competence": ["javascript"],
    "description": "class, constructor, es5, es6",
    "type": "question"
  },
  {
    "id": "rMeREgps5WFCmxfZ4rSn",
    "popularity": "5",
    "difficulty": "beginner",
    "answer": {
      "code": [],
      "link": [
        "https://elementor.com/help/whats-the-difference-between-px-em-rem-vw-and-vh/"
      ],
      "text": ["Там в ссылке глянь"]
    },
    "type": "question",
    "description": "В чем разница?",
    "question": "px % em rem vw vw",
    "competence": ["common questions", "html", "css"]
  },
  {
    "id": "rjQ4wX06mvEN87ZGXS97",
    "popularity": "5",
    "tableIndex": 250,
    "question": "Реализуйте делегирование.",
    "description": "делегирование",
    "competence": ["javascript", "html", "frontend"],
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee4b5" },
    "answer": {
      "text": [""],
      "code": [
        "<div class=\"wrapper\">\n  <div class=\"child\">\n    <div>\n      <div>\n        <div>click me</div>\n      </div>\n    </div>\n  </div>\n  <div class=\"child\">\n    <div>\n      <div>\n        <div>click me</div>\n      </div>\n    </div>\n  </div>\n  <div class=\"child\">\n    <div>\n      <div>\n        <div>click me</div>\n      </div>\n    </div>\n  </div>\n  <div class=\"other\">\n    <div>\n      <div>\n        <div>dont't click me</div>\n      </div>\n    </div>\n  </div>\n</div>",
        "const delegate = (eventName, el, selector, handler) => {\n  el.addEventListener(eventName, (event) => {\n    let node = event.target;\n    const items = [].slice.call(el.querySelectorAll(selector));\n    if (items.length) {\n      while (node !== el && node !== null) {\n        const isTarget = items.some((item) => node === item);\n\n        if (isTarget) {\n          handler(node);\n          break;\n        } else {\n          node = node.parentNode;\n        }\n      }\n    }\n  });\n};\n\ndelegate(\n  \"click\",\n  document.querySelector(\".wrapper\"),\n  \".child\",\n  (el) => (el.style.backgroundColor = \"blue\")\n);\n"
      ],
      "link": ["https://learn.javascript.ru/event-delegation"]
    },
    "type": "exercise"
  },
  {
    "id": "s9KHuZXcSqWi6gtOhn03",
    "competence": ["javascript"],
    "question": "Расскажите, что такое поднятие (hoisting).",
    "difficulty": "junior",
    "tableIndex": 251,
    "_id": { "$oid": "60de0704e2c8c53194aee444" },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Поднятие (hoisting) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова var, будут перемещены в верхнюю часть текущей области, что мы называем \"поднятием\". Однако, \"поднимается\" только объявление переменной, присвоение значения (если оно имеется) останется на\nпрежнем месте.\n\nОбратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.\n\n// объявления переменных через var поднимаются. \nconsole.log(foo); // undefined \nvar foo = 1; \nconsole.log(foo); // 1 \n// объявления переменных через let/const НЕ поднимаются. \nconsole.log(bar); // ReferenceError: bar is not defined \nlet bar = 2; \nconsole.log(bar); // 2 \n\nПри объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная. \n\n// Объявление функции \nconsole.log(foo); // [Function: foo] \nfoo(); // 'FOOOOO' \nfunction foo() { \n  console.log('FOOOOO'); \n} \nconsole.log(foo); // [Function: foo] \n// Функциональное выражение \nconsole.log(bar); // undefined \nbar(); // Uncaught TypeError: bar is not a function \nvar bar = function() { \n  console.log('BARRRR'); \n}; \nconsole.log(bar); // [Function: bar]"
      ]
    },
    "type": "question",
    "popularity": "5",
    "description": "hoisting, поднятие"
  },
  {
    "id": "sqOmqxop55HZw1v6v9eA",
    "question": "Что такое связные списки?",
    "answer": {
      "text": [
        "Основное назначение связного списка — предоставление механизма для хранения и доступа к произвольному количеству данных. Как следует из названия, это достигается связыванием данных вместе в список."
      ],
      "link": ["https://tproger.ru/translations/linked-list-for-beginners/"],
      "code": []
    },
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee4f9" },
    "popularity": "1",
    "description": "связный список, Linked list",
    "difficulty": "junior",
    "competence": ["common questions", "javascript"],
    "tableIndex": 253
  },
  {
    "id": "t7eDNfspmt7XOelkApnI",
    "popularity": "3",
    "description": "margin",
    "answer": {
      "link": [],
      "code": [],
      "text": ["Сдвинется вверх и влево на своих соседей."]
    },
    "type": "question",
    "difficulty": "junior",
    "question": "Что будет если задать margin: -10px;",
    "_id": { "$oid": "60de0704e2c8c53194aee4ae" },
    "tableIndex": 254,
    "competence": ["javascript", "html", "css"]
  },
  {
    "id": "tGj90CNmKJD8X7uWPZe3",
    "tableIndex": 255,
    "popularity": "1",
    "question": "Объясните разницу между <script> <script async> и <script defer>?",
    "difficulty": "junior",
    "answer": {
      "text": [
        "defer\nАтрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда он загрузится.\n\nАтрибут async означает, что скрипт абсолютно независим:  Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.\n\nСобытие DOMContentLoaded и асинхронные скрипты не ждут друг друга: DOMContentLoaded может произойти как до асинхронного скрипт (если асинхронный скрипт завершит загрузку после того, как страница будет готова), …так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)\n\nОстальные скрипты не ждут async, и скрипты c async не ждут другие скрипты."
      ],
      "code": [],
      "link": []
    },
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee46d" },
    "type": "question",
    "description": "defer async script"
  },
  {
    "id": "tUmUiyXtPb7OFg2bpCDx",
    "type": "exercise",
    "difficulty": "junior",
    "description": "Quick sort, быстрая сортировка",
    "competence": ["javascript"],
    "popularity": "5",
    "answer": {
      "code": [
        "const values = [2, 27, 14, 52, 31, 96, 73, 47, 22, 6];\n\nfunction QuickSort(List) {\n   if (List.length <= 1) {\n       return List;\n   }\n\n   const pivot = List[List.length - 1];\n   const leftList = [];\n   const rightList = [];\n\n   for (let i = 0; i < List.length - 1; i++) {\n       if (List[i] < pivot) {\n           leftList.push(List[i]);\n       }\n       else {\n           rightList.push(List[i])\n       }\n   }\n\n   return [...QuickSort(leftList), pivot, ...QuickSort(rightList)];\n}\n\nconsole.log(QuickSort(values));"
      ],
      "link": [
        "https://proglib.io/p/obyasnyaem-algoritm-bystroy-sortirovki-s-pomoshchyu-javascript-2022-01-26"
      ],
      "text": [
        "Тут работает рекурсия. Принцип \"разделяй и властвуй\".\n1. Выбирается опорное значение (pivot).\n2. Все остальные значения раскидываются в два списка лефт(меньше) и райт(больше).\n3. Для каждого списка вызывается эта же функция, пока в массиве не останется одно значение.\n4. Потом все это поднимается наверх. Пивот вставляется между лефт и райт и поднимается вверх, пока не закончится\n5. Получаем отсортированный список."
      ]
    },
    "question": "Реализуйте алгоритм быстрой сортировки. (Quick sort)"
  },
  {
    "id": "u5lUm9sFJQIEKI8UErRM",
    "description": "Constructor Pattern",
    "competence": ["common questions", "javascript"],
    "popularity": "4",
    "question": "Что такое Constructor Pattern в Javascript?",
    "type": "question",
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "code": [
        "// traditional Function-based syntax\nfunction Hero(name, specialAbility) {\n  // setting property values\n  this.name = name;\n  this.specialAbility = specialAbility;\n\n  // declaring a method on the object\n  this.getDetails = function() {\n    return this.name + ' can ' + this.specialAbility;\n  };\n}\n\n// ES6 Class syntax\nclass Hero {\n  constructor(name, specialAbility) {\n    // setting property values\n    this._name = name;\n    this._specialAbility = specialAbility;\n\n    // declaring a method on the object\n    this.getDetails = function() {\n      return `${this._name} can ${this._specialAbility}`;\n    };\n  }\n}\n\n// creating new instances of Hero\nconst IronMan = new Hero('Iron Man', 'fly');\n\nconsole.log(IronMan.getDetails()); // Iron Man can fly"
      ],
      "text": [
        "Просто конструктор в javascript. Создание классов, экземпляров класса через классы или функции."
      ]
    }
  },
  {
    "id": "u6WC4mgpIxd6hsRkYnbH",
    "tableIndex": 258,
    "difficulty": "middle",
    "answer": {
      "text": [
        "Поговорим о движке В8, состоящем из двух компиляторов\nПоследняя версия В8 состоит из двух компиляторов:\n\n– полный-что codegen — простейший компилятор, создающий обычные машинные коды, не отличающиеся высокой скоростью;\n\n– коленвал — компилятор, работающий в системе jit, создающий быстрые и производительные коды.\n\nВ своей работе движок В8 использует разные потоки:\n\nОсновной поток – выполнение прямых задач. То есть – передача кода, его компиляция и реализация;\nДополнительный поток – оптимизирует коды, с целью разгрузки основного потока;\nПотоки для обработки сборщиком мусора.\nКак же все это работает? На стадии первого выполнения кода движок применяет полный-что codegen, задачей которого является преобразование кода в машинный. Так как промежуточная стадия (байт-код) не используется, то необходимость применения в работе переводчика устраняется сама собой."
      ],
      "link": [
        "https://softdroid.net/proizvoditelnost-kompilyatora-i-llvm",
        "https://education-ecosystem.com/blog/v8/"
      ],
      "code": []
    },
    "type": "question",
    "popularity": "2",
    "description": "Codegen",
    "question": "Что такое компилятор Codegen?",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee501" }
  },
  {
    "id": "uCqyLMAqzzHuL8tGwm6M",
    "popularity": "3",
    "description": "attribute property атрибут свойство",
    "difficulty": "junior",
    "competence": ["javascript", "html", "frontend"],
    "answer": {
      "text": [
        "Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы\nпроиллюстрировать разницу, представьте, что у нас есть это текстовое поле в\nHTML: <input type=\"text\" value=\"Hello\">. "
      ],
      "link": [
        "https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html"
      ],
      "code": [
        "const input = document.querySelector('input'); \nconsole.log(input.getAttribute('value')); // Hello \nconsole.log(input.value); // Hello \nНо после того, как вы измените значение текстового поля, добавив к нему\n\"World!\", будет: \nconsole.log(input.getAttribute('value')); // Hello \nconsole.log(input.value); // Hello World!"
      ]
    },
    "question": "В чем разница между \"атрибутом\" (attribute) и \"свойством\" (property)? ",
    "type": "question"
  },
  {
    "id": "uJujVdixOMJRt6rXAnwI",
    "question": "Что такое OCP? (вторая в SOLID)",
    "type": "question",
    "description": "OCP - Open–closed principle - Принцип открытости-закрытости",
    "popularity": "5",
    "difficulty": "junior",
    "answer": {
      "link": [
        "https://medium.com/webbdev/solid-4ffc018077da",
        "https://blog.logrocket.com/solid-principles-single-responsibility-in-javascript-frameworks/",
        "https://stackify.com/solid-design-open-closed-principle/"
      ],
      "text": [
        "Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации."
      ],
      "code": []
    },
    "competence": ["common questions"]
  },
  {
    "id": "uMVyVrx8TikqYTMeEMI8",
    "popularity": "5",
    "answer": {
      "link": [],
      "text": [""],
      "code": [
        "var arr = [{date: '10.01.2017'}, {date: '05.11.2016'}, {date: '21.13.2002'}];\n \narr.forEach(function(item) {\n  var arrDate = item.date.split('.'), date = new Date(Number(arrDate[2]), Number(arrDate[1]), Number(arrDate[0]));\n  item.time = date.getTime();\n});\n\narr.sort(function (a, b) {\n  if (a.time - b.time < 0) {\n    return false;\n  } else {\n    return true;\n  }\n});\n\nvar res = arr.map(function (item) {\n  return {date: item.date};\n});\nconsole.log(res);"
      ]
    },
    "difficulty": "middle",
    "competence": ["javascript"],
    "tableIndex": 261,
    "_id": { "$oid": "60de0704e2c8c53194aee492" },
    "question": "Есть массив в котором лежат объекты с датами, отсортировать по датам.",
    "description": "date sort,  сортировка дат",
    "type": "exercise"
  },
  {
    "id": "uWUZko8dD6kom4N2y4ln",
    "question": "Объясните разницу между раскладкой (layout), painting и композитингом (compositing).",
    "answer": {
      "link": [],
      "text": [
        "Если очень кратко и поверхностно, то перед выводом картинки на экран браузер проходит 5 стадий, часть из которых может быть опущена:\n\nОбработка JS > вычисление стилей > расчет макета > прорисовка > компановка.\n\nСначала отрабатывают скрипты, в результате которых картинка может измениться. \n\nДалее идет вычисление стилей, чтобы понять, что изменилось и применить данные изменения. В свою очередь это может вызвать расчет макета, если были затронуты свойства, влияющие на размеры и т.п. элемента. \n\nПосле идет прорисовка, если были задеты свойства, вроде изменения цвета, тени и т.п.\n\nПосле идет компановка, то бишь сведение всех измененных слоев в правильном порядке и выведения их на экран пользователя.\n\nИзоляция размеров — тот случай, когда у родителя отсутствует указание размеров, аля `width: auto; height: auto;` и т.п. В таком случае дочерний элемент может повлиять на родительский и изменить (к примеру, увеличить) его размеры. Вот `contain: size;` у родителя как раз и не даст этого сделать.  Ну а по существу, перевод есть перевод и, тем более, первый параграф сего ответа не является целью данной статьи, ибо так статьи излишне распухнет."
      ],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee47d" },
    "type": "question",
    "tableIndex": 262,
    "popularity": "4",
    "competence": ["javascript"],
    "difficulty": "junior",
    "description": "layout painting  compositing"
  },
  {
    "id": "ujN0ccZ1udAq6KExmBnP",
    "description": "Объедините два массива",
    "question": "Объедините два массива с вложенностью [1, [1, 2, [3, 4]], [2, 4]] -> [1, 1, 2, 3, 4, 2, 4] \n ",
    "popularity": "5",
    "difficulty": "junior",
    "_id": { "$oid": "60de0704e2c8c53194aee4c9" },
    "tableIndex": 263,
    "type": "question",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "code": [
        "const flatten = (arr) => arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten),[]);"
      ],
      "text": [
        "Задачу можно решать различными способами. Обычно хотят узнать знает ли собеседуемый такой метод как reduce.\n\nИдея заключается в том, чтобы обойти все элементы исходного массива и его “под массивов” с целью вернуть найденные значения в новый массив. Это происходит рекурсивно пока мы не дойдём до последнего элемента.  \n\nТак же с формированием нового массива нам помогает concat. "
      ]
    }
  },
  {
    "id": "uyPJUX1bhqjxMsmh5bSn",
    "description": "Функция высшего порядка. High order function HOF",
    "_id": { "$oid": "60de0704e2c8c53194aee45c" },
    "type": "question",
    "tableIndex": 264,
    "answer": {
      "link": [
        "https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99",
        "https://hackernoon.com/effective-functional-javascript-first-class-and-higher-order-functions-713fde8df50a",
        "https://eloquentjavascript.net/05_higher_order.html"
      ],
      "code": [
        "// Допустим, у нас есть массив с именами, которые нам нужны о преобразовать в верхний регистр. \nconst names = ['irish', 'daisy', 'anna']; \n\n// Императивное решение будет выглядеть так: \nconst transformNamesToUppercase = function(names) {\n  const results = [];\n  for (let i = 0; i &lt; names.length; i++) {\n    results.push(names[i].toUpperCase());\n  }\n  return results;\n};\ntransformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA'] \n\n// Воспользууемся .map(transformerFn), чтобы сделать код декларативным и более коротким:\nconst transformNamesToUppercase = function(names) {\n  return names.map(name =&gt; name.toUpperCase()); \n}; \ntransformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']"
      ],
      "text": [
        "Функция высшего порядка — это любая функция, которая принимает одну или несколько функций в качестве аргументов, которые она использует для работы с данными и/или возвращает функцию в качестве результата. \n\nФункции высшего порядка предназначены для абстрагирования некоторой операции, которая выполняется повторно. Классическим примером является метод map, который принимает массив и функцию в качестве аргументов. Затем `map` использует эту функцию для преобразования каждого элемента в массиве, возвращая новый массив с преобразованными данными. \n\nДругими популярными примерами в JavaScript являются forEach, filter и reduce. Функции высшего порядка используют не только для манипуляций с массивами, но также и для возврата функции из другой функции, например при использовании Function.prototype.bind.\n\nMap \n"
      ]
    },
    "competence": ["javascript"],
    "popularity": "5",
    "difficulty": "junior",
    "question": "Дайте определение функции высшего порядка."
  },
  {
    "id": "uzmIdwJdlOPbOlOOdkMx",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "text": [
        "Каждый скрипт имеет доступ к глобальной области видимости, и если каждый будет использовать глобальное пространство имен для определения своих переменных, то могут возникнуть конфликты. Используйте модульный паттерн (используя IIFE) для инкапсуляции ваших переменных в локальное пространство имен."
      ],
      "code": []
    },
    "popularity": "1",
    "question": "Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?",
    "tableIndex": 265,
    "_id": { "$oid": "60de0704e2c8c53194aee44e" },
    "type": "question",
    "description": "global scope",
    "difficulty": "junior"
  },
  {
    "id": "v0c4MnjohCCIC1Pu4idu",
    "question": "Что такое Proxy Pattern в Javascript?",
    "competence": ["common questions", "javascript"],
    "difficulty": "middle",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "text": [
        "Это структурный шаблон проектирования, который ведет себя точно так, как следует из его названия. Он действует как суррогат или заполнитель для другого объекта для управления доступом к нему.\n\nОбычно он используется в ситуациях, когда целевой объект находится под ограничениями и может быть не в состоянии эффективно выполнять все свои обязанности. Прокси в этом случае обычно предоставляет тот же интерфейс для клиента и добавляет уровень косвенности для поддержки контролируемого доступа к целевому объекту, чтобы избежать чрезмерного давления на него.\nШаблон прокси может быть очень полезен при работе с приложениями, обрабатывающими сетевые запросы, чтобы избежать ненужных или избыточных сетевых запросов.\n\nВ этом примере мы будем использовать две новые функции ES6, Proxy и Reflect. Объект Proxy используется для определения пользовательского поведения для основных операций объекта JavaScript (помните, что функции и массивы также являются объектами в JavaScript). Это метод конструктора, который можно использовать для создания объекта Proxy. Он принимает целевой объект, который должен быть проксирован, и объект-обработчик, который определяет необходимую настройку. Объект обработчика позволяет определять некоторые функции-ловушки, такие как get, set, has, apply и т. д., которые используются для добавления пользовательского поведения, связанного с их использованием. Reflect, с другой стороны, является встроенным объектом, который предоставляет аналогичные методы, которые поддерживаются объектом-обработчиком Proxy как статические методы самого себя. Это не конструктор; его статические методы используются для перехватываемых операций JavaScript.\n\nТеперь мы создаем функцию, которую можно рассматривать как сетевой запрос. Мы назвали его networkFetch. Он принимает URL-адрес и отвечает соответствующим образом. Мы хотим реализовать прокси, где мы получаем ответ из сети только в том случае, если он недоступен в нашем кеше. В противном случае мы просто возвращаем ответ из кеша.\n\nГлобальная переменная cache будет хранить наши кешированные ответы. Мы создаем прокси с именем proxiedNetworkFetch с нашим исходным networkFetch в качестве цели и используем метод применения в нашем объекте-обработчике для проксирования вызова функции. Метод применения передается самому целевому объекту. Это значение как thisArg и аргументы передаются ему в массивной структуре args.\n\nМы проверяем, находится ли переданный аргумент url в кеше. Если он существует в кеше, мы возвращаем ответ оттуда, никогда не вызывая исходную целевую функцию. Если это не так, то мы используем метод Reflect.apply для вызова целевой функции с thisArg (хотя в нашем случае это не имеет никакого значения) и переданными аргументами."
      ],
      "code": [
        "// Target\nfunction networkFetch(url) {\n  return `${url} - Response from network`;\n}\n\n// Proxy\n// ES6 Proxy API = new Proxy(target, handler);\nconst cache = [];\nconst proxiedNetworkFetch = new Proxy(networkFetch, {\n  apply(target, thisArg, args) {\n    const urlParam = args[0];\n    if (cache.includes(urlParam)) {\n      return `${urlParam} - Response from cache`;\n    } else {\n      cache.push(urlParam);\n      return Reflect.apply(target, thisArg, args);\n    }\n  },\n});\n\n// usage\nconsole.log(proxiedNetworkFetch('dogPic.jpg')); // 'dogPic.jpg - Response from network'\nconsole.log(proxiedNetworkFetch('dogPic.jpg')); // 'dogPic.jpg - Response from cache'"
      ]
    },
    "popularity": "4",
    "type": "question",
    "description": "Proxy Pattern"
  },
  {
    "id": "vWeVB2fEZoHFPT7Wxc2x",
    "competence": ["common questions"],
    "question": "Что такое LSP? (третья в SOLID)",
    "description": "LSP - Liskov substitution principle - Принцип подстановки Барбары Лисков",
    "popularity": "5",
    "answer": {
      "text": [
        "Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.\n\nЦель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается."
      ],
      "link": [
        "https://medium.com/webbdev/solid-4ffc018077da",
        "https://blog.logrocket.com/solid-principles-single-responsibility-in-javascript-frameworks/",
        "https://stackify.com/solid-design-liskov-substitution-principle/"
      ],
      "code": []
    },
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "vXBGoJn9ZWXGNFBl4eLt",
    "description": "web api",
    "type": "question",
    "tableIndex": 268,
    "competence": ["javascript", "frontend"],
    "_id": { "$oid": "60de0704e2c8c53194aee4d9" },
    "difficulty": "junior",
    "answer": {
      "text": [
        "Есть функции, которые реализованы не в движке v8, а в самом браузере или другой среде исполнения. Например settimeout ."
      ],
      "code": [],
      "link": []
    },
    "popularity": "3",
    "question": "Что такое web api?"
  },
  {
    "id": "vdkuyaxH5u3zRJTmmR4g",
    "competence": ["common questions", "javascript"],
    "difficulty": "middle",
    "description": "Template Pattern - Шаблон",
    "type": "question",
    "question": "Что такое Template Pattern в Javascript?",
    "answer": {
      "link": [
        "https://betterprogramming.pub/javascript-design-patterns-25f0faaaa15"
      ],
      "code": [
        "class Employee {\n  constructor(name, salary) {\n    this._name = name;\n    this._salary = salary;\n  }\n\n  work() {\n    return `${this._name} handles ${this.responsibilities() /* gap to be filled by subclass */}`;\n  }\n\n  getPaid() {\n    return `${this._name} got paid ${this._salary}`;\n  }\n}\n\nclass Developer extends Employee {\n  constructor(name, salary) {\n    super(name, salary);\n  }\n\n  // details handled by subclass\n  responsibilities() {\n    return 'application development';\n  }\n}\n\nclass Tester extends Employee {\n  constructor(name, salary) {\n    super(name, salary);\n  }\n\n  // details handled by subclass\n  responsibilities() {\n    return 'testing';\n  }\n}\n\n// usage\nconst dev = new Developer('Nathan', 100000);\nconsole.log(dev.getPaid()); // 'Nathan got paid 100000'\nconsole.log(dev.work()); // 'Nathan handles application development'\n\nconst tester = new Tester('Brian', 90000);\nconsole.log(tester.getPaid()); // 'Brian got paid 90000'\nconsole.log(tester.work()); // 'Brian handles testing'"
      ],
      "text": [
        "Это шаблон поведенческого проектирования, основанный на определении скелета алгоритма или реализации операции, но откладывающий некоторые шаги на подклассы. Он позволяет подклассам переопределять определенные шаги алгоритма без изменения внешней структуры алгоритма.\n\nВ этом примере у нас есть класс Template Employee, который частично реализует метод работы. Подклассы должны реализовать метод обязанностей, чтобы он работал как единое целое. Затем мы создаем два подкласса Developer и Tester, которые расширяют класс шаблона и реализуют необходимый метод, чтобы заполнить пробел в реализации."
      ]
    },
    "popularity": "4"
  },
  {
    "id": "vgRmreDNrx2CU0YK5oyh",
    "competence": ["javascript"],
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
      ],
      "text": [
        "Шаблонные строки помогают упростить строковую строк или включение переменных в строку.\n\nДо ES2015 писали так: \nvar person = { name: ‘Tyler’, age: 28 }; \nconsole.log(‘Hi, my name is ‘ + person.name + ‘ and I am ‘ + person.age + ‘years old!’); \n // ‘Hi, my name is Tyler and I am 28 years old!’ \n\nС приходом шаблонных строк в ES6 стало намного проще: \nconst person = { name: ‘Tyler’, age: 28 }; \nconsole.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);\n // ‘Hi, my name is Tyler and I am 28 years old!’ \n\nОбратите внимание, что для шаблонных строк используются обратные кавычки, а не простые. Переменные добавляются в подстановки ${}, обозначаемые знаком доллара и фигурными скобками.\n\nВторой пример использования заключается в создании многострочных литералов.\nДо ES2015 перенос осуществлялся следующим образом:\nconsole.log(‘This is line one.\\nThis is line two.’);\n // This is line one.\n // This is line two.\n\nИли же, чтобы не приходилось прокручивать длинную строку в текстовом редакторе, можно было разбить код на несколько строк в коде, таким образом:\nconsole.log(‘This is line one.\\n’ +\n‘This is line two.’); \n// This is line one.\n// This is line two.\n\nОднако шаблонные строки сохраняют любой интервал, который вы добавляете к ним. \nНапример, чтобы создать тот же многострочный литерал, который мы создали выше, вы можете просто написать: \nconsole.log(`This is line one.\nThis is line two.`);\n// This is line one.\n// This is line two.\n\nЕще одним вариантом использования шаблонных строк будет использование в качестве замены библиотек шаблонизации для интерполяции переменных:\nconst person = { name: ‘Tyler’, age: 28 }; \ndocument.body.innerHTML = ` \n<div>\n<p>Name: ${person.name}</p>\n<p>Name: ${person.age}</p>\n</div>\n` \nОбратите внимание, что ваш код может быть восприимчив к XSS при использовании .innerHTML. Очищайте ваши данные перед отображением, если они получены от пользователя!"
      ],
      "code": []
    },
    "_id": { "$oid": "60de0704e2c8c53194aee45e" },
    "type": "question",
    "question": "Приведите пример использования шаблонных строк.",
    "tableIndex": 270,
    "difficulty": "junior",
    "popularity": "3",
    "description": "Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?"
  },
  {
    "id": "w397bBevwzL3ISK59i2J",
    "competence": ["javascript"],
    "difficulty": "middle",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Главное на что здесь стоит обратить внимание, так это то, что foo на которую ссылается foo.x “устанавливается” перед тем как foo изменится. foo.x ссылается на старое значение foo.\n\nSee section 11.13.1 of the ES5 spec:\nLet lref be the result of evaluating LeftHandSideExpression.\nLet rref be the result of evaluating AssignmentExpression.\n\nЭто значит, что в старом foo появиться новое свойство x равное {n: 2} . А в новое foo запишется {n: 2}.\nЗначение старого foo находиться в bar:\n// bar \n{ n: 1, x: { n: 2 } }\n\nТак как при дальнейшем выводе foo.x наше foo ссылается на его новое значение, в котором отсутствует x , то соответственно foo.x будет не определенно — undefined.\n\nОтвет: undefined"
      ]
    },
    "_id": { "$oid": "60de0704e2c8c53194aee488" },
    "tableIndex": 271,
    "question": "Чему равно foo.x?",
    "description": "var foo = {n: 1};\nvar bar = foo;\nfoo.x = foo = {n: 2};\n\nЭтот вопрос задают в топ 3% компаний (Apple, Google, Facebook).",
    "type": "question",
    "popularity": "5"
  },
  {
    "id": "wI0QegcuFAkBUNDcUvfR",
    "popularity": "4",
    "question": "В каких случаях обычно используются анонимные функции?",
    "answer": {
      "text": [
        "Они могут использоваться в IIFE для инкапсуляции кода в локальную область видимости, чтобы объявленные в ней переменные не попадали в глобальную область видимости.\n\n(function() { \n// Здесь код функции. \n})();\n\nКак callback-функция, которая используется один раз и не должна использоваться где-либо еще. Код будет казаться более автономными читаемым, когда обработчики будут определены прямо внутри вызывающего их кода, а не искать в другом месте, чтобы найти тело функции.\n\nsetTimeout(function() {\n  console.log('Hello world!'); \n}, 1000);\n\nАргументы в конструкциях функционального программирования или Lodash (аналогично callback-функциям).\nconst arr = [1, 2, 3]; \nconst double = arr.map(function(el) { return el * 2; }); \nconsole.log(double); // [2, 4, 6]"
      ],
      "code": [],
      "link": [
        "https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions",
        "https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo"
      ]
    },
    "difficulty": "junior",
    "tableIndex": 272,
    "type": "question",
    "competence": ["typescript"],
    "_id": { "$oid": "60de0704e2c8c53194aee438" },
    "description": "анонимные функции"
  },
  {
    "id": "wpvVkIbBtQKNQINbPz3k",
    "competence": ["javascript"],
    "question": "Обратная польская нотация.",
    "_id": { "$oid": "60de0704e2c8c53194aee4a4" },
    "tableIndex": 273,
    "answer": {
      "text": [""],
      "link": [
        "https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C"
      ],
      "code": [
        "var notation = '23+1-', notation1 = '7 2 3 * -', notation2 = '1 2 + 4 * 3 +';\n \nfunction getComputation(notation) {\n  var queue = [], tmp, num1, num2;\n  for (var i = 0; i < notation.length; i++) {\n    if (/\\d+/.test(notation[i]) === true) {\n      queue.push(Number(notation[i]));\n    } else {\n      switch (notation[i]) {\n        case '+':\n          tmp = queue.pop() + queue.pop();\n          queue.push(tmp);\n        break;\n        case '-':\n          num1 = queue.pop();\n          num2 = queue.pop();\n          if (num1 > num2) {\n            tmp = num1 - num2;\n          } else {\n            tmp = num2 - num1;\n          }\n          queue.push(tmp);\n        break;\n        case '*':\n          tmp = queue.pop() * queue.pop();\n          queue.push(tmp);\n        break;\n        case '/':\n          tmp = queue.pop() / queue.pop();\n          queue.push(tmp);\n        break;\n      }\n    }\n  }\n  return queue[0];\n}\n\nconsole.log(getComputation(notation));\nconsole.log(getComputation(notation1));\nconsole.log(getComputation(notation2));\n "
      ]
    },
    "popularity": "5",
    "type": "exercise",
    "description": "префиксная нотация",
    "difficulty": "middle"
  },
  {
    "id": "wwhoJqpXfCXSrmXqLUjp",
    "description": "Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?",
    "difficulty": "junior",
    "popularity": "2",
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee44f" },
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload"
      ],
      "code": [],
      "text": [
        "Событие load происходит в конце процесса загрузки документа. На этом этапе все объекты в документе находятся в DOM, и все изображения, скрипты и ссылки загрузились.\n\nСобытие DOM DOMContentLoaded будет запущено после создания DOM для страницы, но не будет ждать окончания загрузки других ресурсов. Оно предпочтительно в тех случаях, когда вам не нужно загружать страницу целиком перед инициализацией."
      ]
    },
    "competence": ["javascript"],
    "tableIndex": 274,
    "question": "Для чего используют событие `load`? "
  },
  {
    "id": "wwx5q46Ig1RIxavtUs7H",
    "popularity": "2",
    "type": "question",
    "question": "В каком порядке делать изменение размера колонок?",
    "competence": ["javascript"],
    "answer": {
      "code": [],
      "text": ["mousedown -> mouseMove -> mouseup -> click"],
      "link": []
    },
    "difficulty": "junior",
    "description": "Типа как в экселе, когда хватаешь колонку и тащишь, а потом отпускаешь."
  },
  {
    "id": "x6YwGOelyu23zeiVfbhh",
    "question": "Какие инструменты и методы вы используете при отладке кода?",
    "tableIndex": 276,
    "answer": {
      "code": [],
      "link": [
        "https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d",
        "https://raygun.com/blog/javascript-debugging/"
      ],
      "text": [
        "React и Redux:\nReact Devtools\nRedux Devtools\n\nVue:\nVue Devtools\n\nJavaScript:\nChrome Devtools\nВыражение debugger\nОтладка при помощи старого доброго console.log"
      ]
    },
    "competence": ["javascript"],
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee454" },
    "popularity": "5",
    "difficulty": "middle",
    "description": "отладка кода"
  },
  {
    "id": "xSAArRdURVBeGSbdtTRV",
    "answer": { "code": [], "text": ["js быстрее"], "link": [] },
    "_id": { "$oid": "60de0704e2c8c53194aee466" },
    "competence": ["javascript"],
    "tableIndex": 277,
    "description": "анимация",
    "question": "Какие преимущества и недостатки у CSS и JavaScript анимации?",
    "difficulty": "junior",
    "type": "question",
    "popularity": "1"
  },
  {
    "id": "xm6T9aDRQ8uJDsMCuwzz",
    "type": "question",
    "description": "Что бы вы выбрали и почему?",
    "difficulty": "junior",
    "popularity": "1",
    "_id": { "$oid": "60de0704e2c8c53194aee472" },
    "tableIndex": 278,
    "question": "В чем разница между «сбросом» и «нормализацией» CSS? ",
    "competence": ["javascript"],
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Цели normalize.css: \nсохранять полезные настройки браузера, а не стирать их;\nнормализовать стили для широкого круга HTML-элементов;\nкорректироватьошибки и основные несоответствия браузера;\nсовершенствовать юзабилити незаметными улучшениями;\nобъяснять код, используякомментарии и детальную документацию."
      ]
    }
  },
  {
    "id": "xrGpWjDUr6cAPosnBgL4",
    "difficulty": "middle",
    "question": "В чем разница между standards mode и quirks mode?",
    "tableIndex": 279,
    "_id": { "$oid": "60de0704e2c8c53194aee4ca" },
    "competence": ["javascript"],
    "type": "question",
    "popularity": "1",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "На сегодняшний день существует три режима отображения, которые используются движками разметки (layout engines) браузеров: \n\nрежим совместимости (quirks mode), частично стандартный режим (almost standards mode) и стандартный режим (full standards mode).\n\nВ режиме совместимости (quirks mode), разметка эмулирует нестандартное поведение браузеров Navigator 4 и Internet Explorer 5.\n\nЭтот режим необходим для поддержки сайтов, созданных до начала широкого применения веб стандартов. В стандартном режиме (full standards mode) поведение браузера соответствует (будем надеяться) описанному в спецификациях HTML и CSS. В частично стандартном режиме (almost standards mode) реализовано лишь незначительное количество так называемых \"странностей\" (quirks)."
      ]
    },
    "description": "standards mode и quirks mode"
  },
  {
    "id": "xvK3GGbBMQAVwpkuhBvG",
    "question": "Что такое Injector?",
    "popularity": "5",
    "difficulty": "middle",
    "competence": ["typescript", "angular", "frontend"],
    "description": "Injector, @Injectable & @Inject",
    "answer": {
      "code": [],
      "link": [
        "https://www.tektutorialshub.com/angular/angular-injector-injectable-inject/",
        "https://www.tektutorialshub.com/angular/angular-dependency-injection/"
      ],
      "text": ["без ответа"]
    },
    "type": "question"
  },
  {
    "id": "yDtZGwF5hlBotdzVNMCi",
    "difficulty": "junior",
    "popularity": "1",
    "answer": {
      "link": ["https://developer.mozilla.org/ru/docs/Glossary/Falsy"],
      "text": [
        "Ложноподобное (falsy) значение — значение, которое становится false в булевом контексте.\nfalse\n0\n-0\n0n\n\"\", '', ``\nnull\nundefined\nNaN (en-US)\ndocument.all"
      ],
      "code": []
    },
    "type": "question",
    "description": "false, falsy",
    "competence": ["javascript"],
    "tableIndex": 281,
    "_id": { "$oid": "60de0704e2c8c53194aee50e" },
    "question": "Какие есть falsy значения?"
  },
  {
    "id": "yMSxGv2uOPnqhbGhzMQz",
    "answer": {
      "link": [
        "http://requirejs.org/docs/whyamd.html",
        "https://nodejs.org/docs/latest/api/modules.html",
        "http://2ality.com/2014/09/es6-modules-final.html"
      ],
      "code": [],
      "text": [
        "Это зависит от среды выполнения JavaScript. На клиенте (в среде браузера), пока переменные/функции объявлены в глобальной области видимости (window), все скрипты могут на них ссылаться. В качестве альтернативы, используйте Asynchronous Module Definition (AMD) через RequireJS для модульного подхода. На сервере (Node.js) обычно используется CommonJS. Каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту module.exports. ES2015 позволяет использовать модульный синтаксис, который призван заменить как AMD, так и CommonJS. В конечном итоге он будет поддерживаться как в браузере, так и в Node."
      ]
    },
    "competence": ["javascript"],
    "type": "question",
    "popularity": "1",
    "_id": { "$oid": "60de0704e2c8c53194aee461" },
    "description": "обмен кодом",
    "tableIndex": 282,
    "difficulty": "junior",
    "question": "Каким образом можно обмениваться кодом между файлами?"
  },
  {
    "id": "yZSuh13seqyyTn4kMCFw",
    "competence": ["javascript"],
    "_id": { "$oid": "60de0704e2c8c53194aee483" },
    "answer": {
      "code": [
        "function f(a, b) {\n  if (b !== undefined) {\n    return a + b;\n  } else {\n    return function (b) {\n      return a + b;\n    };\n  }\n}\n\n// f(1)(2)(3)() -> 6, f(0)(3)(1)(5)() ->; 8\nfunction f(arg) {\n  var value = arg;\n  return function (arg) {\n    if (arg !== undefined) {\n      return f(value + arg);\n    } else {\n      return value;\n    }\n  };\n}\n\n// foo(1)(2)(3) -> 6\nfunction foo(value) {\n  var acc = value;\n  function addNext(next) {\n    acc += next;\n    return addNext;\n  }\n  addNext.toString = addNext.valueOf = function () {\n    return acc;\n  };\n  return addNext;\n}"
      ],
      "text": ["Смотреть каррирование"],
      "link": []
    },
    "type": "question",
    "description": "add(2,5); // 7\nadd(2)(5); // 7\n ",
    "tableIndex": 283,
    "difficulty": "junior",
    "question": "Как сделать, чтобы это выражение работало?",
    "popularity": "1"
  },
  {
    "id": "zAS6bg5r1ZXX9JRNYQnx",
    "_id": { "$oid": "60de0704e2c8c53194aee4cf" },
    "competence": ["javascript"],
    "difficulty": "middle",
    "popularity": "3",
    "tableIndex": 284,
    "type": "question",
    "answer": {
      "text": [],
      "code": [
        "function makeArmy() {\n  let shooters = [];\n  for(let i = 0; i  < 10; i++) {\n    let shooter = function() { // функция shooter \n      alert( i ); // должна выводить порядковый номер\n    };\n    shooters.push(shooter);\n  }\n  return shooters;\n}\n\n let army = makeArmy();"
      ],
      "link": ["https://learn.javascript.ru/task/make-army"]
    },
    "description": "Типикал задача, по ссылке",
    "question": "Сделайте армию функций."
  },
  {
    "id": "zLWnQ9XVxPgrtofXOiB4",
    "answer": {
      "code": [],
      "text": [
        "Разницу между Expires, Date, Age и If-Modified-… \n\nExpires: Tue, 31 Jan 2012 15:02:53 GMT \nДата предполагаемого истечения срока актуальности сущности. \n\nDate: Tue, 15 Nov 1994 08:12:31 GMT \nДата генерации отклика. \n\nIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT \nДата. Выполнять метод если сущность изменилась с указанного момента. \n\nDo Not Track \nПри включении этой опции браузеры будут посылать в http-заголовках запрос\n“Do Not Track” для того, чтобы ваши действия не отслеживались сайтом и\nтретьими сторонами на нем (например, аналитическими и рекламными системами).\n\nCache-Control \nОбщий заголовок Cache-Control используется для задания инструкций\nкэширования как для запросов, так и для ответов. Инструкции кэширования\nоднонаправленные: заданная инструкция в запросе не подразумевает, что такая\nже инструкция будет указана в ответе \n\nTransfer-Encoding \nмеханизм передачи данных в протоколе передачи гипертекста (HTTP),\nпозволяющий надёжно доставлять данные от сервера клиенту (чаще всего\nклиентскому web-браузеру) без необходимости заранее знать точный размер всего\nтела HTTP-сообщения. Это достигается разбиением сообщения на небольшие части\n(chunks), а затем передачей каждой части с указанием только её размера (в\nшестнадцатеричном виде). Окончание передачи сообщения определяется наличием\nпоследней части с нулевой длиной. \n\nEtag (или entity tag) — один из механизмов кэширования в HTTP. По сути это\nидентификатор, который присваивается файлу сервером для последующей проверки.\nКогда клиент запрашивает файлы веб-страницы (картинки, CSS и т.д), сервер\nпередает все данные вместе с тэгами Etag в виде: ETag:\n\"6d82cbb050ddc7fa9cbb659014546e59\"\nФайлы сохраняются в кэше на стороне клиента, и когда браузер запрашивает\nэти файлы снова, то к запросу добавляется строка If-None-Match:\nIf-None-Match: \"6d82cbb050ddc7fa9cbb659014546e59\"\n\nСервер, в свою очередь, проверяет Etag, если он совпадает, то в ответ\nсервер отправляет код 304:HTTP/1.1 304 Not Modified Иначе требуемые файлы\nбудут заново отправлены. \n\nX-Frame-Options \nЗаголовок X-Frame-Options со стороны сервера может разрешать или запрещать\nотображение страницы внутри фрейма. \nЭто должен быть именно HTTP-заголовок: браузер проигнорирует его, если\nнайдёт в HTML-теге &lt;meta&gt;. Поэтому при &lt;meta\nhttp-equiv=\"X-Frame-Options\"...&gt; ничего не произойдёт. \nЗаголовок может иметь 3 значения: \nDENY \nНикогда не показывать страницу внутри фрейма. \nSAMEORIGIN \nРазрешить открытие страницы внутри фрейма только в том случае, если\nродительский документ имеет тот же источник. \nALLOW-FROM domain \nРазрешить открытие страницы внутри фрейма только в том случае, если\nродительский документ находится на указанном в заголовке домене."
      ],
      "link": []
    },
    "type": "question",
    "_id": { "$oid": "60de0704e2c8c53194aee47f" },
    "tableIndex": 285,
    "popularity": "2",
    "difficulty": "junior",
    "question": "Опишите следующие заголовки HTTP-запросов и ответов.",
    "competence": ["javascript"],
    "description": "HTTP запросы"
  },
  {
    "id": "zPyUWR6P5vjeh5wMcbow",
    "competence": ["javascript"],
    "answer": {
      "text": [
        "Поскольку, мы работаем с числами, надо расширить прототип Number новыми методами.\n\nNumber.prototype.plus = function (value) {\n return this + value;\n}\n\nNumber.prototype.minus = function (value) {\n return this - value;\n}"
      ],
      "code": [],
      "link": []
    },
    "tableIndex": 286,
    "_id": { "$oid": "60de0704e2c8c53194aee48a" },
    "difficulty": "middle",
    "question": "Реализовать методы, которые в процессе выполнения строки (2).plus(3).minus(1) дали бы на выходе 4.",
    "popularity": "5",
    "type": "exercise",
    "description": "(2).plus(3).minus(1)"
  },
  {
    "id": "zd23GzS3vLbxaEku2OEt",
    "difficulty": "middle",
    "answer": { "text": ["server side rendering"], "link": [], "code": [] },
    "question": "Что такое SSR?",
    "description": "Не СССР, а SSR",
    "competence": ["javascript", "angular"],
    "type": "question",
    "popularity": "3"
  }
]
