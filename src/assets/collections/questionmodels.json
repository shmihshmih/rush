[
  {
    "id": "0G51IYLNXpl9CdfaxZna",
    "_id": {
      "$oid": "60de0704e2c8c53194aee43c"
    },
    "description": "Поясните пожалуйста в чем разница? Еще раз, для самых умненьких",
    "popularity": "4",
    "answer": {
      "text": [
        "Сходство\n заключается в том, что и .call, и .apply используются для вызова функций, а\n также первый параметр будет использоваться как значение this внутри функции.\n А разница в том, что .call в качестве следующих аргументов принимает\n аргументы, разделенные запятыми, в то время как .apply в качестве следующих\n аргументов принимает массив аргументов. <br>\n function add(a, b) { <br>\n return a + b; <br>\n } <br>\n console.log(add.call(null, 1, 2)); // 3 <br>\n console.log(add.apply(null, [1, 2])); // 3"
      ],
      "link": [],
      "code": []
    },
    "type": "question",
    "difficulty": "junior",
    "question": "В\n чем разница между `.call` и `.apply`?",
    "competence": [
      "typescript"
    ],
    "tableIndex": 1
  },
  {
    "id": "0YISGPZECpl3gH48EaYY",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "С\n появлением Rest parameters реализация этой задачи стала чуть проще, чем\n прежде, когда приходилось делать arguments.slice. <br>\n Решение <br>\n Function.prototype.bind = function(context, ...argsBind) { <br>\n const fn = this; <br>\n <br>\n return function (...args) { <br>\n return fn.apply(context, argsBind.concat(args)) <br>\n }; <br>\n }; <br>\n "
      ],
      "code": []
    },
    "difficulty": "junior",
    "type": "question",
    "question": "Задача:\n Реализовать аналог Function.prototype.bind.",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b3"
    }
  },
  {
    "id": "0ZmSAz5b4GyZS80JvEsR",
    "difficulty": "junior",
    "popularity": "3",
    "description": "Что такое hmr?",
    "question": "Что такое hmr?",
    "answer": {
      "text": [
        "hot module replacement (настройка в вебпаке в dev-server чтобы стенд обновлялся после изменения файла)"
      ],
      "code": [],
      "link": []
    },
    "type": "question",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "0kJkRLexcPymiOnYMXyK",
    "description": "Расскажите про мемоизацию",
    "tableIndex": 3,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d3"
    },
    "competence": [
      "common questions"
    ],
    "popularity": "3",
    "difficulty": "junior",
    "type": "question",
    "question": "Мемоизация",
    "answer": {
      "link": [],
      "text": [
        "Сохранение\n результата функций при определенных аргументах, что позволяет не выполнять\n функцию снова, если эти аргументы использованы. <br>\n // простая функция, прибавляющая 10 к переданному ей числу <br>\n const add = (n) =&gt; (n + 10); <br>\n add(9); <br>\n // аналогичная функция с мемоизацией <br>\n const memoizedAdd = () =&gt; { <br>\n let cache = {}; <br>\n return (n) =&gt; { <br>\n if (n in cache) { <br>\n console.log('Fetching from cache'); <br>\n return cache[n]; <br>\n } <br>\n else { <br>\n console.log('Calculating result'); <br>\n let result = n + 10; <br>\n cache[n] = result; <br>\n return result; <br>\n } <br>\n } <br>\n } <br>\n // эту функцию возвратит memoizedAdd <br>\n const newAdd = memoizedAdd(); <br>\n console.log(newAdd(9)); // вычислено <br>\n console.log(newAdd(9)); // взято из кэша <br>\n "
      ],
      "code": [
        "console.log(aaaa)"
      ]
    }
  },
  {
    "id": "1OgxKEHGIf66C5sbhHzQ",
    "question": "event\n loop",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d6"
    },
    "difficulty": null,
    "type": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "competence": [],
    "description": ""
  },
  {
    "id": "26dIqjffpn2el90iZGeG",
    "answer": {
      "link": [
        "http://callbackhell.com/",
        "https://www.geeksforgeeks.org/what-is-callback-hell-in-node-js/"
      ],
      "text": [
        "Цепочка call back функций с большой вложенностью. Из-за большой вложенности ничего не понятно. Происходит большая путаница. Трудно читается. Легко допустить ошибки. Легко пропустить скобки."
      ],
      "code": [
        "fs.readdir(source, function (err, files) {\n  if (err) {\n    console.log('Error finding files: ' + err)\n  } else {\n    files.forEach(function (filename, fileIndex) {\n      console.log(filename)\n      gm(source + filename).size(function (err, values) {\n        if (err) {\n          console.log('Error identifying file size: ' + err)\n        } else {\n          console.log(filename + ' : ' + values)\n          aspect = (values.width / values.height)\n          widths.forEach(function (width, widthIndex) {\n            height = Math.round(width / aspect)\n            console.log('resizing ' + filename + 'to ' + height + 'x' + height)\n            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {\n              if (err) console.log('Error writing file: ' + err)\n            })\n          }.bind(this))\n        }\n      })\n    })\n  }\n})"
      ]
    },
    "difficulty": "beginner",
    "popularity": "4",
    "tableIndex": 5,
    "competence": [
      "common questions",
      "javascript"
    ],
    "description": "Объясните с примером callback hell.",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f4"
    },
    "question": "Что такое callback hell?"
  },
  {
    "id": "2D6JNpeGnXuCLBZ0oqkN",
    "question": "Как пример в строке \"=1+3\" посчитать в js?",
    "description": "Или Венгерская нотация может быть использльзована",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "eval(\"\")"
      ]
    },
    "difficulty": "middle",
    "popularity": "3",
    "type": "question",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "2nXq0sD1XsmCTgAJD8Sw",
    "answer": {
      "code": [],
      "link": [
        "https://codeburst.io/javascript-map-vs-foreach-f38111822c0f"
      ],
      "text": [
        "Чтобы\n понять разницу между ними, давайте посмотрим, что делает каждая функция.\n <br>\n forEach <br>\n Перебирает элементы в массиве. <br>\n Вызывает callback-функцию для каждого элемента. <br>\n Не возвращает значение. <br>\n const a = [1, 2, 3]; <br>\n const doubled = a.forEach((num, index) =&gt; { <br>\n // Делаем что-либо с num и/или index. <br>\n }); <br>\n // doubled = undefined <br>\n map <br>\n Перебирает элементы в массиве. <br>\n “Сопоставляет” каждый элемент с новым элементом, вызывая функцию для\n каждого элемента, создавая в результате новый массив. <br>\n const a = [1, 2, 3]; <br>\n const doubled = a.map(num =&gt; { <br>\n return num * 2; <br>\n }); <br>\n // doubled = [2, 4, 6] <br>\n Основное различие между .forEach и .map() состоит в том, что .map()\n возвращает новый массив. Если вам нужен результат, но вы не хотите изменять\n исходный массив, .map() — очевидный выбор. Если вам просто нужно перебрать\n массив, то стоит воспользоваться forEach."
      ]
    },
    "competence": [
      "typescript"
    ],
    "description": "",
    "popularity": "4",
    "difficulty": "junior",
    "question": "Можете\n ли вы описать основное различие между циклом `.forEach` и циклом `.map()`? И\n в каких случаях каждый из них используется?",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee437"
    }
  },
  {
    "id": "3IxNLdHeb6UIU9WAduaL",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c0"
    },
    "answer": {
      "code": [],
      "text": [
        "Перевести\n в строку, разбить на кусочки и отправить разными запросами. <br>\n P.S.: Вопрос из разряда тех, на которые нет правильного ответа, потому как\n единственно верным ответом на этот вопрос был бы — не делайте так, не\n отправляйте файлы методом GET, даже не думайте об этом и всё будет хорошо.\n <br>\n И это не тот случай когда хочется услышать размышления, а дойдёт ли\n собеседуемый до ожидаемого ответа или нет уже не так важно. Потому как в этом\n случае можно было бы поставить задачу иначе — указать некоторые\n дополнительные требования к загрузке файлов: например, чт файлы могут быть\n неприлично большого размера и необходимо реализовать загрузку с возможностью\n догрузки, если в каком-то временном промежутке у клиента будут проблемы с\n сетью. Я имею ввиду, что если хочется услышать про возможность нарезки файлов\n на клиенте, то можно придумать условия и поадекватнее. <br>\n "
      ],
      "link": []
    },
    "description": "",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "question": "Вопрос:\n Как передать изображение размером 10Mb с помощью GET-запроса?",
    "popularity": null
  },
  {
    "id": "450L8AKAJrk12yZFfqAF",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee446"
    },
    "type": "question",
    "popularity": null,
    "question": "Почему\n не следует расширять нативные JavaScript-объекты?",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "answer": {
      "code": [],
      "text": [
        "Расширение\n встроенного/нативног объекта JavaScript означает добавление свойств/функций к\n его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на\n практике это опасно. Представьте, что ваш код использует несколько библиотек,\n которые расширяют Array.prototype, добавляя один и тот же метод contains. В\n результате код будет работать неверно, если поведение этих двух методов не\n будет одинаковым. <br>\n Единственный случай, при котором можно расширить нативный объект — это при\n создании полифила, создав собственную реализацию метода, который является\n частью спецификации JavaScript, но может отсутствовать в устаревших\n браузерах. <br>\n "
      ],
      "link": [
        "http://lucybain.com/blog/2014/js-extending-built-in-objects/"
      ]
    }
  },
  {
    "id": "4FdWtQ6wA4OtGd9g8mBY",
    "_id": {
      "$oid": "60de0704e2c8c53194aee442"
    },
    "type": "question",
    "question": "Объясните,\n как работает JSONP (и почему это не совсем AJAX)",
    "answer": {
      "code": [],
      "link": [
        "https://stackoverflow.com/a/2067584/1751946"
      ],
      "text": [
        "JSONP\n (JSON с набивкой) - это способ, часто используемый для обхода политики\n ограничения домена в браузерах, потому что Ajax-запросы с текущей страницы к\n серверу, находящемуся в другом домене, запрещены. <br>\n JSONP работает, отправляя запрос к серверу в другом домене через тег\n &lt;script&gt; и обычно с параметром запроса callback,\n например:https://example.com?callback=printData. Затем сервер обернет данные\n внутри функции с именем printData и вернет их клиенту. <br>\n HTML: <br>\n &lt;!-- https://mydomain.com --&gt; <br>\n &lt;script&gt; <br>\n function printData(data) { <br>\n console.log(`My name is ${data.name}!`); <br>\n } <br>\n &lt;/script&gt; <br>\n &lt;script\n src=\"https://example.com?callback=printData\"&gt;&lt;/script&gt; <br>\n JS: <br>\n // Файл загружен с https://example.com?callback=printData <br>\n printData({ name: 'Yang Shun' }); <br>\n У клиента должна быть функция printData в своей глобальной области\n видимости, и эта функция будет выполнена клиентом, когда будет получен ответ\n с сервера из другого домена. <br>\n JSONP может быть небезопасным и иметь повышенный риск. Поскольку JSONP -\n это действительно JavaScript, и он может делать все остальное, что может\n делать JavaScript, то вы должны быть уверены в надежности поставщика данных\n JSONP. <br>\n В наши дни, CORS является рекомендуемым подходом и JSONP является способом\n для его обхода."
      ]
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "description": "",
    "popularity": null
  },
  {
    "id": "4PD6pLbHFQzTNP89ylKZ",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Связано\n с системой представления десятичных чисел, не точностью их вычисления."
      ]
    },
    "description": "",
    "question": "Почему\n 0.1 + 0.2 даст 0.30000000000000004",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4af"
    }
  },
  {
    "id": "4Vvrc75pdRaXOfM3qwDe",
    "question": "Использовали\n ли вы систему сеток, и если да, то какую вы предпочитаете?",
    "popularity": null,
    "answer": {
      "text": [
        "bootstrap\n <br>\n materialise <br>\n "
      ],
      "code": [],
      "link": []
    },
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee474"
    },
    "type": "question",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "4Wl1ITsUNvIQ776SWCCg",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "type": "exercise",
    "popularity": null,
    "question": "Напишите\n цикл, который перебирает числа до 100, возвращая ”fizz” на числа кратные 3,\n ”buzz” на числа кратные 5 и ”fizzbuzz” на числа кратные 3 и 5.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee44d"
    },
    "answer": {
      "code": [],
      "text": [
        "Взгляните\n на версию FizzBuzz от Paul Irish: <br>\n for (let i = 1; i &lt;= 100; i++) { <br>\n let f = i % 3 == 0, <br>\n b = i % 5 == 0; <br>\n console.log(f ? (b ? 'FizzBuzz' : 'Fizz') : b ? 'Buzz' : i); <br>\n } <br>\n Хотя я бы не советовал вам использовать этот код во время интервью. Просто\n придерживайтесь длинного, но ясного подхода. Также можете взглянуть на разные\n безумные реализации FizzBuzz, по ссылке ниже."
      ],
      "link": [
        "https://gist.github.com/jaysonrowe/1592432"
      ]
    },
    "description": ""
  },
  {
    "id": "4hNKIIPjdw7vwTjgtVPD",
    "question": "FizzBuzz",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "const\n fizzBuzz = num =&gt; { <br>\n for(let i = 1; i &lt;= num; i++) { <br>\n // Проверяем, кратно ли число 3 и 5 <br>\n if(i % 3 === 0 &amp;&amp; i % 5 === 0) { <br>\n console.log('fizzbuzz') <br>\n } // Проверяем, кратно ли число 3 <br>\n else if(i % 3 === 0) { <br>\n console.log('fizz') <br>\n } // Проверяем, кратно ли число 5 <br>\n else if(i % 5 === 0) { <br>\n console.log('buzz') <br>\n } else { <br>\n console.log(i) <br>\n } <br>\n } <br>\n } <br>\n "
      ]
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c3"
    },
    "type": "question",
    "popularity": null,
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "description": ""
  },
  {
    "id": "4tuktcCNvSCz9eZINcD1",
    "question": "export\\import\n &amp;&amp; modules",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f5"
    },
    "difficulty": null,
    "type": null,
    "popularity": null,
    "description": ""
  },
  {
    "id": "4xe8bWsXe4vHZTNf3rH7",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "text": [
        "а)\n callback <br>\n б) method <br>\n в) undefined +++++++++++++++ <br>\n г) function <br>\n "
      ],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ad"
    },
    "question": "Что\n вернёт этот код — typeof (function(){})()",
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "popularity": null
  },
  {
    "id": "5AOcQZPlEAd12aMNiotx",
    "answer": {
      "code": [],
      "text": [
        "function\n Book() { <br>\n this.name = 'foo' <br>\n } <br>\n Book.prototype = { <br>\n getName: function() { <br>\n return this.name; <br>\n } <br>\n }; <br>\n var book = new Book(); <br>\n Book.prototype.getUpperName = function() { <br>\n return this.getName().toUpperCase(); <br>\n } <br>\n book.getUpperName(); <br>\n "
      ],
      "link": []
    },
    "type": "question",
    "question": "Что\n вернет метод?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ab"
    },
    "popularity": null,
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "description": ""
  },
  {
    "id": "5PppPjwbXFejbByH5en6",
    "popularity": null,
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c6"
    },
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "const\n fibonacci = num =&gt; { <br>\n // Сохраняем последовательность Фибоначчи, которую собираемся\n сгенерировать, <br>\n // внутри массива и инициализируем массив первыми двумя числами\n последовательности <br>\n const result = [0, 1] <br>\n for(let i = 2; i &lt;= num; i++) { <br>\n // Поместим сумму двух чисел, предшествующих позиции i в массиве\n результатов, <br>\n // в конец этого массива <br>\n const prevNum1 = result[i - 1] <br>\n const prevNum2 = result[i - 2] <br>\n result.push(prevNum1 + prevNum2) <br>\n } <br>\n // Вернём последнее значение из массива результатов <br>\n return result[num] <br>\n } <br>\n "
      ]
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "type": "question",
    "question": "Фибоначчи"
  },
  {
    "id": "5TjZyKwUCLHtlIFX2WIZ",
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "type": null,
    "competence": [],
    "popularity": null,
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e9"
    },
    "question": "prototypal\n inheritance",
    "description": ""
  },
  {
    "id": "5VWTkAUucBXDIwuFN8Y5",
    "answer": {
      "text": [
        "Преимущества\n <br>\n Помогает избежать “callback hell”, который может быть нечитаемым. <br>\n Упрощает написание последовательного удобочитаемого асинхронного кода с\n помощью .then(). <br>\n Упрощает написание параллельного асинхронного кода с помощью Promise.all().\n <br>\n С использованием промисов можно избежать следующих проблем, которые\n возникают при использовании callback-функций: <br>\n Колбэк-функция была вызвана слишком рано <br>\n Колбэк-функция была вызвана слишком поздно (или вовсе не была вызвана)\n <br>\n Колбэк-функция была вызвана слишком мало или слишком много раз <br>\n Не удалось передать необходимую среду/параметры <br>\n Были пропущены ошибки/исключения <br>\n Недостатки <br>\n Чуть более сложный код (спорно). <br>\n В старых браузерах, где не поддерживается ES2015, вам нужно загрузить\n полифил, чтобы их использовать. <br>\n "
      ],
      "code": [],
      "link": [
        "https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md"
      ]
    },
    "question": "Какие\n преимущества и недостатки при использовании промисов вместо колбэков\n (callbacks)?",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee452"
    },
    "description": "",
    "difficulty": "junior",
    "popularity": null,
    "type": "question"
  },
  {
    "id": "5dIQ4hJ4aLF0i5QsqD8n",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee46b"
    },
    "description": "",
    "question": "Представьте\n HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?",
    "competence": [
      "javascript"
    ],
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "popularity": null,
    "difficulty": "junior"
  },
  {
    "id": "5xU37j8zty9RKSTIFJVu",
    "difficulty": "junior",
    "type": "question",
    "competence": [
      "javascript",
      "html",
      "css"
    ],
    "popularity": "3",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Оптимизация поиска элементов на странице с определенным селектором: искать только в нужном родителе, сохранить результаты в переменную и уже оттуда делать операции "
      ]
    },
    "description": "Много элементов на странице и надо их находить, менять у них стили и т.д.",
    "question": "Как оптимизировать работу с элементами одного класса на странице?"
  },
  {
    "id": "639jcaBHDM2WeUkFqwQj",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a7"
    },
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "$('#root').on('click',\n function (event) { <br>\n event.stopPropogation(); <br>\n console.log($(event.target).attr('id')); <br>\n }) <br>\n "
      ]
    },
    "question": "Напишите\n код, который при клике на любой div внутри root будет выводить в консоль его\n id.",
    "difficulty": "junior"
  },
  {
    "id": "67VGkkUzSZuuASKU4mho",
    "popularity": null,
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "answer": {
      "text": [
        "Стилевые\n свойства применятся ко всем элементам с текстом, если у тегов не указаны\n стилевые правила. К примеру у ссылок указан цвет текста по умолчанию и он\n более приоритетный, чем определенный нами в body. Дело в том, что для многих\n свойств по умолчанию стоит значение inherit, то есть как у родителя.\n Получается поднимается вверх, пока не дойдет до body. <br>\n Для свойства border-radius, наоборот, применяется только к тегу, у которого\n мы хотим что бы били скругленные углы. <br>\n "
      ],
      "link": [],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee48e"
    },
    "question": "Как\n применяются скругленные углы для элементов и стили для текста(шрифт, тип\n шрифта, цветащте и тд)?",
    "type": "question",
    "description": ""
  },
  {
    "id": "68dIkZQKfBkF0dcPAngy",
    "difficulty": "junior",
    "question": "Как\n вы организуете свой код? (module pattern, classical inheritance)",
    "_id": {
      "$oid": "60de0704e2c8c53194aee439"
    },
    "description": "",
    "type": "question",
    "answer": {
      "link": [
        "https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4"
      ],
      "text": [
        "В\n прошлом я использовал Backbone, который поощряет ООП подход, создавая\n Backbone модели и добавляя к ним методы. <br>\n Модульный паттерн до сих пор хорош, но в настоящее время я использую\n React/Redux, который использует однонаправленный поток данных на основе\n архитектуры Flux. Я создаю модели своего приложения при помощи простых\n объектов и пишу чистые функции для управления этими объектами. Состояние\n управляется при помощью экшенов и редьюсеров, как в любом другом приложении\n Redux. <br>\n Я избегаю использования наследования классов, где это возможно. Если же мне\n это необходимо сделать, то я придерживаюсь этих правил."
      ],
      "code": []
    },
    "popularity": "4",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "6PiGetlij5Lp57xY7U0t",
    "answer": {
      "link": [
        "https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables",
        "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined"
      ],
      "code": [],
      "text": [
        "Необъявленные\n переменные создаются, когда вы присваиваете значение идентификатору, который\n не был ранее создан при помощи var, let или const. Необъявленные переменные\n будут определены глобально, вне текущей области видимости. В строгом режиме,\n будет ошибка ReferenceError, когда вы попытаетесь назначить значение\n необъявленной переменной. Необъявленные переменные плохи так же, как и\n глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их\n наличие, оберните код в блок try/catch.<br>\n <br>\n function foo() { <br>\n x = 1; // ReferenceError в строгом режиме <br>\n } <br>\n foo(); <br>\n console.log(x); // 1 <br>\n <br>\n Переменная undefined — это переменная, которая была объявлена, но ей не\n было присвоено значение. Ее тип undefined. Если переменной присвоить функцию,\n которая не возвращает никакого значения, то переменная также будет иметь\n значение undefined. Чтобы проверить это, сравните, используя оператор\n строгого равенства (===) или typeof, который вернет строку undefined. Обратите\n внимание, что вам не следует использовать оператор абстрактного сравнения для\n проверки, так как он также вернет true, если значение равно null.<br>\n <br>\n var foo; <br>\n console.log(foo); // undefined <br>\n console.log(foo === undefined); // true <br>\n console.log(typeof foo === ‘undefined’); // true <br>\n console.log(foo == null); // true. Неправильно, не используйте это для\n проверки! <br>\n function bar() {} <br>\n var baz = bar(); <br>\n console.log(baz); // undefined <br>\n <br>\n Переменной со значением null было явно присвоено значение null. Она\n отличается от undefined тем, что она была назначена явно. Чтобы проверить на\n null, просто сравните, используя оператор строгого равенства. Обратите\n внимание, что, как и выше, вы не должны использовать оператор абстрактного\n равенства (==) для проверки, так как он также вернет true, если значение\n равно undefined.<br>\n <br>\n var foo = null; <br>\n console.log(foo === null); // true <br>\n console.log(typeof foo === ‘object’); // true <br>\n console.log(foo == undefined); // true. Неправильно, не используйте это для\n проверки! <br>\n <br>\n Личная привычка — я никогда не оставляю свои переменные необъявленными или\n неприсвоенными. Я явно назначаю им null после объявления, если я не собираюсь\n их пока использовать. Если вы используете линтер в своем рабочем процессе, он\n обычно также проверяет, что вы не ссылаетесь на необъявленные\n переменные.<br>\n <br>\n Как бы вы проверили их на каждое из этих значений? <br>\n if( typeof foo !== 'undefined' ) { <br>\n // foo could get resolved and it's defined <br>\n }"
      ]
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "question": "В\n чем различие между переменными, значение которых: `null`, `undefined` и не\n объявлено? Как бы вы проверили их на каждое из этих значений?",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee435"
    },
    "popularity": "5",
    "description": ""
  },
  {
    "id": "6Stnf9vOASI6T3ZbKKCl",
    "competence": [
      "javascript",
      "html",
      "css",
      "frontend"
    ],
    "popularity": "3",
    "difficulty": "senior",
    "answer": {
      "text": [
        "Использовался для роутинга в самодельном фреймворке"
      ],
      "code": [],
      "link": []
    },
    "type": "question",
    "question": "Что такое hashChange в обьекте window?",
    "description": "Поподробнее с этим"
  },
  {
    "id": "6T5rXmyH7cIETNMG6K2w",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "popularity": null,
    "competence": [],
    "type": null,
    "description": "",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4dd"
    },
    "question": "local\n scope"
  },
  {
    "id": "6hGw3TZAfg9pmHuz63IO",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "difficulty": "junior",
    "description": "",
    "answer": {
      "link": [
        "http://2ality.com/2011/10/strict-mode-hatred.html",
        "http://lucybain.com/blog/2014/js-use-strict/"
      ],
      "text": [
        "‘use\n strict’ это директива, используемая для включения строгого режима во всем\n скрипте или отдельных функциях. <br>\n Преимущества: <br>\n Не позволяет случайно создавать глобальные переменные. <br>\n Любое присваивание, которое в обычном режиме завершается неудачей, в\n строгом режиме выдаст исключение. <br>\n При попытке удалить неудаляемые свойства, выдаст исключение (в то время как\n в нестрогом режиме никакого действия бы не произошло). <br>\n Требует, чтобы имена параметров функции были уникальными. <br>\n this в глобальной области видимости равно undefined. <br>\n Перехватывает распространенные ошибки, выдавая исключения. <br>\n Исключает неочевидные особенности языка. <br>\n Недостатки: <br>\n Нельзя использовать некоторые особенности языка, к которым привыкли\n некоторые разработчики. <br>\n Нет доступа к function.caller и function.arguments. <br>\n Объединение скриптов, написанных в строгом режиме может вызвать проблемы.\n <br>\n В целом, я думаю, что преимущества перевешивают недостатки, и мне никогда\n не приходилось полагаться на функции, которые заблокированы в строгом режиме.\n Я бы порекомендовал использовать строгий режим."
      ],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee44c"
    },
    "question": "Что\n делает строчка “use strict”;? Какие достоинства и недостатки от ее\n использования?"
  },
  {
    "id": "6hoGUAqbX3mtcXPktX3k",
    "answer": {
      "code": [],
      "link": [
        "https://makedev.org/principles/solid/srp.html"
      ],
      "text": [
        "Что такое SRP"
      ]
    },
    "description": "Что такое SRP",
    "type": "question",
    "tableIndex": 27,
    "competence": [
      "common questions"
    ],
    "question": "Что такое SRP",
    "popularity": "5",
    "difficulty": "junior"
  },
  {
    "id": "6jm6U4YZ747PmowbdMcN",
    "description": "",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [
        "https://github.com/grab/front-end-guide#single-page-apps-spas",
        "http://stackoverflow.com/questions/21862054/single-page-app-adva<span style=\"display:none\">ntages-and-disadvantages</span>",
        "http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/",
        "https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52"
      ],
      "text": [
        "Текст\n ниже взят из замечательного руководства по фронтенду от Grab, который по\n счастливой случайности тоже был написан мной. <br>\n В наши дни веб-разработчики называют свои продукты веб-приложениями, а не\n веб-сайтами. Хотя между этими двумя терминами нет строгой разницы,\n веб-приложения, как правило, очень интерактивны и динамичны, что позволяет\n пользователю выполнять действия и получать мгновенный ответ. Традиционно\n браузер получает HTML с сервера и отображает его. Когда пользователь\n переходит на другой URL-адрес, требуется полное обновление страницы, и сервер\n отправляет свежий HTML-код на новую страницу. Это называется рендерингом на\n стороне сервера. <br>\n Однако в современных SPA вместо этого используется рендеринг на стороне\n клиента. Браузер загружает начальную страницу с сервера вместе со скриптами\n (фреймворками, библиотеками, кодом приложения) и таблицами стилей,\n необходимыми для всего приложения. Когда пользователь переходит на другие\n страницы, обновление страницы не происходит. URL-адрес страницы обновляется\n при помощи HTML5 History API. Новые данные, необходимые для страницы (обычно\n в формате JSON), извлекаются браузером посредством запросов AJAX к серверу.\n Затем SPA динамически обновляет страницу данными через JavaScript, которые\n были получены при начальной загрузке страницы. Эта модель похожа на работу\n нативных мобильных приложений. <br>\n Преимущества: <br>\n Приложение становится более отзывчивым, и пользователи не видят мерцание\n при навигации, т.к. страница не обновляется целиком. <br>\n На сервер поступает меньше HTTP-запросов, так как одни и те же ресурсы не\n нужно загружать снова для каждой загрузки страницы. <br>\n Четкое разделение на клиент и сервер. Вы можете легко создавать новые\n клиентские приложения для разных платформ (например, для мобильных устройств,\n чат-ботов, умных часов) без необходимости изменять код сервера. Вы также\n можете изменить технологический стек на клиенте и сервере независимо, пока\n между ними существует интерфейс. <br>\n Недостатки: <br>\n Более тяжелая первоначальная загрузка страницы из-за загрузки кода\n фреймворка, самого приложения и ресурсов. <br>\n Ваш сервер должен быть сконфигурирован так, чтобы он направлял все запросы\n к единой точке входа, и переложил обязанности по навигации на сторону клиента.\n <br>\n Для отображения содержимого SPA полагается на JavaScript, но не все\n поисковые системы выполняют JavaScript во время индексации, и они могут не\n увидеть содержимое страницы. Это вредит поисковой оптимизации (SEO) вашего\n приложения. Тем не менее, в большинстве случаев, когда вы создаете\n приложения, SEO не является наиболее важным фактором, так как не весь контент\n должен индексироваться поисковыми системами. Чтобы преодолеть это, вы можете\n либо рендерить свое приложение на стороне сервера, либо использовать такие\n сервисы, как Prerender, чтобы “рендерить ваш javascript в браузере, сохранять\n статический HTML и передавать его поисковым роботам”."
      ],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee450"
    },
    "type": "question",
    "question": "Расскажите,\n что такое одностраничное приложение, и как сделать его SEO-оптимизированным.",
    "popularity": null,
    "difficulty": "junior"
  },
  {
    "id": "7HIZWexpmbR09cAsN2TC",
    "description": "какая разница между strong и b",
    "competence": [
      "html",
      "css"
    ],
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Пока не знаю"
      ]
    },
    "type": "question",
    "popularity": "3",
    "difficulty": "junior",
    "question": "какая разница между strong и b"
  },
  {
    "id": "7e8G1mgopXxGXWGN8rLu",
    "competence": [
      "javascript"
    ],
    "popularity": "5",
    "difficulty": "junior",
    "type": "question",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "свойста в функции, возвращаемые через return function, использование вместо callback функции в map, ..."
      ]
    },
    "description": "Closures",
    "question": "Что такое Замыкание?"
  },
  {
    "id": "7fKuNvsAUYZZkOAkbkS3",
    "description": "debounce",
    "popularity": "5",
    "question": "Что такое функция debounce?",
    "competence": [
      "common questions",
      "javascript"
    ],
    "difficulty": "middle",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "создает таймаут, функция высшего порядка"
      ]
    },
    "type": "question"
  },
  {
    "id": "8PvuiFJqj7zakZTGSVZb",
    "description": "",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee441"
    },
    "difficulty": "junior",
    "answer": {
      "link": [],
      "text": [
        "Преимущества\n <br>\n Повышение интерактивности. Новые данные с сервера могут быть добавлены\n динамически без перезагрузки всей страницы. <br>\n Сокращение количества подключений к серверу, поскольку скрипты и таблицы\n стилей нужно запрашивать только один раз. <br>\n Состояние может быть сохранено на странице. Переменные JavaScript и\n состояние DOM сохраняется, поскольку главная страница контейнера не\n перезагружается. <br>\n Большая часть преимуществ SPA. <br>\n Недостатки <br>\n Сложнее реализовать добавление динамической веб-страницы в закладки. <br>\n Не работает, если в браузере отключен JavaScript. <br>\n Некоторые поисковые роботы не выполняют JavaScript и не видят данные,\n загружаемые при помощи JavaScript. <br>\n Большая часть недостатков SPA."
      ],
      "code": []
    },
    "popularity": "3",
    "question": "Какие\n преимущества и недостатки в использовании Ajax?",
    "type": "question"
  },
  {
    "id": "8VDl1VvxeWzRfQTV6LDl",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a0"
    },
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "var\n url = 'http://mydomen.com/news.php', <br>\n script = document.createElement('script'), <br>\n callbackName = 'jsonCallback' + Math.randome(); <br>\n <br>\n script.src = url + '?callback' + callbackName; <br>\n window[callbackName] = function(response){ <br>\n console.log(response); <br>\n } <br>\n document.header.appendChild(script); <br>\n тег script начинает выкачивать скрипт, лежащий по адресу в атрибуте src, а\n после закачки, происходит выполнение. Поэтому мы создаем тег script. Случайным\n образом генерируем имя функции. Формируем урл к ресурсу, где в качестве\n параметра передается имя нашей новой функции. <br>\n В глобальную область, по ключу callbackName помещается функция, которая\n вызовется, при получение данных от ресурса, они станут доступны внутри через\n параметр. <br>\n &lt;script src='http://mydomen.com/news.php?callback0.90428777...'&gt;\n <br>\n На сервере ресурса сработает что-то в этом роде <br>\n echo $_REQUEST[callback] + '(' + json_encode($arDate) + ')'; <br>\n В window попадет <br>\n window.jsonCallback0.90428777 -&gt; function (response) { <br>\n console.log(response); <br>\n } <br>\n Так как теги с атрибутом src способы посылать только GET запросы, то jsonp\n не поддерживает POST <br>\n "
      ]
    },
    "popularity": null,
    "question": "JSONP,\n как реализовать"
  },
  {
    "id": "8a20T6xQlz4vbnTNdO5m",
    "type": "question",
    "description": "static isAvailable = true",
    "difficulty": "junior",
    "question": "В чем особенность статических полей в классах?",
    "answer": {
      "code": [
        "class Cat {\n  constructor() {\n    console.log(Cat.COLLECTION_NAME);\n  }\n}\n\nCat.COLLECTION_NAME = \"cats\";",
        "class Cat {\n  constructor() {\n    console.log(Cat.COLLECTION_NAME);\n  }\n\n  static get COLLECTION_NAME() {\n    return \"cats\"\n  }\n}"
      ],
      "text": [
        "Статические свойства вызываются непосредственно через сам класс и никак больше."
      ],
      "link": []
    },
    "competence": [
      "html"
    ],
    "popularity": "3"
  },
  {
    "id": "8nyzfm8CGoRkYW6KKZl5",
    "_id": {
      "$oid": "60de0704e2c8c53194aee51d"
    },
    "popularity": null,
    "difficulty": null,
    "type": null,
    "description": "",
    "question": "Что\n такое Map и Set",
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "competence": []
  },
  {
    "id": "8q9eIak5eQPNyZu86XBt",
    "_id": {
      "$oid": "60de0704e2c8c53194aee49c"
    },
    "description": "",
    "type": "question",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "function\n isPalindrom1(str) { <br>\n if (str.toLowerCase().replace(/[^а-яА-ЯёЁ]/g, '') ===\n str.toLowerCase().replace(/[^а-яА-ЯёЁ]/g, <br>\n '').split('').reverse().join('')) { <br>\n return true; <br>\n } else { <br>\n return false; <br>\n } <br>\n } <br>\n "
      ],
      "code": []
    },
    "difficulty": "junior",
    "question": "Задача\n про палиндром",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "8qQ11Ioyh5ln1G0v8ihq",
    "question": "В\n чем разница между: `function Person(){}`, `var person = Person()`, и `var\n person = new Person()`?",
    "description": "",
    "competence": [
      "common questions"
    ],
    "answer": {
      "text": [
        "Этот\n вопрос не совсем понятен. Я полагаю, что суть вопроса о конструкторах в\n JavaScript. Строго говоря, function Person(){} — это обычное объявление\n функции. Принято называть с заглавной буквы функции, которые предназначены\n для использования в качестве конструкторов. <br>\n var person = Person() вызывает Person как функцию, а не как конструктор.\n Вызов как таковой является распространенной ошибкой, если функция\n предназначена для использования в качестве конструктора. Как правило,\n конструктор ничего не возвращает, поэтому при вызове конструктора как обычной\n функции возвращается undefined, и это присваивается переменной,\n предназначенной в качестве экземпляра. <br>\n var person = new Person() создает экземпляр объекта Person с помощью\n оператора new, который наследуется от Person.prototype. Альтернативой может\n быть использование Object.create, например: Object.create(Person.prototype).\n <br>\n function Person(name) { <br>\n this.name = name; <br>\n } <br>\n var person = Person(‘John’); <br>\n console.log(person); // undefined <br>\n console.log(person.name); // Uncaught TypeError: Cannot read property\n ‘name’ of undefined <br>\n var person = new Person(‘John’); <br>\n console.log(person); // Person { name: “John” } <br>\n console.log(person.name); // “john”"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new"
      ],
      "code": []
    },
    "popularity": "4",
    "difficulty": "junior",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee43b"
    }
  },
  {
    "id": "8tzSg4K5u99986wcMdL0",
    "popularity": null,
    "question": "queue",
    "description": "",
    "type": null,
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d5"
    },
    "difficulty": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    }
  },
  {
    "id": "8ucZWF0GB38N01JREfyO",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee476"
    },
    "popularity": null,
    "type": "question",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "question": "Объясните,\n что такое псевдоэлементы и для чего они нужны.",
    "answer": {
      "text": [
        "::after\n <br>\n ::before <br>\n ::first-letter <br>\n ::first-line <br>\n "
      ],
      "code": [],
      "link": []
    }
  },
  {
    "id": "94Vg9pIljudftVl5GBel",
    "question": "Массивы",
    "type": null,
    "popularity": null,
    "description": "",
    "competence": [],
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f6"
    },
    "difficulty": null
  },
  {
    "id": "9Kl4rV2xPtG8xcFxxQrH",
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "difficulty": null,
    "description": "",
    "question": "pre-parser",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e4"
    },
    "type": null
  },
  {
    "id": "9QiD8WiXEfyG47zYaswu",
    "popularity": null,
    "type": "question",
    "difficulty": "junior",
    "question": "кофеварка",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d0"
    },
    "answer": {
      "text": [
        "class\n CoffeeMachine { <br>\n #waterAmount = 0; <br>\n get waterAmount() { <br>\n return this.#waterAmount; <br>\n } <br>\n set waterAmount(value) { <br>\n if (value &lt; 0) throw new Error(\"Отрицательный уровень воды\");\n <br>\n this.#waterAmount = value; <br>\n } <br>\n } <br>\n let machine = new CoffeeMachine(); <br>\n machine.waterAmount = 100; <br>\n alert(machine.#waterAmount); // Error <br>\n "
      ],
      "link": [],
      "code": []
    },
    "description": "",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "9UX0EoyQucnXxopB59dz",
    "_id": {
      "$oid": "60de0704e2c8c53194aee523"
    },
    "question": "Как\n работают модули в ES modules",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "difficulty": null,
    "competence": [],
    "popularity": null,
    "description": "",
    "type": null
  },
  {
    "id": "A96LpWttjWVUWt51sJxR",
    "type": null,
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "difficulty": null,
    "competence": [],
    "question": "Как\n сделать какое либо свойство объекта неизменяемым",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee514"
    }
  },
  {
    "id": "AD4BVrAX2cTJcLs9pRCW",
    "popularity": "5",
    "type": "question",
    "answer": {
      "code": [],
      "text": [
        "Этот\n вопрос очень часто задают на собеседованиях. Все объекты в JavaScript имеют\n свойство prototype, которое является ссылкой на другой объект. Когда\n происходит обращение к свойству объекта, и если свойство не найдено в этом\n объекте, то механизм JavaScript просматривает прототип объекта, затем\n прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на\n одном из прототипов или до тех пор, пока он не достигнет конца цепочки\n прототипов. Такое поведение имитирует классическое наследование, но на самом\n деле это скорее делегирование, чем наследование."
      ],
      "link": [
        "https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson",
        "https://davidwalsh.name/javascript-objects"
      ]
    },
    "competence": [
      "javascript",
      "common questions",
      "typescript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee432"
    },
    "difficulty": "junior",
    "question": "Расскажите,\n как работает прототипное наследование",
    "description": ""
  },
  {
    "id": "AOi2FPnxV6KoWsaQDSgj",
    "question": "Что\n делает * { box-sizing: border-box; }? В чем его преимущества?",
    "popularity": null,
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "border-box\n говорит браузеру учитывать любые границы и внутренние отступы в значениях,\n которые вы указываете в ширине и высоте элемента. Если вы выставите элементу\n ширину 100 пикселей, то эти 100 пикселей будут включать в себя границы и\n внутренние отступы, а контент сожмётся, чтобы выделить для них место. Обычно\n это упрощает работу с размерами элементов."
      ]
    },
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee478"
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "AYvgTugpBdIGCIsqSxmW",
    "question": "Что\n выводит код ниже? console.log(0.1 + 0.2 == 0.3);",
    "difficulty": "junior",
    "description": "",
    "type": "question",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee482"
    },
    "answer": {
      "code": [],
      "text": [
        "ЛОЖЬ"
      ],
      "link": []
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "B3w4eoQ2Rjq2N8YcLB8P",
    "competence": [
      "javascript"
    ],
    "popularity": "4",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Нужно делать проверку на элементы, принадлежащие именно этому обьекту, иначе он будет смотреть и по прототипу (hasOwnProperty), а лучше вообще юзать Object.keys(obj)"
      ]
    },
    "type": "question",
    "question": "Почему при написании for (const key in obj) eslint подчеркивает как ошибку?",
    "difficulty": "junior",
    "description": "const key in obj"
  },
  {
    "id": "BILXyCWMXdibzanyEXun",
    "_id": {
      "$oid": "60de0704e2c8c53194aee51b"
    },
    "difficulty": null,
    "popularity": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "description": "",
    "type": null,
    "question": "Что\n такое eval и почему его следует избегать",
    "competence": []
  },
  {
    "id": "BKdn8fGa8bJvRbbjkx4X",
    "type": null,
    "description": "",
    "popularity": null,
    "question": "Hidden\n class",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee500"
    },
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "difficulty": null
  },
  {
    "id": "Br2dtQIGg1jdjQhZzCkH",
    "type": null,
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "popularity": null,
    "question": "Стеки",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f7"
    },
    "description": "",
    "competence": []
  },
  {
    "id": "C8Q08SndvabbpKqGi7sn",
    "question": "Компилятор\n Crankshaft",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee503"
    },
    "type": null,
    "competence": [],
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "description": "",
    "popularity": null
  },
  {
    "id": "ClMwUwpOYyolQN1R9Sl5",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "description": "",
    "question": "Какие\n языковые конструкции вы используете для итерации по свойствам объекта и\n элементам массива?",
    "answer": {
      "link": [
        "http://2ality.com/2015/08/getting-started-es6.html#from-for-to-foreach-to-for-of",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries"
      ],
      "text": [
        "Для\n объектов: <br>\n for-in циклы — for (var property in obj) { console.log(property); }. Тем не\n менее, он также будет перебирать его унаследованные свойства, и вам нужно\n добавить проверку obj.hasOwnProperty(property) перед его использованием.\n <br>\n Object.keys() — Object.keys(obj).forEach(function (property) { … }).\n Object.keys()- это статический метод, который возвращает все перечисляемые\n свойства объекта. <br>\n Object.getOwnPropertyNames() —\n Object.getOwnPropertyNames(obj).forEach(function (property) { … }).\n Object.getOwnPropertyNames() — это статический метод, который возвращает все\n перечисляемые и неперечисляемые свойства объекта. <br>\n Для массивов: <br>\n Циклы for — for (var i = 0; i &lt; arr.length; i++). Распространенной\n ошибкой здесь является то, что var находится в области видимости функции, а\n не в блочной области видимости, и в большинстве случаев нам нужна\n переменная-итератор блочной области. ES2015 позволяет использовать let,\n который имеет блочную область видимости, и рекомендуется использовать его\n вместо var. В итоге: for (let i = 0; i &lt; arr.length; i++). <br>\n forEach — arr.forEach(function (el, index) { … }). Эта конструкция иногда\n может быть более удобной, потому что вам не нужно использовать inde`, если\n все, что вам нужно, это элементы массива. Существуют также методы every и\n some, которые позволят вам досрочно завершить итерацию. <br>\n for-of циклы — for (let elem of arr) { … }. ES6 представил новый цикл\n for-of, который позволяет перебирать объекты, которые соответствуют\n итерируемому протоколу такие как String, Array, Map, Set, и т.д. Он сочетает\n в себе преимущества цикла `for` и метода forEach(). Преимущество цикла `for`\n заключается в том, что его можно преждевременно завершить, а преимущество\n forEach() заключается в том, что он более лаконичен, чем цикл for, поскольку\n вам не нужна переменная счетчика. С циклом for-of вы получаете возможность\n выхода из цикла и более сжатый синтаксис. <br>\n В большинстве случаев я бы предпочел метод .forEach, но он зависит от того,\n что вы пытаетесь сделать. До ES6 мы использовали циклы for, если нам нужно\n было преждевременно завершить цикл при помощи break. Но теперь с ES6 мы можем\n сделать это с помощью циклов for-of. Я использую циклы for, когда мне нужно\n еще больше гибкости, например, в случае увеличения итератора более одного\n раза за цикл. <br>\n Кроме того, при использовании цикла for-of, если вам нужен доступ как к\n индексу, так и к значению каждого элемента массива, вы можете сделать это с\n помощью метода ES6 entries() и деструктуризации: <br>\n const arr = ['a', 'b', 'c']; <br>\n for (let [index, elem] of arr.entries()) { <br>\n console.log(index, ': ', elem); <br>\n }"
      ],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee455"
    },
    "popularity": null,
    "type": "question"
  },
  {
    "id": "D4CeEHQAPTAdcUk35p8G",
    "competence": [],
    "question": "generator\n functions",
    "popularity": null,
    "description": "",
    "type": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ed"
    },
    "difficulty": null
  },
  {
    "id": "D9sYzyuFOJRvgSwFr9Fn",
    "description": "Первая буква",
    "type": "question",
    "question": "Как проверить первый символ строки?",
    "answer": {
      "code": [],
      "text": [
        ".statsWith()"
      ],
      "link": []
    },
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "popularity": "4"
  },
  {
    "id": "DLejr8fkMKMfXbZJan1Y",
    "difficulty": "middle",
    "question": "Как запустить проверку валидности проекта?",
    "answer": {
      "code": [],
      "text": [
        "eslint ./src"
      ],
      "link": []
    },
    "competence": [
      "javascript",
      "frontend"
    ],
    "description": "запустить проверку линта",
    "type": "question",
    "popularity": "3"
  },
  {
    "id": "DaPTOayYXGDTkfHA1buy",
    "description": "",
    "answer": {
      "text": [
        "GET\n — получение ресурса <br>\n POST — создание ресурса <br>\n PUT — обновление ресурса <br>\n DELETE — удаление ресурса <br>\n REST (REpresentational State Transfer) <br>\n "
      ],
      "link": [],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee480"
    },
    "popularity": null,
    "difficulty": "junior",
    "type": "question",
    "question": "Что\n такое HTTP-методы? Перечислите все HTTP-методы, которые вы знаете, и\n объясните их.",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "E3L8GfBg2r8MQvFrO92u",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "//\n Вспомогательная функция, которая создаёт объект для хранения данных <br>\n const buildCharObject = str =&gt; { <br>\n const charObj = {} <br>\n for(let char of str.replace(/[^\\w]/g).toLowerCase()) { <br>\n // Если объект уже содержит пару ключ-значение равную значению в цикле,\n <br>\n // увеличиваем значение на 1, в противном случае добавляем букву в качестве\n ключа <br>\n // и 1 в качестве значения <br>\n charObj[char] = charObj[char] + 1 || 1 <br>\n } <br>\n return charObj <br>\n } <br>\n // Главная функция <br>\n const anagram = (strA, strB) =&gt; { <br>\n // Создаём объект для хранения strA <br>\n const aCharObject = buildCharObject(strA) <br>\n // Создаём объект для хранения strB <br>\n const bCharObject = buildCharObject(strB) <br>\n // Сравниваем количество ключей в обоих объектах <br>\n // (анаграммы должны иметь одинаковое количество букв) <br>\n if(Object.keys(aCharObject).length !== Object.keys(bCharObject).length) {\n <br>\n return false <br>\n } <br>\n // Если оба объекта имеют одинаковое количество ключей, мы можем быть\n уверены, <br>\n // что обе строки имеют одинаковое количество символов. Теперь мы можем\n сравнить <br>\n // оба объекта, чтобы увидеть, имеют ли они одинаковые буквы в одинаковом\n количестве <br>\n for(let char in aCharObject) { <br>\n if(aCharObject[char] !== bCharObject[char]) { <br>\n return false <br>\n } <br>\n } <br>\n // Если проверка успешна, строки являются анаграммами — возвращаем true\n <br>\n return true <br>\n }"
      ],
      "code": []
    },
    "difficulty": "junior",
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c4"
    },
    "competence": [
      "javascript"
    ],
    "question": "Анаграмма"
  },
  {
    "id": "ESGRBYueW6u458mCQniV",
    "question": "Реализовать\n Foo",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "answer": {
      "code": [],
      "text": [
        "function\n Book(name, author) { <br>\n this.name = name; <br>\n this.author = author; <br>\n return this; <br>\n } <br>\n function Foo(Book, 'Учебник javascript', 'Петр Сергеев') <br>\n <br>\n function Book(name, author) { <br>\n this.name = name; <br>\n this.author = author; <br>\n return this; <br>\n } <br>\n function Foo(Cclass, name, author) { <br>\n return Cclass.call({}, name, author); <br>\n } <br>\n var book = Foo(Book, 'js', 'petr'); <br>\n console.log(book.name); <br>\n "
      ],
      "link": []
    },
    "description": "",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee49b"
    },
    "difficulty": "junior"
  },
  {
    "id": "EZxaqmQ5fwemdl0JtJsh",
    "competence": [],
    "question": "lazily\n evaluated",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f2"
    },
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "type": null,
    "difficulty": null,
    "popularity": null
  },
  {
    "id": "FkTyUIEzFXSz76uurH0d",
    "type": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee524"
    },
    "difficulty": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "description": "",
    "popularity": null,
    "competence": [],
    "question": "Можем\n ли мы поменять переменную в модуле извне"
  },
  {
    "id": "FyniKBNg0qsPKigT4jAh",
    "description": "",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "type": "question",
    "question": "Вопрос:\n Что получится в результате выполнения кода и почему?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4bf"
    },
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "var\n obj = {}; <br>\n function func(x) { <br>\n x = 1; <br>\n return x; <br>\n } <br>\n func(obj); // =&gt; ? <br>\n console.log(obj); // =&gt; ? <br>\n Функция вернёт 1, obj при этом не изменится; <br>\n Несмотря на то, что объекты в JavaScript передаются в параметры функций по\n ссылке, obj не изменится. <br>\n Внутри функции создаётся локальная переменная x, в которую изначально\n попадет ссылка на obj, но позже эта переменная переписывается на числовое\n значение 1. Т.е. меняется само значение переменной x, но меняется значение,\n которое находится по ссылке, переданной изначально в функцию. <br>\n "
      ],
      "code": []
    }
  },
  {
    "id": "GNWSRA55zWZl4wD7xROf",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e5"
    },
    "competence": [],
    "question": "parser",
    "type": null,
    "difficulty": null,
    "description": "",
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "popularity": null
  },
  {
    "id": "GRtIYxEvdOQJK3VPSJvy",
    "popularity": "3",
    "difficulty": "junior",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee440"
    },
    "competence": [
      "javascript"
    ],
    "description": "",
    "question": "Расскажите\n об Ajax как можно более подробно",
    "answer": {
      "text": [
        "Ajax\n (асинхронный JavaScript и XML) - это набор методов веб-разработки,\n использующих множество веб-технологий на стороне клиента для создания\n асинхронных веб-приложений. С помощью Ajax веб-приложения могут отправлять\n данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не\n влияя на отображение и поведение открытой страницы. Отделяя уровень обмена\n данными от уровня представления, Ajax позволяет веб-страницам и, в частности,\n веб-приложениям динамически изменять содержимое без необходимости\n перезагрузки всей страницы. На практике для получения/передачи данных\n используется формат данных JSON вместо XML из-за того, что JSON основан на\n JavaScript. <br>\n Раньше для асинхронного взаимодействия использовали XMLHttpRequest API, а\n сейчас принято использовать fetch API."
      ],
      "code": [],
      "link": [
        "https://en.wikipedia.org/wiki/Ajax_(programming)",
        "https://developer.mozilla.org/en-US/docs/AJAX"
      ]
    }
  },
  {
    "id": "Ghei604jqu37fNcSz4pG",
    "popularity": null,
    "answer": {
      "text": [
        "Необходимо\n реализовать функцию, принимающую в аргументах строку, состоящую из букв и\n вернуть новую строку, в которой повторяющиеся буквы заменены количеством\n повторений. <br>\n Например: <br>\n rle('AVVVBBBVVXDHJFFFFDDDDDDHAAAAJJJDDSLSSSDDDD'); // =&gt;\n 'AV3B3V2XDHJF4D6HA4J3D2SLS3D4' <br>\n function rle(str) { <br>\n const result = [str[0]]; <br>\n let count = 1; <br>\n for (let i = 1; i &lt; str.length; i++) { <br>\n if (str[i] === str[i - 1]) { <br>\n count++; <br>\n if (i === str.length - 1) { <br>\n result.push(str[i]); <br>\n if (count &gt; 1) { <br>\n result.push(count); <br>\n } <br>\n } <br>\n } else { <br>\n if (i &gt; 1) { <br>\n result.push(str[i - 1]); <br>\n } <br>\n if (i === str.length - 1) { <br>\n result.push(str[i]); <br>\n } <br>\n if (count &gt; 1) { <br>\n result.push(count); <br>\n } <br>\n count = 1; <br>\n } <br>\n } <br>\n return result.join(''); <br>\n } <br>\n "
      ],
      "link": [],
      "code": []
    },
    "question": "Задача:\n «Сжатие строк»",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4be"
    },
    "difficulty": "junior",
    "type": "question",
    "description": ""
  },
  {
    "id": "Gi5Wxu2haYcHaidvt0Sa",
    "competence": [
      "javascript"
    ],
    "description": "",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ac"
    },
    "question": "В\n js переменные объявленные следующим образом: <br>\n a=3; b=«hello»; <br>\n ",
    "popularity": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Укажите\n правильные утверждения. <br>\n а) создаются в локальном контексте <br>\n б) создаются в глобальном контексте <br>\n в) создание переменной без ключевого слова var — синтаксическая ошибка.\n <br>\n б) и в) <br>\n "
      ]
    },
    "type": "question"
  },
  {
    "id": "H9nxep6x8M2pxQyNtSjh",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "answer": {
      "text": [
        "print\n speech"
      ],
      "code": [],
      "link": []
    },
    "difficulty": "junior",
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee475"
    },
    "question": "Можете\n ли вы привести пример свойства @media, отличного от screen?"
  },
  {
    "id": "HW8iih6qjGR1npLsyhz9",
    "question": "Можете\n ли вы привести пример каррированной функции (curry function) и в чем их\n преимущество?",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "description": "",
    "difficulty": "junior",
    "type": "question",
    "answer": {
      "link": [
        "https://hackernoon.com/currying-in-js-d9ddc64f162e"
      ],
      "text": [
        "Каррирование\n — это паттерн, где функция с более чем одним параметром разбивается на\n несколько функций, которые при последовательном вызове будут накапливать все\n необходимые параметры по одному. Этот метод может быть полезен для облегчения\n чтения и написания кода, написанного в функциональном стиле. Важно отметить,\n что каррированная функция должна начинаться как одна функция, а затем\n разбиваться на последовательность функций, каждая из которых принимает один\n параметр. <br>\n function curry(fn) { <br>\n if (fn.length === 0) { <br>\n return fn; <br>\n } <br>\n function _curried(depth, args) { <br>\n return function(newArgument) { <br>\n if (depth — 1 === 0) { <br>\n return fn(…args, newArgument); <br>\n } <br>\n return _curried(depth — 1, […args, newArgument]); <br>\n }; <br>\n } <br>\n return _curried(fn.length, []); <br>\n } <br>\n function add(a, b) { <br>\n return a + b; <br>\n } <br>\n var curriedAdd = curry(add); <br>\n var addFive = curriedAdd(5); <br>\n var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10] <br>\n "
      ],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee45f"
    }
  },
  {
    "id": "HdoUxyx7Y516ILbe45IC",
    "type": "question",
    "difficulty": "beginner",
    "answer": {
      "link": [],
      "text": [
        "draw.io"
      ],
      "code": []
    },
    "popularity": "1",
    "competence": [
      "common questions"
    ],
    "question": "На каком ресурсе удобно рисовать моковый дизайн?",
    "description": "Просто схематичное описание дизайна."
  },
  {
    "id": "HzrXIhWqjVhq4CiFqb2u",
    "_id": {
      "$oid": "60de0704e2c8c53194aee44a"
    },
    "question": "Сделайте\n так, чтобы этот код работал: duplicate([1, 2, 3, 4, 5]); //\n [1,2,3,4,5,1,2,3,4,5]",
    "type": "exercise",
    "difficulty": "junior",
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "Решение:\n <br>\n function duplicate(arr) { <br>\n return arr.concat(arr); <br>\n } <br>\n duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]"
      ],
      "link": []
    },
    "popularity": null,
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "IENjVzxf2Fw8d9e3nSsz",
    "difficulty": null,
    "popularity": null,
    "type": null,
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4db"
    },
    "question": "scope",
    "competence": [],
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    }
  },
  {
    "id": "IsSMKuaRbQFhtexYXzMc",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "answer": {
      "text": [
        "Cross-Origin\n Resource Sharing"
      ],
      "code": [],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee467"
    },
    "question": "Что\n означает CORS и какую проблему решает?",
    "description": "",
    "popularity": null,
    "difficulty": "junior"
  },
  {
    "id": "ItXYrb6Xh63Y2Flpctva",
    "difficulty": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "question": "Что\n такое Promise",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee515"
    },
    "popularity": null,
    "type": null,
    "description": ""
  },
  {
    "id": "JFa76Vor5qzJlPjIgB7q",
    "question": "Деревья",
    "difficulty": null,
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "competence": [],
    "type": null,
    "description": "",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4fa"
    }
  },
  {
    "id": "JFtybyPf91Xg3kdxBkfB",
    "popularity": null,
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee45d"
    },
    "difficulty": "junior",
    "question": "Можете\n ли вы привести пример деструктуризации объекта или массива?",
    "description": "",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",
        "https://ponyfoo.com/articles/es6-destructuring-in-depth"
      ],
      "code": [],
      "text": [
        "Деструктуризация\n — это выражение, доступное в ES6, которое предоставляет краткий и удобный\n способ извлекать значения из объектов или массивов и помещать их в отдельные\n переменные. <br>\n <br>\n Деструктуризация массива <br>\n // Присваивание переменной <br>\n const foo = [‘one’, ‘two’, ‘three’]; <br>\n const [one, two, three] = foo; <br>\n console.log(one); // “one” <br>\n console.log(two); // “two” <br>\n console.log(three); // “three” <br>\n // Перестановка переменных местами <br>\n let a = 1; <br>\n let b = 3; <br>\n [a, b] = [b, a]; <br>\n console.log(a); // 3 <br>\n console.log(b); // 1 <br>\n <br>\n Деструктуризация объекта <br>\n // Присваивание переменной <br>\n const o = { p: 42, q: true }; <br>\n const { p, q } = o; <br>\n console.log(p); // 42 <br>\n console.log(q); // true <br>\n "
      ]
    }
  },
  {
    "id": "JPHYu3QKa4LMysIkdaJr",
    "popularity": null,
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "description": "",
    "question": "High\n order functions и карриррование",
    "difficulty": null,
    "competence": [],
    "type": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee520"
    }
  },
  {
    "id": "JSVczdxBDyp5u1FK2ClZ",
    "question": "В\n чем разница между feature detection (определение возможностей браузера),\n feature inference (предположение возможностей) и анализом строки user-agent?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee43f"
    },
    "description": "",
    "difficulty": "junior",
    "popularity": "3",
    "answer": {
      "code": [],
      "text": [
        "Feature\n detection (определение возможностей браузера) <br>\n Определение возможностей браузера заключается в определении, поддерживает\n ли браузер определенный блок кода - и если нет, то будет выполняться другой\n код, так что браузер всегда сможет обеспечить работоспособность и\n предотвратить сбои/ошибки в некоторых браузерах. Например: <br>\n if ('geolocation' in navigator) { <br>\n // Можно использовать navigator.geolocation <br>\n } else { <br>\n // Обработка отсутствия возможности <br>\n } <br>\n Modernizr - отличная библиотека для обработки таких функций. <br>\n Feature inference (предположение возможностей) <br>\n Предположение возможностей проверяет на наличие определенных возможностей,\n как и предыдущий подход, но использует другую функцию, которая предполагает,\n что определенная возможность уже существует, например: <br>\n if (document.getElementsByTagName) { <br>\n element = document.getElementById(id); <br>\n } <br>\n Этот подход не рекомендуется. Первый подход более надежен. <br>\n Строка User Agent <br>\n Это строка, сообщаемая браузером, которая позволяет узлам сетевого\n протокола определить тип приложения, операционную систему, поставщика\n программного обеспечения или версию программного обеспечения пользователя от\n которого исходит запрос. Доступ к ней можно получить через\n navigator.userAgent. Тем не менее, строка User Agent сложна для обработки и\n может быть подделана. Например, браузер Chrome идентифицируется как Chrome,\n так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны\n проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте\n этого метода."
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection",
        "https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th",
        "https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent"
      ]
    },
    "type": "question",
    "competence": [
      "common questions"
    ]
  },
  {
    "id": "K1Q2gEnciu6dCfSN5U6w",
    "question": "Почему\n тернарный оператор так называется?",
    "competence": [
      "javascript"
    ],
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "“Тернарный”\n означает три. Троичное выражение принимает три операнда: условие, выражение\n “then” и выражение “else”. Тернарные операторы не являются исключительными\n для JavaScript, и я не знаю, почему подобный вопрос был добавлен в этот\n список."
      ],
      "link": [
        "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"
      ]
    },
    "difficulty": "junior",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee44b"
    },
    "type": "question"
  },
  {
    "id": "K5n1yhtoklElZKsJSBLq",
    "type": null,
    "description": "",
    "popularity": null,
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4fd"
    },
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "difficulty": null,
    "question": "Хеш-таблицы"
  },
  {
    "id": "KIyKy6lHaUwRmHMDZGyQ",
    "answer": {
      "text": [
        "Прогрессивный\n рендеринг — имя, данное технологиям, используемым для ускорения\n отрисовки страниц (в частности, уменьшение времени загрузки), чтобы показать\n пользователю контент как можно скорее. <br>\n До того, как широкополосный интернет распространился повсеместно,\n прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему\n полезен в современной разработке, поскольку все более популярным (и\n ненадежным) становится мобильный доступ в интернет. <br>\n Примеры технологий: <br>\n Ленивая загрузка картинок. Картинки на странице не загружаются все разом.\n JavaScript подгрузит картинки тогда, когда пользователь доскроллит до той\n части страницы, на которой они расположены. <br>\n Приоритизация видимого контента. Только минимум CSS, контента, скриптов,\n необходимых для отрисовки той части страницы, которую пользователь увидит\n первой. Вы можете использовать отложенные скрипты или слушать события\n DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.\n <br>\n Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы,\n созданной на бэкенде. Более подробно про эту технологию можно почитать в этой\n статье. <br>\n "
      ],
      "link": [],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "question": "Что\n такое прогрессивный рендеринг?",
    "difficulty": "junior",
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee46f"
    }
  },
  {
    "id": "KON9zLObxM9gMwGvnKFP",
    "_id": {
      "$oid": "60de0704e2c8c53194aee49d"
    },
    "difficulty": "junior",
    "answer": {
      "text": [
        "opacity\n отвечает за прозрачность элемента. Принимает значения от 0 до 1, при 0 —\n элемент не виден, .5 — полупрозрачен, 1 — полностью виден. Даже при 0\n занимает место на странице. <br>\n Элемент со стилями visible: hidden так же занимает место, не видим. Но в\n отличие от элемента с opacity, js-события на нем не срабатывают. <br>\n display: none — полностью скрывает элемент, он не видим и не занимает место\n на странице. javascript не может получить ни width, height. <br>\n overflow: hidden; — скрывает все, что попадет за его пределы. <br>\n "
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "javascript"
    ],
    "description": "",
    "popularity": null,
    "question": "Чем\n opacity отличается от visible: hidden и что это такое, отличие от overflow:\n hidden?",
    "type": "question"
  },
  {
    "id": "Kcgo1MqGhzDW7vee07vG",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b2"
    },
    "competence": [
      "javascript"
    ],
    "question": "Задача:\n Реализовать аналог Promise.all.",
    "difficulty": "junior",
    "type": "question",
    "description": "",
    "answer": {
      "text": [
        "promiseAll([\n <br>\n new Promise((resolve) =&gt; { <br>\n setTimeout(() =&gt; resolve('foo'), 5000) <br>\n }), <br>\n new Promise((resolve, reject) =&gt; { <br>\n setTimeout(() =&gt; resolve('bar'), 1000); <br>\n }), <br>\n new Promise((resolve, reject) =&gt; { <br>\n setTimeout(() =&gt; { <br>\n Math.round(Math.random() * 10) % 2 === 0 <br>\n ? resolve('baz') <br>\n : reject(new Error()); <br>\n }, 300); <br>\n }), <br>\n ]) <br>\n .then((res) =&gt; console.log('RESOLVED: ', res)) <br>\n .catch((err) =&gt; console.log('REJECTED: ', err));"
      ],
      "link": [],
      "code": []
    },
    "popularity": null
  },
  {
    "id": "KnpKpqDU6JwxksbxyPBM",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4fc"
    },
    "description": "",
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "popularity": null,
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">Боры (в сущности, это тоже деревья, но их\n целесообразно рассмотреть отдельно). Префиксное дерево (Trie)</div>\n </div>",
    "type": null,
    "competence": [],
    "difficulty": null
  },
  {
    "id": "KuvFIW7XQSJjksPXCMKo",
    "answer": {
      "link": [
        "https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3",
        "https://stackoverflow.com/a/3127440/1751946"
      ],
      "code": [],
      "text": [
        "Нельзя\n в двух словах объяснить работу ключевого слова this; это одно из самых\n запутанных понятий в JavaScript. Говоря максимально простым языком, значение\n this зависит от того, как вызывается функция. Я прочитал много объяснений о\n работе this, и считаю объяснение Arnav Aggrawal наиболее понятным.\n Применяются следующие правила:<br>\n 1. Если ключевое слово new используется при вызове функции, this внутри\n функции является совершенно новым объектом.<br>\n 2. Если для вызова/создания функции используются apply, call или bind, то\n this внутри функции — это объект, который передается в качестве\n аргумента.<br>\n 3. Если функция вызывается как метод, например, obj.method(), то this — это\n объект, к которому принадлежит функция.<br>\n 4. Если функция вызывается без контекста, то есть она вызывается без\n условий, описанных в пунктах выше, то this является глобальным объектом. В\n браузере это объект window. В строгом режиме (’use strict’), this будет\n undefined вместо глобального объекта.<br>\n 5. Если применяются несколько из вышеперечисленных правил, то правило,\n которое выше выигрывает и устанавливает значение this.<br>\n 6. Если функция является стрелочной функцией, то она игнорирует все\n вышеописанные правила и получает значение this из лексического окружения во\n время ее создания.<br>\n "
      ]
    },
    "description": "",
    "question": "Объясните,\n как this работает в JavaScript",
    "type": "question",
    "popularity": "5",
    "competence": [
      "javascript",
      "typescript"
    ],
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee431"
    }
  },
  {
    "id": "Lbp2IhRGlHsoNfTL5Hg2",
    "popularity": null,
    "type": "question",
    "answer": {
      "link": [],
      "text": [
        "Ассоциативный\n массив — абстрактный тип данных, с помощью которого хранятся пары\n ключ-значение. У него есть и другие названия: \"словарь\",\n \"мап\" (от слова map). В разных языках ему соответствуют разные типы\n данных. В JavaScript — это Object, в других языках: <br>\n Структура данных, которая позволяет хранить пары ключ-значение и выполнять\n три операции над ними: добавление новой пары, поиск значение по ключу и\n удаление пары по ключу. <br>\n "
      ],
      "code": []
    },
    "question": "Что-такое\n хэш-таблица?",
    "competence": [
      "javascript"
    ],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4cb"
    },
    "difficulty": "junior"
  },
  {
    "id": "MDQhdrkfb6wyPacu02x1",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a8"
    },
    "answer": {
      "link": [],
      "text": [
        "var\n arr = [ <br>\n {name: 'width', value: 10}, <br>\n {name: 'height', value: 20} <br>\n ] <br>\n // на выходе объект <br>\n {width: 10, height: 20} <br>\n function getObj(arr) { <br>\n var obj = {}; <br>\n <br>\n arr.forEach(function(item){ <br>\n obj[item.name] = item.value; <br>\n }); <br>\n <br>\n return obj; <br>\n }"
      ],
      "code": []
    },
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "question": "Напишите\n код, который сделает из массива объект",
    "popularity": null,
    "description": ""
  },
  {
    "id": "NU4LB9xHGMiX8YLrLBZ3",
    "competence": [],
    "type": null,
    "description": "",
    "difficulty": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4eb"
    },
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">__proto__ (reference to Class.prototype)</div>\n </div>"
  },
  {
    "id": "Ny0dOVaPgf0I3ItMuzLx",
    "difficulty": "senior",
    "type": "question",
    "answer": {
      "link": [],
      "text": [
        "Это как в rxjs Observable Subject BehaviourSubject\nМожно подписать компоненты, они наблюдают за изменениями и изменения прокидывается ко всем, кто за ними наблюдает"
      ],
      "code": []
    },
    "popularity": "4",
    "competence": [
      "common questions",
      "javascript"
    ],
    "question": "Что такое observer pattern?",
    "description": "observer "
  },
  {
    "id": "NzAPv7lDVHU8aBmTTuiy",
    "difficulty": "middle",
    "type": "question",
    "popularity": "1",
    "competence": [
      "javascript"
    ],
    "description": "Как в Babel выглядит async функция?",
    "question": "Как в Babel выглядит async функция?",
    "answer": {
      "code": [],
      "text": [
        "async => asyncGeneratorStep in Babel (так асинхронная функция отображается в файле после пропуск через полифил)"
      ],
      "link": []
    }
  },
  {
    "id": "OFOpmVC70kOrPuPWCeJi",
    "difficulty": "beginner",
    "description": "contenteditable in html",
    "type": "question",
    "popularity": "1",
    "competence": [
      "html",
      "css",
      "frontend"
    ],
    "question": "Что за свойство contenteditable?",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "свойство прописать в div и можно писать прямо в диве как в инпуте(spellcheck=\"false\" убирает проверку на ввоимые слова)"
      ]
    }
  },
  {
    "id": "OOZumNsxsf2CMYgiJSKl",
    "question": "Насколько\n вы опытны в работе с промисами (promises) и/или их полифилами?",
    "popularity": null,
    "answer": {
      "code": [],
      "link": [
        "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261"
      ],
      "text": [
        "Обладаю\n практическими знаниями о них. Промис — это объект, который может вернуть одно\n значение в будущем: либо выполненное значение, либо причина, по которой оно\n не было выполнено (например, произошла ошибка сети). Промис может находиться\n в одном из 3 возможных состояний: выполнено, отклонено или ожидает\n выполнения. При использовании промисов можно добавлять callback-функции для\n обработки выполненного значения или причины отказа. <br>\n Некоторыми распространенными полифилами являются $.deferred, Q и Bluebird,\n но не все они соответствуют спецификации. ES2015 поддерживает промисы “из\n коробки”, и в настоящее время полифилы обычно не нужны. <br>\n "
      ]
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee451"
    },
    "type": "question",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "description": ""
  },
  {
    "id": "OV2Bul5DgPjOIY0CGoQl",
    "question": "Что такое деструктулизация?",
    "type": "question",
    "popularity": "5",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [
        "https://dmitripavlutin.com/javascript-object-destructuring/",
        "https://javascript.info/destructuring-assignment"
      ],
      "text": [
        "Раскрывает массив или обьект и присваивает значения из массива"
      ],
      "code": [
        "// we have an array with the name and surname\nlet arr = [\"John\", \"Smith\"]\n\n// destructuring assignment\n// sets firstName = arr[0]\n// and surname = arr[1]\nlet [firstName, surname] = arr;\n\nalert(firstName); // John\nalert(surname);  // Smith"
      ]
    },
    "description": "Деструктивное присваивание",
    "difficulty": "middle"
  },
  {
    "id": "OZ02wMlKxpHqt27XJk0R",
    "type": "question",
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Пройти\n массив циклом и сложить все имеющиеся там цифры и вычесть из числа,\n полученного по формуле (n + 1) / (n / 2)."
      ]
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee499"
    },
    "popularity": null,
    "question": "От\n них же. Числа от 1 до 100 лежат в массиве, они хаотично перемешанные, от туда\n изъяли одно число, надо найти, что это за число. алгоритм не должен превышать\n O(n^2) сложности.",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "Oz3DOPJuQ5JCy6pAspQY",
    "question": "Дана\n функция, она принимает в качестве аргументов строки '*', '1', 'b', '1c',\n реализуйте ее так, что бы она вернула строку '1*b*1c'",
    "_id": {
      "$oid": "60de0704e2c8c53194aee48b"
    },
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "description": "",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Ее\n можно решать прямо в лоб, перебирая в цикле все аргументы, но мы поступим\n умнее. <br>\n <br>\n Дано дерево, надо найти сумму всех вершин. <br>\n Я решила задачу рекурсией, потом мы упростили решение, а затем переписали\n на очередь. <br>\n var sum = 0; <br>\n <br>\n function getSum(obj) { <br>\n sum += obj.valueNode; <br>\n if (obj.next != null) { <br>\n for (var i = 0; i &lt; obj.next.length; i++) { <br>\n getSum(obj.next[i]); <br>\n } <br>\n } <br>\n <br>\n return sum; <br>\n } <br>\n <br>\n var tree1 = { <br>\n valueNode: 1, <br>\n next: [ <br>\n { <br>\n valueNode: 3, <br>\n next: null <br>\n }, <br>\n { <br>\n valueNode: 2, <br>\n next: null <br>\n } <br>\n ] <br>\n } <br>\n "
      ]
    },
    "type": "question"
  },
  {
    "id": "PPNVLsLJp1YaBIxIuKut",
    "description": "Как они используются и для чего?",
    "difficulty": "junior",
    "question": "Что такое что такое data атрибуты?",
    "popularity": "4",
    "competence": [
      "javascript",
      "html"
    ],
    "answer": {
      "text": [
        "(data-attr, getAttribute(attr) | DOMStringMap{resize: col} e.target.dataset.resize)"
      ],
      "link": [],
      "code": []
    },
    "type": "question"
  },
  {
    "id": "PUD6Y8wlnEaUSAq92Z6v",
    "_id": {
      "$oid": "60de0704e2c8c53194aee458"
    },
    "difficulty": "junior",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "question": "В\n чем различие между переменными, созданными при помощи `let`, `var` и `const`?",
    "description": "",
    "answer": {
      "text": [
        "Переменные,\n объявленные при помощи ключевого слова var, относятся к области видимости\n функции, в которой они созданы. Или, если они созданы вне какой-либо функции\n — к глобальному объекту. let и const относятся к блочной области видимости —\n это означает, что они доступны только в пределах ближайшего набора фигурных\n скобок (функция, блок if-else или цикл for). <br>\n function foo() { <br>\n // Все переменные доступны внутри функции. <br>\n var bar = 'bar'; <br>\n let baz = 'baz'; <br>\n const qux = 'qux'; <br>\n console.log(bar); // bar <br>\n console.log(baz); // baz <br>\n console.log(qux); // qux <br>\n } <br>\n console.log(bar); // ReferenceError: bar is not defined <br>\n console.log(baz); // ReferenceError: baz is not defined <br>\n console.log(qux); // ReferenceError: qux is not defined <br>\n if (true) { <br>\n var bar = 'bar'; <br>\n let baz = 'baz'; <br>\n const qux = 'qux'; <br>\n } <br>\n // переменные, объявленные при помощи var, доступны в любом месте функции.\n <br>\n console.log(bar); // bar <br>\n // переменные, объявленные при помощи let и const не доступны вне блока, в\n котором были определены. <br>\n console.log(baz); // ReferenceError: baz is not defined <br>\n console.log(qux); // ReferenceError: qux is not defined <br>\n var позволяет поднимать переменные, что означает, что на них можно\n ссылаться в коде до их объявления. let и const не позволяют этого, и выдают\n ошибку. <br>\n console.log(foo); // undefined <br>\n var foo = 'foo'; <br>\n console.log(baz); // ReferenceError: can’t access lexical declaration 'baz'\n before initialization <br>\n let baz = 'baz'; <br>\n console.log(bar); // ReferenceError: can’t access lexical declaration 'bar'\n before initialization <br>\n const bar = 'bar'; <br>\n Переопределение переменной с помощью var не вызовет ошибку, в отличие от\n let и const. <br>\n var foo = 'foo'; <br>\n var foo = 'bar'; <br>\n console.log(foo); // “bar” <br>\n let baz = 'baz'; <br>\n let baz = 'qux'; // Uncaught SyntaxError: Identifier ‘baz’ has already been\n declared <br>\n let отличается от const тем, что изменять значение const нельзя. <br>\n // Это нормально. <br>\n let foo = 'foo'; <br>\n foo = 'bar'; <br>\n // Это вызывает исключение. <br>\n const baz = 'baz'; <br>\n baz = 'qux';"
      ],
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const"
      ]
    },
    "popularity": null
  },
  {
    "id": "PqA1QdpvpAJ2dgggjWWI",
    "competence": [
      "common questions",
      "javascript"
    ],
    "question": "Что такое DIP deep indencemble dependens inversioal principal",
    "description": "DIP",
    "answer": {
      "link": [],
      "text": [
        "DIP"
      ],
      "code": []
    },
    "popularity": "5",
    "difficulty": "senior",
    "type": "question"
  },
  {
    "id": "PtApcR5V8eemQbgkcjLr",
    "answer": {
      "code": [],
      "text": [
        "1020"
      ],
      "link": []
    },
    "question": "Вопрос:\n Чему равно foo? var foo = 10 + '20'",
    "popularity": null,
    "difficulty": "junior",
    "type": "question",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee481"
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "Pxsh7XJOa8BTiWofuAZ2",
    "description": "root em",
    "type": "question",
    "answer": {
      "text": [
        "размер шрифта относительный использовать root em"
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "html",
      "css"
    ],
    "question": "Что такое величина rem?",
    "popularity": "2",
    "difficulty": "junior"
  },
  {
    "id": "QAtNMBy6kgEzejh94eYW",
    "competence": [],
    "description": "",
    "type": null,
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e8"
    },
    "popularity": null,
    "question": "optimizing\n compiler",
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    }
  },
  {
    "id": "QNnCoC8TiIqRypaUSwOy",
    "answer": {
      "code": [],
      "text": [
        "Семантика.\n Позволяет более точно описать из чего состоит контент. <br>\n Связанность. Позволяет общаться с сервером новыми и инновационными\n способами. <br>\n Офлайн и хранилище. Позволяют страницам хранить данные локально на\n клиентской стороне и более эффективно работать в офлайне. <br>\n Мультимедиа. Ставит создание видео и аудио на первое место в вебе. <br>\n 2D- и 3D-графика и эффекты. Позволяет расширить возможности презентации.\n <br>\n Производительность и интеграция. Обеспечивает большую скорость оптимизации\n и лучшее использование аппаратных средств. <br>\n Доступ к устройствам. Позволяет взаимодействовать с различными устройствами\n ввода и вывода. <br>\n Стилизация. Позволяет создавать более сложные темы оформления. <br>\n "
      ],
      "link": []
    },
    "difficulty": "junior",
    "description": "",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d2"
    },
    "popularity": null,
    "question": "Представьте\n HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?",
    "type": "question"
  },
  {
    "id": "QWnIdqdjuKLPnu329EoI",
    "difficulty": null,
    "competence": [],
    "description": "",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee50d"
    },
    "question": "Различие\n операторов сравнения",
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "type": null
  },
  {
    "id": "QkM5mFj3BNZLnFiCIE4U",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d7"
    },
    "type": null,
    "description": "",
    "popularity": null,
    "competence": [],
    "difficulty": null,
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "question": "heap"
  },
  {
    "id": "QxUkf5SX5v5wsdkiorjp",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "question": "Что\n выведется в результате?",
    "type": "question",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a9"
    },
    "answer": {
      "code": [],
      "text": [
        "var\n i = 10; <br>\n <br>\n var array = []; <br>\n <br>\n while (i--) { <br>\n <br>\n (function (i) { <br>\n <br>\n var i = i; <br>\n <br>\n array.push(function() { <br>\n <br>\n return i + i; <br>\n <br>\n }); <br>\n <br>\n })(i); <br>\n <br>\n } <br>\n <br>\n console.log([ <br>\n <br>\n array[0](), <br>\n <br>\n array[1](), <br>\n <br>\n ]) <br>\n <br>\n [18, 16], так как за счет функции <br>\n <br>\n (function (i) {})(i); <br>\n <br>\n создает замыкание, var i = i — уже принадлежат областям видимости в\n замыканиях. <br>\n <br>\n function() { return i + i; } <br>\n <br>\n в начале поищет в своей области видимости i, не найдя, подымется на уровень\n выше и там найдет его. Из функции вернется сумма, которая будет положена в\n массив последним элементом."
      ],
      "link": []
    },
    "difficulty": "junior"
  },
  {
    "id": "R5jB5haIzXlVWwJp7QmM",
    "description": "",
    "popularity": null,
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">L - Liskov substitution principle - принцип\n подстановки, обьекты нследники должны иметь туже логику</div>\n </div>",
    "type": null,
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "difficulty": null,
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee507"
    }
  },
  {
    "id": "REc4jqjCIcc7wLnvZKg5",
    "question": "Задача:\n Сумма вершин дерева",
    "popularity": null,
    "type": "question",
    "competence": [
      "javascript"
    ],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ba"
    },
    "difficulty": "junior",
    "answer": {
      "text": [
        "Очень\n похоже на предыдущую задачу, только требуется найти сумму значений. <br>\n Через рекурсию: <br>\n function getTreeSum(node) { <br>\n let sum = node.value; <br>\n if (Array.isArray(node.children)) { <br>\n node.children.forEach(item =&gt; sum += getTreeSum(item)); <br>\n } <br>\n return sum; <br>\n } <br>\n Как видно не только задача, но и её решение практически идентичны\n предыдущей задаче. <br>\n Также, как и предыдущую её можно решить без рекурсии, обойдясь циклом,\n приводить его не буду, т.к. оно тоже практически идентично предыдущей задаче."
      ],
      "link": [],
      "code": []
    }
  },
  {
    "id": "RIWB91aVtLtPlyWVuwWH",
    "question": "В чем разлиция Dump components/smart components?",
    "competence": [
      "common questions",
      "javascript",
      "frontend"
    ],
    "type": "question",
    "description": "Глупый и умный компоненты",
    "difficulty": "middle",
    "answer": {
      "text": [
        "В одном логика, в другом отображение"
      ],
      "code": [],
      "link": []
    },
    "popularity": "5"
  },
  {
    "id": "RKykKx8IpQoDHQLI8Bty",
    "question": "Какие\n вы знаете методы запрета обтекания (clearing) и в каких случаях они\n применяются?",
    "difficulty": "junior",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "1\n <br>\n .clear { <br>\n 2 <br>\n clear:both; <br>\n 3 <br>\n font-size:0; <br>\n 4 <br>\n overflow:hidden; /* для IE */ <br>\n 5 <br>\n } <br>\n 1 <br>\n .wraprightcol:after { <br>\n 2 <br>\n content: \".\"; <br>\n 3 <br>\n display: block; <br>\n 4 <br>\n height: 0; <br>\n 5 <br>\n clear: both; <br>\n 6 <br>\n visibility: hidden; <br>\n 7 <br>\n }"
      ]
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee473"
    },
    "description": ""
  },
  {
    "id": "Rg7UphtQow2bbE66VC4H",
    "description": "",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "var\n arr = ['kot', 'tok', 'okt'], <br>\n arr1 = ['kot', 'tok', 'ott']; <br>\n function sameWords(arr) { <br>\n var word1, word2; <br>\n for (var i = 0; i &lt; arr.length-1; i++) { <br>\n word1 = 0; <br>\n word2 = 0; <br>\n if (arr[i].length !== arr[i+1].length) { <br>\n return false; <br>\n } else { <br>\n for (var j = 0; j &lt; arr[i].length; j++) { <br>\n word1 += arr[i][j].charCodeAt(0); <br>\n word2 += arr[i+1][j].charCodeAt(0); <br>\n } <br>\n if (word1 !== word2) { <br>\n return false; <br>\n } <br>\n } <br>\n } <br>\n return true; <br>\n } <br>\n console.log(sameWords(arr)); <br>\n console.log(sameWords(arr1)); <br>\n "
      ]
    },
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee493"
    },
    "question": "Есть\n несколько слов, определить состоят ли они из одних и тех же букв('кот',\n 'ток', 'окт')"
  },
  {
    "id": "RqDGmtmHF4si2DEiK495",
    "answer": {
      "text": [
        "Необходимо\n написать функцию, принимающую в аргументах две строки и возвращающую true,\n если эти строки состоят из идентичных букв и false в противном случае. <br>\n Например: <br>\n isEqualSymbols('кот', 'ток'); // =&gt; true <br>\n isEqualSymbols('кот', 'тик'); // =&gt; false <br>\n function isEqualSymbols(str1, str2) { <br>\n if (str1.length !== str2.length) { <br>\n return false; <br>\n } <br>\n if (str1.split('').sort().join('') === str2.split('').sort().join('')) {\n <br>\n return true; <br>\n } <br>\n return false; <br>\n } <br>\n Этот вариант решения исходит из того, что каждый символ уникален сам по\n себе и если в одной из строк встречаются повторяющиеся символы, а в другой\n нет, то это разные наборы символов и в результате должно вернуться false.\n <br>\n Если же будет необходимо исходить из того, что символы не уникальны сами по\n себе и повторные символы должны игнорироваться, то можно предварительно\n уникализировать символы в обоих строках, воспользовавшись одним из решений из\n задачи об уникализации значений в массиве. <br>\n "
      ],
      "link": [],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "type": "question",
    "description": "",
    "question": "Задача:\n Идентичный алфавит",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4bc"
    }
  },
  {
    "id": "RrNUIEE4Z0zrCLtpygqB",
    "description": "",
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">Компиляторы: AOT agead-of-time(компилируют до\n выполнения); JIT - Just-in-time</div>\n </div>",
    "popularity": null,
    "type": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4fe"
    },
    "difficulty": null,
    "competence": [],
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    }
  },
  {
    "id": "Rtwe49c4cPQM9fnDdgz5",
    "description": "",
    "answer": {
      "text": [
        "function\n f() { console.log(this.x); } <br>\n var obj = {x: 'bar'}; <br>\n f.call(obj, a, b); <br>\n f.apply(obj, [a, b]); <br>\n obj.funk = function f() { console.log(this.x); } <br>\n obj.funk(); <br>\n function f() { console.log(this.x); }.bind(obj, a, b); <br>\n f(); <br>\n "
      ],
      "code": [],
      "link": []
    },
    "question": "Есть\n функция и объект. Напишите все известные вам способы, чтобы вывести в консоли\n значение x из объекта используя функцию",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4aa"
    },
    "difficulty": "junior",
    "popularity": null
  },
  {
    "id": "S0q7lzF1EcXNgChtwzag",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee522"
    },
    "type": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "question": "В\n чем заключается отличие классов в JS от классов в других языках",
    "popularity": null,
    "competence": [],
    "description": ""
  },
  {
    "id": "S9XIZVzXtSNTGWwgNAEt",
    "difficulty": null,
    "popularity": null,
    "question": "В\n чем отличие null и undefined",
    "type": null,
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee50b"
    },
    "description": "",
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    }
  },
  {
    "id": "SJfN776ZphQm0ecma3wC",
    "description": "",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c1"
    },
    "question": "Вопрос:\n Назовите известные вам HTTP-методы. Что такое CRUD?",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Про\n HTTP-методы и CRUD: <br>\n GET — read — используется только для получения данных. <br>\n POST — create — создание новых сущностей. <br>\n PUT/PATCH — update — обновление данных. <br>\n DELETE — delete — удаление. <br>\n Вообще HTTP-методов сильно больше, помимо выше перечисленных есть OPTIONS,\n HEAD, TRACE и др. <br>\n "
      ]
    },
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "type": "question"
  },
  {
    "id": "SuWzKPWtDqZdedCDgAns",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "competence": [],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee517"
    },
    "question": "Что\n такое чистая функция",
    "difficulty": null,
    "popularity": null,
    "type": null
  },
  {
    "id": "T32KrdVYwNTq8qqpADfz",
    "popularity": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "LocalStorage:\n <br>\n Хранит данные постоянно, так как дата истечения срока хранения информации\n не устанавливается. Очищается исключительно через средства, предоставляемые\n JavaScript или посредством очистки кэша браузера и локально сохраненных\n данных в настройках браузера. <br>\n Самый большой объем хранения данных среди всех трех технологий <br>\n SessionStorage: <br>\n Объект sessionStorage хранит данные только в рамках сессии, т.е. это\n означает, что данные сохраняются до тех пор пока не закрыт браузер или\n вкладка браузера. <br>\n Данные никогда не отправляются на сервер. <br>\n Объем для сохранения данных намного больше чем у Cookie - по крайней мере\n 5MB. <br>\n Cookie: <br>\n Хранит данные, которые должны быть отправлены на сервер с последующими\n запросами. Срок экспирации различающийся, в зависимости от типа и\n продолжительности срока хранения, может быть установлен либо на стороне\n сервера или на стороне клиента (хотя, как правило, на стороне сервера).\n <br>\n Cookie, в первую очередь, предназначены для чтения на стороне сервера,\n однако могут быть прочитаны и на стороне клиента. В свою очередь localStorage\n и sessionStorage могут быть прочитаны только на стороне клиента. <br>\n Размер должен быть менее 4KB. <br>\n Cookie можно сделать защищенными, установив флаг httpOnly равным true. Это\n приведет к недоступности Cookie на стороне клиента. <br>\n "
      ]
    },
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee46c"
    },
    "description": "",
    "question": "Объясните\n разницу между cookie, sessionStorage и localStorage.",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "T6OPQ2651SVw9XCpVQZH",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee51a"
    },
    "difficulty": null,
    "description": "",
    "competence": [],
    "question": "Зачем\n нам нужны стрелочные функции",
    "type": null,
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    }
  },
  {
    "id": "T9EdVPQ9uYvl6PtjOrtL",
    "question": "Какое\n значение возвращает данное выражение?",
    "competence": [
      "javascript"
    ],
    "description": "",
    "popularity": null,
    "type": "question",
    "answer": {
      "text": [
        "\"i'm\n a lasagna hog\".split(\"\").reverse().join(\"\");\n reversed"
      ],
      "code": [],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee484"
    },
    "difficulty": "junior"
  },
  {
    "id": "TYcFcGe1tRmFXE6TV5tZ",
    "question": "Палиндром",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c2"
    },
    "answer": {
      "code": [],
      "text": [
        "const\n palindrome = str =&gt; { <br>\n // Меняем регистр строки на нижний <br>\n str = str.toLowerCase() <br>\n // Переворачиваем строку и возвращаем результат сравнения <br>\n return str === str.split('').reverse().join('') <br>\n } <br>\n "
      ],
      "link": []
    },
    "popularity": null
  },
  {
    "id": "TZudOEUrffTB5VTPbJbh",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4bb"
    },
    "question": "Задача:\n Сортировка нечётных.",
    "popularity": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Необходимо\n написать функцию, принимающую в аргументах массив и возвращающую новый\n массив, в котором отсортированы все нечетные числа по возрастанию, в то время\n как чётные остаются на своих местах. <br>\n Например: <br>\n oddSort([7, 3, 4, 9, 5, 2, 17]); // =&gt; [3, 5, 4, 7, 9, 2, 17] <br>\n function oddSort(arr) { <br>\n arr.forEach((item, index) =&gt; { <br>\n if (item % 2 === 1) { <br>\n let sortNumber = item; <br>\n for (let i = 0; i &lt; index; i++) { <br>\n if (arr[i] % 2 === 1) { <br>\n if (arr[i] &gt; sortNumber) { <br>\n const tmp = sortNumber; <br>\n <br>\n sortNumber = arr[i]; <br>\n arr[i] = tmp; <br>\n } <br>\n } <br>\n } <br>\n arr[index] = sortNumber; <br>\n } <br>\n }); <br>\n return arr; <br>\n } <br>\n "
      ]
    },
    "type": "question",
    "competence": [
      "javascript"
    ],
    "description": "",
    "difficulty": "junior"
  },
  {
    "id": "TvjoTPf1M4A8tCS2bQT1",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee485"
    },
    "question": "Чему\n равно window.foo?",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "(\n window.foo || ( window.foo = \"bar\" ) ); bar"
      ],
      "code": []
    },
    "type": "question",
    "difficulty": "junior",
    "description": ""
  },
  {
    "id": "U4CpZFMrXIlowyFMu6Gn",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c5"
    },
    "type": "question",
    "answer": {
      "text": [
        "const\n findVowels = str =&gt; { <br>\n let count = 0 <br>\n const vowels = ['a', 'e', 'i', 'o', 'u'] <br>\n for(let char of str.toLowerCase()) { <br>\n if(vowels.includes(char)) { <br>\n count++ <br>\n } <br>\n } <br>\n return count <br>\n } <br>\n или <br>\n const findVowels = str =&gt; { <br>\n const matches = str.match(/[aeiou]/gi) <br>\n return matches ? matches.length : 0 <br>\n } <br>\n "
      ],
      "link": [],
      "code": []
    },
    "question": "Найти\n гласные",
    "description": "",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "U7ygidSaC4sw1CE0a24O",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d8"
    },
    "competence": [],
    "type": null,
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "popularity": null,
    "question": "call\n stack",
    "difficulty": null
  },
  {
    "id": "UhBzHD9HIzRruSCG2TOJ",
    "difficulty": "junior",
    "popularity": null,
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events",
        "http://html5doctor.com/server-sent-events/#api",
        "https://www.html5rocks.com/en/tutorials/eventsource/basics/",
        "https://jaxenter.com/tutorial-jsf-2-and-html5-server-sent-events-104548.html"
      ],
      "code": [],
      "text": [
        "Long-Polling\n <br>\n Клиент запрашивает веб-страницу с сервера с использованием обычного HTTP\n (см. HTTP выше). <br>\n Клиент получает запрошенную веб-страницу и выполняет JavaScript на\n странице, которая запрашивает файл с сервера. <br>\n Сервер не сразу отвечает запрошенной информацией, но ждет, пока не появится\n новая информация. <br>\n Когда появится новая информация, сервер отвечает новой информацией. <br>\n Клиент получает новую информацию и немедленно отправляет другой запрос на\n сервер, повторно запуская процесс. <br>\n <br>\n События, отправленные сервером HTML5 (SSE)/EventSource: <br>\n Клиент запрашивает веб-страницу с сервера с использованием обычного HTTP\n (см. HTTP выше). <br>\n Клиент получает запрошенную веб-страницу и выполняет JavaScript на\n странице, которая открывает соединение с сервером. <br>\n Сервер отправляет событие клиенту, когда появляется новая информация.\n <br>\n <br>\n Трафик реального времени от сервера к клиенту, в основном, что вам нужно\n <br>\n Вы хотите использовать сервер с циклом событий <br>\n Невозможно установить соединение с сервером из другого домена"
      ]
    },
    "competence": [
      "javascript"
    ],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee47e"
    },
    "question": "В\n чём различия между Long-Polling, Websockets и Server-Sent Events?",
    "type": "question"
  },
  {
    "id": "UnabASaTYucvVPyMNeX2",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b7"
    },
    "type": "question",
    "question": "Задача:\n «Расплющивание» массива.",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "difficulty": "junior",
    "answer": {
      "code": [],
      "text": [
        "Необходимо\n написать функцию, принимающую в аргументах многомерный массив неограниченной\n вложенности и возвращающую новый одномерный массив, состоящий из элементов со\n всех уровней вложенности исходного массива. <br>\n Например: <br>\n flat([1, [2, [3, [4,5]]]]); // =&gt; [1, 2, 3, 4, 5] <br>\n function flat(arr) { <br>\n let res = []; <br>\n arr.forEach((item) =&gt; { <br>\n if (Array.isArray(item)) { <br>\n res = res.concat(flat(item)); <br>\n } else { <br>\n res.push(item); <br>\n } <br>\n }); <br>\n return res; <br>\n } <br>\n Есть нативный метод — Array.prototype.flat <br>\n Я считаю, что именно с него надо начать ответ на этот вопрос, и только\n когда (именно когда, а не если) интервьюер скажет, что такое решение ему не\n подходит и нужно всё сделать руками, приниматься за вышеупомянутое решение\n через рекурсию. <br>\n [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]].flat(Infinity); <br>\n "
      ],
      "link": []
    }
  },
  {
    "id": "VIK0KX8Q1CwLcOENLY0u",
    "question": "На\n что необходимо обратить внимание при разработке мультиязычных сайтов?",
    "description": "",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Особенности\n SEO-оптимизации мультиязычных ресурсов <br>\n переключение языка <br>\n домены поддомены и т.д. <br>\n "
      ]
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee469"
    },
    "difficulty": "junior",
    "popularity": null
  },
  {
    "id": "VWapaAyfOMLCU5w44XAg",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a3"
    },
    "type": "question",
    "question": "Сортировка\n пузырьком.",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "var\n m = [1, 7, 5, 13, 8], <br>\n count = m.length - 1, <br>\n max; <br>\n for (var i = 0; i &lt; count; i++) { <br>\n for (var j = 0; j &lt; count - i; j++) { <br>\n if (m[j] &gt; m[j + 1]) { <br>\n max = m[j]; <br>\n m[j] = m[j + 1]; <br>\n m[j + 1] = max; <br>\n } <br>\n } <br>\n } <br>\n "
      ]
    },
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "description": "",
    "popularity": null
  },
  {
    "id": "VsLryjhw5GhFf8xnDzly",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Asynchronous\n Module Definition или AMD <br>\n //Вызов функции define с массивом зависимостей и фабричной функцией <br>\n define(['dep1', 'dep2'], function (dep1, dep2) { <br>\n <br>\n //Определение модуля с помощью возвращаемого значения <br>\n return function () {}; <br>\n }); <br>\n CommonJS <br>\n Формат CommonJS применяется в Node.js и использует для определения\n зависимостей и модулей require и module.exports: <br>\n <br>\n var dep1 = require('./dep1'); <br>\n var dep2 = require('./dep2'); <br>\n <br>\n module.exports = function(){ <br>\n // ... <br>\n } <br>\n "
      ]
    },
    "difficulty": "junior",
    "question": "Что\n вы думаете о AMD против CommonJS?",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee47a"
    },
    "description": ""
  },
  {
    "id": "WFjL8rcGHJpVMEG8TYaY",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "popularity": null,
    "question": "Вообще\n вопросы на setTimeout и setInterval весьма актуальны.Меня спрашивали: «Какое\n минимальное время можно задать?»",
    "description": "",
    "answer": {
      "text": [
        "В\n каждом браузере есть свой минимум, если вы указываете меньше него, то все\n равно задержка будет не меньше минимуму. Иногда даже и больше указанного\n времени, так как задача попадает в очередь и время складывается из заданного\n плюс затраты в на выполнение на задач в очереди перед ней.<br>\n Не давно выделили целую статью для этого примера(тут), читатели в\n комментариях расписывали всевозможные способы решения, от традиционных до\n фантастических. Вот о которых я обычно рассказывала на собеседованиях. <br>\n for (var i = 0; i &lt; 10; i++) { <br>\n setTimeout(function () { <br>\n console.log(i); <br>\n }, 100); <br>\n } <br>\n Что будет выведено в консоль, как можно модифицировать пример что бы он\n возвращал правильный результат(назовите как можно больше способов)? <br>\n for (var i = 0; i &lt; 10; i++) { <br>\n (function (i) { <br>\n setTimeout(function () { <br>\n console.log(i); <br>\n }, 100); <br>\n })(i) <br>\n } <br>\n es6 <br>\n for (let i = 0; i &lt; 10; i++) { <br>\n setTimeout(function () { <br>\n console.log(i); <br>\n }, 100); <br>\n } <br>\n "
      ],
      "code": [],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee497"
    }
  },
  {
    "id": "WNryGHLapTlPcip1CXIX",
    "description": "",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "question": "Объясните,\n почему это не является IIFE: `function foo(){ }();`. Что необходимо изменить,\n чтобы это стало IIFE??",
    "difficulty": "junior",
    "popularity": "5",
    "_id": {
      "$oid": "60de0704e2c8c53194aee434"
    },
    "answer": {
      "link": [
        "http://lucybain.com/blog/2014/immediately-invoked-function-expression/",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void"
      ],
      "code": [],
      "text": [
        "IIFE\n расшифровывается как Immediately Invoked Function Expression — немедленно\n вызываемое функциональное выражение. Синтаксический анализатор JavaScript\n читает function foo(){ } (); как function foo(){ } и ();, где первое\n выражение — это объявление функции, а второе (пара скобок) — попытка вызова\n функции, но так как имя не указано, он выдает ошибку Uncaught SyntaxError:\n Unexpected token.<br>\n Вот два способа исправить это, которые заключаются добавление\n дополнительных скобок: (function foo(){ })() и (function foo(){ }()).\n Выражения, начинающиеся с function, считаются объявлениями функций.\n Оборачивая эту функцию внутри (), она становится функциональным выражением,\n которое затем может быть выполнено с последующим (). Подобные функции не\n отображаются в глобальной области видимости, и вы можете даже не указывать им\n имя, если вы не будете на них ссылаться.<br>\n Вы также можете использовать оператор void — void function foo(){ }(). К\n сожалению, с таким подходом есть одна проблема. Выполнение данного выражения\n всегда возвращает undefined, поэтому, если ваше IIFE возвращает что-либо, вы\n не можете его использовать. Пример: <br>\n const foo = void function bar() { return ‘foo’; }(); <br>\n console.log(foo); // undefined <br>\n "
      ]
    }
  },
  {
    "id": "WQwbUHRepRXAfn9xNahh",
    "question": "run-to-completion\n model",
    "type": null,
    "difficulty": null,
    "description": "",
    "popularity": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ee"
    },
    "competence": []
  },
  {
    "id": "WX2pmUi8XHMnQbbHjTPQ",
    "popularity": null,
    "competence": [],
    "difficulty": null,
    "question": "service\n worker",
    "type": null,
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e1"
    },
    "description": ""
  },
  {
    "id": "WYydSIPgp5WmYWLYkUyk",
    "_id": {
      "$oid": "60de0704e2c8c53194aee513"
    },
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "description": "",
    "difficulty": null,
    "competence": [],
    "type": null,
    "question": "Прототипы\n и прототипное наследование"
  },
  {
    "id": "Wgasyfk7YnSpOLtE1Sx8",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee462"
    },
    "question": "Для\n чего используются статические члены класса?",
    "popularity": null,
    "type": "question",
    "description": "",
    "answer": {
      "text": [
        "Члены\n статических классов (свойства/методы) не привязаны к конкретному экземпляру\n класса и имеют одинаковое значение вне зависимости от того, какой экземпляр\n ссылается на них. Статические свойства обычно являются конфигурационными\n переменными, а статические методы обычно являются чисто служебными функциями,\n которые не зависят от состояния экземпляра."
      ],
      "code": [],
      "link": [
        "https://stackoverflow.com/questions/21155438/when-to-use-static-variables-methods-and-when-to-use-instance-variables-methods"
      ]
    }
  },
  {
    "id": "Ww5uR6yI6DwW8eTrhGjN",
    "type": "question",
    "popularity": "3",
    "description": "shift alt ",
    "answer": {
      "text": [
        "При нажатии на блок и получении эвента эта информация хранится в window.event"
      ],
      "code": [
        "let onkeydown = (function (ev) {\n  var key;\n  var isShift;\n  if (window.event) {\n    key = window.event.keyCode;\n    isShift = !!window.event.shiftKey; // typecast to boolean\n  } else {\n    key = ev.which;\n    isShift = !!ev.shiftKey;\n  }\n  if ( isShift ) {\n    switch (key) {\n      case 16: // ignore shift key\n        break;\n      default:\n        alert(key);\n        // do stuff here?\n        break;\n    }\n  }\n});"
      ],
      "link": []
    },
    "question": "Как определить нажат ли shift или alt при щелчке на элемент?",
    "competence": [
      "javascript",
      "html",
      "css"
    ],
    "difficulty": "junior"
  },
  {
    "id": "XCa3SCIWkZrjlLXwYtFM",
    "_id": {
      "$oid": "60de0704e2c8c53194aee51e"
    },
    "popularity": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "description": "",
    "question": "Зачем\n нужен use strict",
    "type": null,
    "competence": [],
    "difficulty": null
  },
  {
    "id": "XcRb3oIp67RTnu3s9bou",
    "popularity": "5",
    "_id": {
      "$oid": "60de0704e2c8c53194aee433"
    },
    "type": "question",
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "Оба\n являются способами реализации системы модулей, которая изначально не\n присутствовала в JavaScript до появления ES2015. CommonJS является\n синхронным, в то время как AMD (Asynchronous Module Definition, асинхронное\n определение модуля) — соответственно, асинхронным. CommonJS разработан с\n учетом разработки на стороне сервера, в то время как AMD с поддержкой\n асинхронной загрузки модулей больше предназначена для браузеров.<br>\n Я считаю синтаксис AMD довольно многословным, а CommonJS ближе к стилю,\n который используется в выражениях импорта в других языках. В большинстве\n случаев я считаю AMD ненужным, потому что если вы разместите весь свой код в\n одном объединенном файле, то вы не сможете воспользоваться свойствами\n асинхронной загрузки. Кроме того, синтаксис CommonJS ближе к стилю написания\n модулей Node, и поэтому происходит меньше путаницы при переключении между\n клиентской и серверной разработкой на JavaScript.<br>\n Я рад, что с появлением модулей ES2015, которые поддерживают как\n синхронную, так и асинхронную загрузку, мы, наконец, можем придерживаться\n одного подхода. Несмотря на то, что они не полностью поддерживаются во всех\n браузерах и Node, мы можем использовать транспайлеры для преобразования\n нашего кода."
      ],
      "link": [
        "https://auth0.com/blog/javascript-module-systems-showdown/",
        "https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs"
      ]
    },
    "difficulty": "middle",
    "competence": [
      "javascript",
      "typescript"
    ],
    "question": "Что\n вы думаете о AMD против CommonJS?"
  },
  {
    "id": "Xf8FEbaV4AThhZz3ah0U",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "Уменьшите\n размер страниц сайта Слишком «тяжелый» контент долго загружается. ... <br>\n Снизьте «вес» графики ... <br>\n Упростите код JavaScript и CSS. ... <br>\n Уменьшите число запросов браузера ... <br>\n Сократите расстояние между сайтом и пользователями <br>\n <br>\n FOUC <br>\n Flash of unstyled content"
      ],
      "link": []
    },
    "question": "Как\n можно оптимизировать загрузку внешних ресурсов на странице?",
    "type": "question",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee464"
    }
  },
  {
    "id": "XpP7FIlYR1Od177wi3Or",
    "competence": [
      "javascript"
    ],
    "answer": {
      "code": [],
      "text": [
        "Тут\n делается упор на проверку знаний об arguments, но иногда заходят ещё дальше и\n просят рассказать каким образом работает\n Array.prototype.slice.call(arguments). <br>\n Ответ: <br>\n function isThreePassed(){ <br>\n const args = Array.prototype.slice.call(arguments); <br>\n return args.indexOf(3) != -1; <br>\n } <br>\n isThreePassed(1,2) //false <br>\n isThreePassed(9,3,4,9) //true <br>\n Как мы знаем, arguments не массив, а обычный объект, поэтому у него нет\n такого полезного метода как indexOf. Для этого используется\n Array.prototype.slice.call(arguments), который делает из argument — &gt;\n array. <br>\n .call() и .apply() позволяют явно установить this в функции. И если\n передать argument как this, то slice будет работать с ним как с обычным массивом.\n <br>\n А вот интересный эксперимент: <br>\n const o = { <br>\n '0': 'zero', <br>\n '1': 'one' <br>\n }; <br>\n [].slice.call(o); // []; <br>\n const oo = { <br>\n '0': 'zero', <br>\n '1': 'one', <br>\n length: 2 <br>\n }; <br>\n [].slice.call(oo); // [\"zero\", \"one\"]; <br>\n "
      ],
      "link": []
    },
    "type": "question",
    "popularity": null,
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c8"
    },
    "difficulty": "junior",
    "question": "Напишите\n простую функцию, чтобы узнать равен ли один из входных параметров 3."
  },
  {
    "id": "Xu6eYCpTWqAJfO7CG0y6",
    "competence": [],
    "question": "Inline\n caches",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ff"
    },
    "description": "",
    "type": null,
    "popularity": null,
    "difficulty": null,
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    }
  },
  {
    "id": "XveGPjVwrTQWsnKM3WOl",
    "popularity": null,
    "answer": {
      "text": [
        "нет"
      ],
      "link": [],
      "code": []
    },
    "type": "question",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee495"
    },
    "question": "У\n нас есть три запроса к серверу, один возвращает нам имя пользователя, второй\n его данные, а третий изображение для аватарки, мы для каждого запроса\n используем по промису, объединяя их в цепочку, что будет если в одном из\n запросов произойдет ошибка, довыполнится ли цепочка?",
    "description": "",
    "difficulty": "junior"
  },
  {
    "id": "Y6frOvSNhI909hurbqh6",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee498"
    },
    "type": "question",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "question": "Надо\n написать функцию, которая вернет «hello world», но при этом в теле функции\n нельзя использовать ни цифры, ни буквы, а циклы, массивы, объекты можно, но\n без цифр.",
    "description": "",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    }
  },
  {
    "id": "YBcCK2OYgvctae57UV2V",
    "answer": {
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded",
        "https://developer.mozilla.org/en-US/docs/Web/Events/load"
      ],
      "text": [
        "Событие\n DOMContentLoaded вызывается, когда исходный HTML-документ полностью загружен\n и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и\n скриптов. <br>\n Событие load происходит только после загрузки DOM и всех зависимых\n ресурсов. <br>\n "
      ]
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "popularity": null,
    "question": "В\n чем разница между событием `load` и событием `DOMContentLoaded`?",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee447"
    },
    "difficulty": "junior"
  },
  {
    "id": "YEi4lssbwoXnDN7a8iHG",
    "question": "Для\n чего используется атрибут srcset в теге изображения? Опишите процесс, который\n использует браузер при оценке содержимого этого атрибута.",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Однако\n есть два новых атрибута — srcset and sizes — позволяющих добавить\n дополнительные изображения с пометками, чтобы браузер выбрал подходящее.\n <br>\n &lt;img srcset=\"elva-fairy-320w.jpg 320w, <br>\n elva-fairy-480w.jpg 480w, <br>\n elva-fairy-800w.jpg 800w\" <br>\n sizes=\"(max-width: 320px) 280px, <br>\n (max-width: 480px) 440px, <br>\n 800px\" <br>\n src=\"elva-fairy-800w.jpg\" alt=\"Elva dressed as a\n fairy\"&gt; <br>\n "
      ]
    },
    "difficulty": "junior",
    "type": "question",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee470"
    }
  },
  {
    "id": "YJbnA0B81yan73vwuF1f",
    "type": "question",
    "difficulty": "junior",
    "question": "Объясните\n разницу при использовании `foo` в `function foo() {}` и `var foo = function()\n {}`",
    "_id": {
      "$oid": "60de0704e2c8c53194aee457"
    },
    "answer": {
      "text": [
        "Первое\n — объявление функции, а второе — функциональное выражение. Ключевое отличие\n состоит в том, что тело функции при объявлении поднимается наверх, а тело\n функциональных выражений — нет (они имеют такое же поведение поднятия, что и\n переменные). Для получения более подробной информации, обратитесь к вопросу\n выше о поднятии. Если вы попытаетесь вызвать выражение функции до того, как\n оно будет определено, вы получите ошибку Uncaught TypeError: XXX is not a\n function. <br>\n Объявление функции <br>\n foo(); // 'FOOOOO' <br>\n function foo() { <br>\n console.log('FOOOOO'); <br>\n } <br>\n Функциональное выражение <br>\n foo(); // Uncaught TypeError: foo is not a function <br>\n var foo = function() { <br>\n console.log('FOOOOO'); <br>\n };"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function"
      ],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "description": ""
  },
  {
    "id": "YNlFSfIcpydHvv4cqJS4",
    "answer": {
      "code": [],
      "text": [
        "чтобы работал position: absolute надо чтобы парент был в position: relative"
      ],
      "link": []
    },
    "popularity": "4",
    "difficulty": "beginner",
    "description": "Абсолютное позиционирование",
    "type": "question",
    "competence": [
      "css"
    ],
    "question": "Как сделать, чтобы работал position:absolute ?"
  },
  {
    "id": "YTjeq3XdngVd4X0dnOOa",
    "_id": {
      "$oid": "60de0704e2c8c53194aee43e"
    },
    "type": "question",
    "question": "В\n каких случаях используется `document.write()`?",
    "popularity": "3",
    "competence": [
      "typescript"
    ],
    "difficulty": "junior",
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "document.write()\n записывает строку текста в поток документа, открытого при помощи\n document.open(). Когда document.write() выполняется после загрузки страницы,\n он вызывает document.open, который очищает весь документ\n (&lt;head&gt;и&lt;body&gt; будут удалены!) и заменяет содержимое на заданное\n значение параметра. Подобный подход считается опасным и не рекомендуется его\n использовать. <br>\n В Интернете есть несколько ответов, которые объясняют, что document.write()\n используется в коде отслеживания или когда вы хотите добавить стили, которые\n должны работать только при включенном JavaScript. Он даже используется в\n шаблоне HTML5 для параллельной загрузки скриптов и сохранения порядка\n выполнения! Тем не менее, я подозреваю, что эти причины могут быть устаревшими,\n и в наши дни они могут быть достигнуты без использования document.write().\n Пожалуйста, поправьте меня, если я ошибаюсь по этому поводу."
      ],
      "link": [
        "https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html",
        "https://github.com/h5bp/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag"
      ]
    }
  },
  {
    "id": "YZx5Im7LiUTnEKSpL0vp",
    "question": "Какая очередности написания тестов функций в jest?",
    "difficulty": "senior",
    "description": "Порядок, обертки, jest",
    "type": "question",
    "popularity": "5",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "jest test => describe(test(expect()))"
      ]
    },
    "competence": [
      "javascript",
      "typescript",
      "frontend"
    ]
  },
  {
    "id": "Z2NpvdP0neb1fvYhhEqf",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4de"
    },
    "question": "block\n scope",
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "description": "",
    "difficulty": null,
    "type": null
  },
  {
    "id": "Z5m64K7GZVSkPBZcNXtD",
    "question": "В\n чем разница между host-объектами и нативными объектами?",
    "description": "",
    "difficulty": "junior",
    "answer": {
      "text": [
        "В\n чем разница между host-объектами и нативными объектами? <br>\n Нативные объекты — это объекты, которые являются частью языка JavaScript,\n определенного в спецификации ECMAScript, такие как String, Math, RegExp,\n Object, Function и т.д. <br>\n Хост-объекты предоставляются средой выполнения (браузером или Node), такие\n как `window`, `XMLHTTPRequest` и т.д. <br>\n "
      ],
      "code": [],
      "link": [
        "https://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects"
      ]
    },
    "type": "question",
    "popularity": "4",
    "_id": {
      "$oid": "60de0704e2c8c53194aee43a"
    },
    "competence": [
      "typescript"
    ]
  },
  {
    "id": "ZKpgl7O5FgWlGDAvkOSp",
    "question": "global\n scope",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4dc"
    },
    "competence": [],
    "type": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "popularity": null,
    "description": ""
  },
  {
    "id": "ZZoezCwPkb44QGkK6NGY",
    "competence": [
      "common questions",
      "javascript"
    ],
    "type": "question",
    "difficulty": "junior",
    "popularity": "4",
    "description": "Performance ",
    "question": "Как использовать Performance в консоли браузера и зачем он нужен?",
    "answer": {
      "text": [
        "Записывает все действия и насколько они нагружают систему. Служит для оптимизации."
      ],
      "link": [],
      "code": []
    }
  },
  {
    "id": "ZfFB49EfJ3wmeYAB11ox",
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "function\n promiseAll(promises) { <br>\n return new Promise((resolve, reject) =&gt; { <br>\n const results = []; <br>\n let resolvedCount = 0; <br>\n <br>\n promises.forEach((promise, index) =&gt; { <br>\n promise <br>\n .then((result) =&gt; { <br>\n results[index] = result; <br>\n <br>\n resolvedCount++; <br>\n <br>\n if (resolvedCount === promises.length) { <br>\n resolve(results); <br>\n } <br>\n }) <br>\n .catch((err) =&gt; reject(err)); <br>\n }); <br>\n }); <br>\n }"
      ]
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b1"
    },
    "popularity": null,
    "question": "Реализовать\n аналог Promise.all."
  },
  {
    "id": "ZhEUysYfQXzUyGV2RZWx",
    "competence": [],
    "popularity": null,
    "description": "",
    "question": "Блочная\n область видимости, функциональная",
    "type": null,
    "difficulty": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee50f"
    }
  },
  {
    "id": "ZpzCEjbkhLvGtuxegn8u",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "description": "",
    "type": "question",
    "answer": {
      "code": [],
      "text": [
        "1\n минимизировать и склеить в один все js-файлы <br>\n 2 то же и с css <br>\n 3 собрать изображения в спрайты <br>\n 4 кеширование <br>\n а) файлы js и css кешируются навсегда( или на длительный период, к примеру\n на год), когда в них вносятся какие-то изменения, в результате разработки,\n меняется номер версии, браузер считает, что это новые файлы и закачивает их.\n Время кеширование содержится в заголовке expires. <br>\n б) файл кешируется до тех пор, пока в нем не произошли изменения. Когда\n пользователь в первый раз заходит на сайт, у него еще нет кеша, файлы\n закачиваются и в следующий раз, когда происходит обмен заголовками происходит\n анализ ETag(хеш суммы содержимого содержимого файла или хеш последнего\n времени изменения, или номер версии) Если он изменился, то закачивается, в\n противном случае, берется из хеша. <br>\n Так же можно брать заголовки с датой последней модификации(Last_Modifed),\n но это менее надежно. <br>\n в) можно сжать данные перед отправкой, решается настройкой конфига в nginx.\n Пример. Content-Encoding: gzip <br>\n г) можно разбить js на модули и на разных страницах подключать по мере\n необходимости."
      ],
      "link": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a1"
    },
    "question": "Ускорение\n загрузки страницы."
  },
  {
    "id": "aKrG2dSTvtNfcr3XwByE",
    "description": "",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee525"
    },
    "popularity": null,
    "competence": [],
    "type": null,
    "question": "Как\n мы можем эмулировать модули не используя ES modules/require",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    }
  },
  {
    "id": "aMEmlUXXtsD0FhPIx62Z",
    "competence": [
      "typescript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee443"
    },
    "type": "question",
    "answer": {
      "code": [],
      "text": [
        "Да.\n Handlebars, Underscore, Lodash, AngularJS, и JSX. Мне не нравилась\n шаблонизация в AngularJS, потому что там активно использовались строки в\n директивах и легко допустить ошибку при опечатке. JSX - мой новый фаворит,\n так как он ближе к JavaScript и почти не имеет дополнительного синтаксиса. В\n настоящее время вы даже можете использовать строковые литералы шаблонов\n ES2015 в качестве быстрого способа создания шаблонов, не полагаясь на\n сторонний код. <br>\n const template = `&lt;div&gt;My name is: ${name}&lt;/div&gt;`; <br>\n Однако следует помнить о возможном XSS в вышеприведенном подходе, поскольку\n содержимое не экранируется, в отличие от библиотек шаблонизации."
      ],
      "link": []
    },
    "difficulty": "junior",
    "description": "",
    "question": "Вы\n когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие\n библиотеки вы использовали?",
    "popularity": null
  },
  {
    "id": "aQcU4eB1x1sj4BMLdeoY",
    "difficulty": "junior",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4cc"
    },
    "question": "Как\n получить параметры из URL’а текущего окна?",
    "answer": {
      "link": [],
      "text": [
        "window.location.href\n <br>\n Как отмечено в комментариях, строка ниже работает, но она содержит ошибки\n для Firefox. <br>\n document.URL; <br>\n "
      ],
      "code": []
    },
    "popularity": null
  },
  {
    "id": "afqu7q3fcYHlmhdxMGS8",
    "answer": {
      "link": [],
      "text": [
        "Многим\n тегам стили прописаны по умолчанию, в процессе верстке нам приходится\n переопределять их. Что бы не делать это каждый раз, мы «скидываем» их\n «массово». Для этого заводим файл под стили, подключаем его первым или в\n первом стилевом файле, в самом верху указываем наши стили для базовых тегов.\n <br>\n К примеру. Мы часто используем список ul для верстки меню, для этого мы\n каждый раз вынуждены обнулять padding, margin и list-style-type. Можно один\n раз задать стили, и списки станут без внешней и внутренней границы, а так же\n без маркеров. <br>\n "
      ],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "description": "",
    "question": "Что\n такое ресет стилей?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee48f"
    },
    "popularity": null,
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "b10OcxRi0wgeFDXEAP74",
    "_id": {
      "$oid": "60de0704e2c8c53194aee453"
    },
    "competence": [
      "javascript"
    ],
    "question": "Каковы\n преимущества и недостатки написания JavaScript-кода на языке, который\n компилируется в JavaScript?",
    "popularity": null,
    "answer": {
      "link": [
        "https://softwareengineering.stackexchange.com/questions/72569/what-are-the-pros-and-cons-of-coffeescript"
      ],
      "code": [],
      "text": [
        "Вот\n несколько языков, которые компилируются в JavaScript: CoffeeScript, Elm,\n ClojureScript, PureScript и TypeScript. <br>\n Преимущества: <br>\n Исправляют некоторые давние проблемы в JavaScript и препятствует\n использованию анти-паттернов в JavaScript. <br>\n Позволяют писать более короткий код, предоставляя синтаксический сахар\n поверх JavaScript, которого, как мне кажется, не хватало в ES5, но с приходом\n ES2015 все изменилось. <br>\n Статическая типизация идеальна (в случае TypeScript) для больших проектов,\n которые необходимо поддерживать с течением времени. <br>\n Недостатки: <br>\n Необходима сборка/компиляция кода, так как браузеры запускают только\n JavaScript, и ваш код должен быть скомпилирован в JavaScript перед тем, как\n он будет передан в браузеры. <br>\n Отладка может быть трудной, если карты кода (source maps) плохо\n сопоставляются с исходным кодом. <br>\n Большинство разработчиков не знакомы с этими языками и должны будут изучить\n их. Если ваша команда будет использовать их для своих проектов, это приведет\n к увеличению затрат. <br>\n Меньшее сообщество (зависит от языка), что означает, что будет труднее\n найти ресурсы, учебные пособия, библиотеки и инструменты. <br>\n Может отсутствовать поддержка в IDE/редакторе. <br>\n Эти языки всегда будут позади последнего стандарта JavaScript. <br>\n Разработчики должны знать, во что компилируется их код — потому что это то,\n что будет запускаться в браузере, и это наиболее важно. <br>\n По большому счету, ES2015 значительно улучшил JavaScript и сделал\n разработку на нем намного удобнее. Я не вижу причин использовать CoffeeScript\n в наши дни."
      ]
    },
    "difficulty": "junior",
    "description": "",
    "type": "question"
  },
  {
    "id": "bW3Aa4QbC6vTf8QWILak",
    "question": "Для чего используется метод .fill(\"\")?",
    "popularity": "4",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"
      ],
      "code": [],
      "text": [
        "Заполняет там как-то матрицу и т.д."
      ]
    },
    "difficulty": "middle",
    "description": "Очень интересный метод в js"
  },
  {
    "id": "cCSDpoNw5Aq9HsJokfvo",
    "competence": [
      "javascript"
    ],
    "question": "var\n foo = {}; <br>\n foo.bar = 'hello'; <br>\n Вопрос: Чему равно foo.length? <br>\n ",
    "description": "",
    "popularity": null,
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ce"
    },
    "type": "question",
    "answer": {
      "text": [
        "Ответ:\n undefined"
      ],
      "link": [],
      "code": []
    }
  },
  {
    "id": "cDMLvv0UTZ4wQD4kdEg1",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f8"
    },
    "popularity": null,
    "question": "Очереди",
    "competence": [],
    "type": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "difficulty": null
  },
  {
    "id": "cJLCRpQMlePmmVnvXstv",
    "answer": {
      "code": [],
      "text": [
        "var\n foo = []; <br>\n foo.push(1); <br>\n foo.push(2); <br>\n "
      ],
      "link": []
    },
    "popularity": null,
    "question": "Чему\n равно foo.length?",
    "competence": [
      "javascript"
    ],
    "description": "",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee487"
    },
    "type": "question"
  },
  {
    "id": "cNzBEL9rTgXBU9MKBUJa",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e7"
    },
    "popularity": null,
    "question": "interpreter",
    "description": "",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "difficulty": null,
    "type": null
  },
  {
    "id": "ctWOJraQWirvFeNvKjkN",
    "_id": {
      "$oid": "60de0704e2c8c53194aee50c"
    },
    "question": "Логические\n операторы",
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "description": "",
    "type": null,
    "popularity": null,
    "competence": [],
    "difficulty": null
  },
  {
    "id": "dEGmPez38M6jlhnseqLy",
    "difficulty": null,
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee518"
    },
    "question": "В\n чем разница между function expression и function declaration",
    "type": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "description": "",
    "popularity": null
  },
  {
    "id": "dJqOteNwiJ3R8HaIeeLh",
    "description": "",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee449"
    },
    "answer": {
      "code": [],
      "text": [
        "Same-origin\n policy (принцип одинакового источника) не позволяет JavaScript выполнять\n запросы за границы домена. Источник определяется как комбинация схемы URI,\n имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию\n на одной странице получить доступ к конфиденциальным данным на другой через\n объектную модель документа этой страницы."
      ],
      "link": [
        "https://en.wikipedia.org/wiki/Same-origin_policy"
      ]
    },
    "question": "Объясните\n same-origin policy в контексте JavaScript",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "dPDSwD5hUUjVMBLGcCqY",
    "difficulty": "junior",
    "popularity": null,
    "question": "Реализовать\n функцию f: f(2, 3) -&gt; 5, при вызове f(2)(3), тоже вернет 5",
    "answer": {
      "text": [
        "function\n f(a, b) { <br>\n if (b !== undefined) { <br>\n return a + b; <br>\n } else { <br>\n return function (b) { <br>\n return a + b; <br>\n } <br>\n } <br>\n } <br>\n <br>\n f(1)(2)(3)() -&gt; 6, f(0)(3)(1)(5)() -&gt; 8 <br>\n function f(arg) { <br>\n var value = arg; <br>\n <br>\n return function (arg) { <br>\n if (arg !== undefined) { <br>\n return f(value + arg); <br>\n } else { <br>\n return value; <br>\n } <br>\n } <br>\n } <br>\n <br>\n foo(1)(2)(3) -&gt; 6 <br>\n function foo(value) { <br>\n var acc = value; <br>\n function addNext(next) { <br>\n acc += next; <br>\n return addNext; <br>\n } <br>\n addNext.toString = addNext.valueOf = function() { <br>\n return acc; <br>\n } <br>\n return addNext; <br>\n }"
      ],
      "link": [],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee49e"
    }
  },
  {
    "id": "dddhyHmaVahewS2e5HKD",
    "description": "",
    "popularity": null,
    "difficulty": "junior",
    "question": "Задача:\n Бомба",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4bd"
    },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Надо\n реализовать «бомбу» (в виде функции-конструктора), которая получает на входе\n время, через которое взорвется и некоторый «звук взрыва» (строку, которую\n вернет через заданное время). С фантазией задача. <br>\n function Bomb(message, delay) { <br>\n this.message = message; <br>\n setTimeout(this.blowUp.bind(this), delay * 1000); // взрываем через delay\n sec <br>\n } <br>\n Bomb.prototype.blowUp = function () { <br>\n console.log(this.message); <br>\n }; <br>\n new Bomb(\"Explosion!\", .5); <br>\n "
      ]
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "e6hs9rqEGcHT8xdsAw9H",
    "_id": {
      "$oid": "60de0704e2c8c53194aee494"
    },
    "type": "question",
    "description": "",
    "question": "И\n конечно вопрос на засыпку: «Каким образом можно обойтись без промисов?».",
    "popularity": null,
    "difficulty": "junior",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "По\n старинке, вводили переменную-счетчик и как-только наступало окончание\n очередного асинхронного действия, сравнивали переменную с общем количеством."
      ]
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "e9ro78D0jT8BUcHqLkq6",
    "difficulty": "junior",
    "question": "Задача:\n Уникализация значений в массиве.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b6"
    },
    "popularity": null,
    "type": "question",
    "description": "",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "text": [
        "Необходимо\n написать функцию, принимающую в аргументах массив целых чисел и возвращающую\n новый массив, состоящий только из уникальных значений первого массива. <br>\n Например: <br>\n unique([1, 1, 2, 2, 4, 2, 3, 7, 3]); // =&gt; [1, 2, 4, 3, 7] <br>\n Решение в лоб <br>\n function unique(arr) { <br>\n const res = []; <br>\n arr.forEach((item) =&gt; { <br>\n if (res.indexOf(item) === -1) { <br>\n res.push(item); <br>\n } <br>\n }); <br>\n return res; <br>\n } <br>\n Ожидания интервьюера <br>\n function unique(arr) { <br>\n const res = {}; <br>\n arr.forEach((item) =&gt; { <br>\n res[item] = ''; <br>\n }); <br>\n return Object.keys(res).map(item =&gt; Number(item)); <br>\n } <br>\n <br>\n Решение в одну строку <br>\n function unique(arr) { <br>\n return arr.filter((item, index, self) =&gt; (self.indexOf(item) ===\n index)); <br>\n }"
      ],
      "code": []
    }
  },
  {
    "id": "eWNLFepOhJPX1dDa53gM",
    "type": "question",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML"
      ],
      "code": [
        "const insert = document.querySelector('#insert');\ninsert.addEventListener('click', () => {\n  const subject = document.querySelector('#subject');\n  const positionSelect = document.querySelector('#position');\n  subject.insertAdjacentHTML(positionSelect.value, '<strong>inserted text</strong>');\n});\n\nconst reset = document.querySelector('#reset');\nreset.addEventListener('click', () => {\n  document.location.reload();\n});"
      ],
      "text": [
        "element.insertAdjacentHTML(position, text);\ninsertAdjacentHTML ('afterbegin', 'afterend', 'beforeend', 'beforebegin')"
      ]
    },
    "difficulty": "junior",
    "description": "insertAdjacentHTML",
    "question": "Что такое insertAdjacentHTML?",
    "popularity": "3",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "ejiNxIeYxixPueXnnYcy",
    "_id": {
      "$oid": "60de0704e2c8c53194aee436"
    },
    "question": "Что\n такое замыкание и как/для чего его используют?",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
        "https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36"
      ],
      "text": [
        "Замыкание\n — это комбинация функции и лексического окружения, в которой эта функция была\n объявлена. Слово “лексический” относится к тому факту, что лексическая\n область видимости использует место, где переменная объявлена в исходном коде,\n чтобы определить, где эта переменная доступна. Замыкания — это функции,\n которые имеют доступ к переменным внешней (замыкающей) функции — цепочке\n областей видимости даже после того, как внешняя функция вернулась.<br>\n Для чего его используют? <br>\n Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий.\n Обычно используется в модульном паттерне. <br>\n Частичное применение функций или каррирование. <br>\n "
      ],
      "code": []
    },
    "type": "question",
    "popularity": "4",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "description": ""
  },
  {
    "id": "emRK3e7MI8LCj0Mbaz4m",
    "difficulty": "junior",
    "description": "",
    "popularity": null,
    "question": "На\n собесе на прошлую работу мне попался вопрос: 'Что такое live/die'",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Где\n то из глубины сознания всплыло, что это аналог on/off, с помощью них можно\n навешивать/удалять обработчики на события их. Но более старые методы, по\n сравнению on/off. <br>\n В проекте я столкнулась с еще и с bind/unbind <br>\n "
      ]
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee49f"
    }
  },
  {
    "id": "enAJmMeGp96TLghWYeAE",
    "type": "question",
    "answer": {
      "text": [
        "function\n Promise(fn) { <br>\n this.thenHandlers = []; <br>\n this.catchHandlers = []; <br>\n this.isResolved = false; <br>\n this.isRejected = false; <br>\n setTimeout(() =&gt; fn(this.applyResolve.bind(this),\n this.applyReject.bind(this))); <br>\n } <br>\n Promise.prototype = { <br>\n applyResolve: function () { <br>\n this.thenHandlers.forEach((handler) =&gt; handler()); <br>\n this.isResolved = true; <br>\n }, <br>\n applyReject: function () { <br>\n this.catchHandlers.forEach((handler) =&gt; handler()); <br>\n this.isRejected = true; <br>\n }, <br>\n then: function (handler) { <br>\n if (this.isResolved) { <br>\n handler(); <br>\n } else { <br>\n this.thenHandlers.push(handler); <br>\n } <br>\n return this; <br>\n }, <br>\n catch: function (handler) { <br>\n if (this.isRejected) { <br>\n handler(); <br>\n } else { <br>\n this.catchHandlers.push(handler); <br>\n } <br>\n return this; <br>\n } <br>\n <br>\n }; <br>\n const p = new Promise((resolve, reject) =&gt; ( <br>\n Math.round(Math.random() * 10) % 2 === 0 <br>\n ? resolve() <br>\n : reject() <br>\n )); <br>\n p <br>\n .then(function () { <br>\n console.log('resolved'); <br>\n }) <br>\n .catch(function () { <br>\n console.log('rejected'); <br>\n }); <br>\n "
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "description": "",
    "difficulty": "junior",
    "question": "Написать\n полифилл для Promise.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b0"
    }
  },
  {
    "id": "eqkIB94DX6N4zaKbqlhN",
    "description": "",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "question": "Объясните\n разницу между синхронными и асинхронными функциями",
    "_id": {
      "$oid": "60de0704e2c8c53194aee456"
    },
    "answer": {
      "code": [],
      "text": [
        "Синхронные\n функции являются блокирующими, а асинхронные — нет. В синхронных функциях\n одна операция должна завершиться, прежде чем будет запущена следующая\n операция. В этом случае скрипт выполняется строго по порядку операций, и\n выполнение скрипта приостанавливается, если одна из операций занимает очень\n много времени. <br>\n Асинхронные функции обычно принимают callback-функцию в качестве параметра,\n и выполнение продолжается на следующей строке сразу после вызова асинхронной\n функции. Callback-функция вызывается только тогда, когда асинхронная операция\n завершена и стек вызовов пуст. Ресурсоемкие операции, такие как загрузка\n данных с веб-сервера или запросы к базе данных, должны выполняться\n асинхронно, чтобы основной поток мог продолжать выполнять другие операции\n вместо блокировки до завершения этой долгой операции (в случае браузеров\n пользовательский интерфейс будет зависать). <br>\n <br>\n Что такое цикл событий (event loop)? В чем разница между стеком вызовов\n (call stack) и очередью событий (task queue)? <br>\n Цикл событий — это однопоточный цикл, который контролирует стек вызовов и\n проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди\n задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то\n функция удаляется из очереди и помещается в стек вызовов для выполнения.\n <br>\n Рекомендую ознакомиться с докладом о цикле событий от Philip Robert. Это\n одно из самых популярных видео о JavaScript. <br>\n https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html"
      ],
      "link": [
        "https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html",
        "http://theproactiveprogrammer.com/javascript/the-javascript-event-loop-a-stack-and-a-queue/"
      ]
    },
    "type": "question",
    "popularity": null
  },
  {
    "id": "f5SGK6pZ5eWxMdaK6YDJ",
    "competence": [
      "javascript"
    ],
    "question": "Какое\n значение возвращает данное предложение? ~~3.14",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "3\n <br>\n ~~3.14 <br>\n ~ = Округление вниз <br>\n ~~ = Преобразования строки в число <br>\n "
      ]
    },
    "popularity": null,
    "description": "",
    "type": "question",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4cd"
    }
  },
  {
    "id": "fsaKDVzM0ZT9ZWXMMwMG",
    "competence": [],
    "description": "",
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">prototype (у класса ссылка на constructor)</div>\n </div>",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ea"
    },
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "type": null,
    "popularity": null,
    "difficulty": null
  },
  {
    "id": "gdBpPzWVUU5gJjTnA9Ef",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d1"
    },
    "popularity": null,
    "difficulty": "junior",
    "description": "",
    "type": "question",
    "question": "Что\n такое функциональное программирование и какие особенности JS позволяют\n говорить о нем как о функциональном языке программирования?",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Функциональное\n программирование — это декларативная концепция программирования или образец\n (паттерн) того, как строятся приложения, как используются функции, содержащие\n выражения, которые вычисляют значения без изменения аргументов, которые им\n передаются. <br>\n Объект Array содержит методы map, filter и reduce, которые являются самыми\n известными функциями в мире функционального программирования из-за их\n полезности, а также потому, что они не изменяют массив, что делает эти\n функции «чистыми». Также в JS имеются замыкание и функции высшего порядка,\n которые являются характеристиками функционального языка программирования."
      ]
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "goR56CVPUtgpuQ52jk5e",
    "description": "",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee512"
    },
    "difficulty": null,
    "type": null,
    "question": "Замыкания\n и IIFE",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    }
  },
  {
    "id": "hAEPs5SjZMCy1tXlsPp1",
    "_id": {
      "$oid": "60de0704e2c8c53194aee47c"
    },
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Обычно\n используют два вида автоматических тестов: <br>\n Модульное тестирование (тестирование отдельных частей продукта, обычно\n отдельных функций/методов) <br>\n Функциональное тестирование — тестирование некого функционала продукта, при\n этом продукт воспринимается как единый «чёрный ящик». <br>\n "
      ]
    },
    "question": "В\n чём различие между юнит-тестами и функциональными/интеграционными тестами?",
    "description": "",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "type": "question",
    "popularity": null
  },
  {
    "id": "hiI1y5pPjRvjZ83YTu8q",
    "_id": {
      "$oid": "60de0704e2c8c53194aee479"
    },
    "type": "question",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "text": [
        "Это\n значение генерирует блочный элемент, который обтекается другими элементами\n веб-страницы подобно встроенному элементу. Фактически такой элемент по своему\n действию похож на встраиваемые элементы (вроде тега &lt;img&gt;). При этом\n его внутренняя часть форматируется как блочный элемент, а сам элемент — как\n встроенный."
      ],
      "code": []
    },
    "difficulty": "junior",
    "question": "В\n чем разница между строчным и блочно-строчным элементом?",
    "description": "",
    "popularity": null
  },
  {
    "id": "hiXj6O0OA6cwcga3bs0n",
    "popularity": "4",
    "difficulty": "junior",
    "description": "Как получить координаты объекта?",
    "question": "Как получить координаты объекта?",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "getBoundingClientRect"
      ]
    }
  },
  {
    "id": "hofyoCOCszDAdhPJ4L4o",
    "question": "Можете\n ли вы привести пример использования стрелочных функции =&gt;? Чем они\n отличаются от других функций?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee45a"
    },
    "description": "",
    "popularity": null,
    "difficulty": "junior",
    "answer": {
      "text": [
        "Одним\n очевидным преимуществом стрелочных функций является упрощение синтаксиса,\n необходимого для создания функций, без необходимости использования ключевого\n слова function. This внутри стрелочных функций также привязано к замыкающей\n области видимости, в отличие от обычных функций, где this определяется\n контекстом, в котором они вызываются. Лексически привязанное this полезно при\n вызове callback-функций, особенно в компонентах React."
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "javascript"
    ],
    "type": "question"
  },
  {
    "id": "iNRhbjqMZlJtKSXt2vJv",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee468"
    },
    "competence": [
      "javascript"
    ],
    "description": "",
    "question": "Как\n следует оформлять страницу, содержимое которой может быть на разных языках?",
    "popularity": null,
    "answer": {
      "text": [
        "&lt;html\n lang=\"fr\"&gt; <br>\n &lt;span title=\"Spanish\"&gt;&lt;a lang=\"es\"\n href=\"qa-html-language-declarations.es\"&gt;Español&lt;/a&gt;&lt;/span&gt;\n <br>\n Это пример HTTP заголовка <br>\n Content-Language: en, hi, pa <br>\n "
      ],
      "link": [],
      "code": []
    },
    "type": "question"
  },
  {
    "id": "ilGxYSK4w35lA3j6FKZF",
    "description": "",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee477"
    },
    "difficulty": "junior",
    "question": "Объясните\n своими словами, что такое блочная модель.",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Ширина\n — ширина площади содержимого элемента. Для блочных элементов значение по\n умолчанию равно 100%. У строчных элементов ширина зависит от содержимого.\n <br>\n Высота — определяет высоту элемента. Как правило, она зависит от\n внутреннего содержимого, но при желании можно указать конкретную высоту.\n Опять же, это работает только с блочными элементами. <br>\n Границы — границы есть у каждого элемента, даже если вы их не видите. У них\n может быть разный размер, цвет и оформление. <br>\n Отступы — они определяют расстояние между границей элемента и его\n содержимым. Их можно использовать, например, для того, чтобы текст внутри\n элемента оставался читаемым. <br>\n Поля — они определяют расстояние между границей элемента и тем, что его\n окружает."
      ]
    },
    "popularity": null,
    "type": "question"
  },
  {
    "id": "ipXEJgoCTFZzcWdbqrT3",
    "type": "question",
    "description": "",
    "popularity": null,
    "answer": {
      "text": [
        "Accessible\n Rich Internet Applications <br>\n htmo role <br>\n "
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "javascript"
    ],
    "question": "Объясните,\n что такое ARIA и скринридеры, а также как сделать сайт доступным.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee465"
    },
    "difficulty": "junior"
  },
  {
    "id": "itwp5b6OMnh2xVuhswoU",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee505"
    },
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">S - single responsobility - все связи выносить в\n отдельные сущности (единственность зависимости)</div>\n </div>",
    "difficulty": null,
    "competence": [],
    "popularity": null,
    "type": null
  },
  {
    "id": "iy5h7zWBaC9TYFSpy1CN",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e6"
    },
    "answer": {
      "text": [
        ""
      ],
      "code": [],
      "link": []
    },
    "question": "Abstract\n Syntax Tree (AST)",
    "difficulty": null,
    "type": null,
    "description": "",
    "popularity": null
  },
  {
    "id": "j8C8R6aVYGtxVu5Y7MDu",
    "question": "Объясните,\n что такое всплытие событий (event bubbling)",
    "answer": {
      "link": [
        "https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html"
      ],
      "code": [],
      "text": [
        "Когда\n событие срабатывает на элементе DOM, оно попытается обработать событие (если\n привязан обработчик), затем событие всплывет вверх к своему родителю и это\n повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть\n до `document`. Всплытие событий является механизмом, на котором основано\n делегирование событий. <br>\n <br>\n В чем разница между \"атрибутом\" (attribute) и\n \"свойством\" (property)? <br>\n Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы\n проиллюстрировать разницу, представьте, что у нас есть это текстовое поле в\n HTML: &lt;input type=\"text\" value=\"Hello\"&gt;. <br>\n const input = document.querySelector('input'); <br>\n console.log(input.getAttribute('value')); // Hello <br>\n console.log(input.value); // Hello <br>\n Но после того, как вы измените значение текстового поля, добавив к нему\n \"World!\", будет: <br>\n console.log(input.getAttribute('value')); // Hello <br>\n console.log(input.value); // Hello World!"
      ]
    },
    "competence": [
      "common questions"
    ],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee445"
    },
    "popularity": null,
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "jHrY41nx0DU9nPGx47H3",
    "question": "Что\n делает и для чего нужна функция `Function.prototype.bind`?",
    "popularity": "3",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "answer": {
      "text": [
        "Метод\n bind() создаёт новую функцию, которая при вызове устанавливает в качестве\n контекста выполнения this предоставленное значение. В метод также передаётся\n набор аргументов, которые будут установлены перед переданными в привязанную\n функцию аргументами при её вызове. <br>\n По моему опыту, это наиболее полезно для привязки значения this в методах\n классов, которые вы хотите передать в другие функции. Это часто делается в\n компонентах React."
      ],
      "link": [
        "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind"
      ],
      "code": []
    },
    "description": "",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee43d"
    }
  },
  {
    "id": "jV37e9yguwftOoMjkEZG",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d4"
    },
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "num\n <br>\n bigint <br>\n string <br>\n boolean <br>\n null <br>\n undefined <br>\n obj <br>\n sym"
      ]
    },
    "popularity": null,
    "type": "question",
    "difficulty": "junior",
    "description": "",
    "question": "Типы\n данных",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "jiyaN7vUpK10tIF3QoZy",
    "type": "question",
    "difficulty": "junior",
    "question": "В\n чем разница между `==` и `===`?",
    "answer": {
      "code": [],
      "text": [
        "#ОШИБКА!"
      ],
      "link": [
        "https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons"
      ]
    },
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee448"
    },
    "description": "",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "jkFvaZex9h4DGrC0Bk3h",
    "difficulty": "junior",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "type": "question",
    "popularity": null,
    "description": "",
    "competence": [
      "javascript"
    ],
    "question": "В\n чём разница между классом в ES6 и функцией-конструктором в ES5?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee47b"
    }
  },
  {
    "id": "jkpoFbuLASvWEIqYnScu",
    "_id": {
      "$oid": "60de0704e2c8c53194aee519"
    },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "popularity": null,
    "difficulty": null,
    "type": null,
    "description": "",
    "competence": [],
    "question": "Как\n появляется контекст у функции"
  },
  {
    "id": "jpszSo7cP5HKKGMgzM7o",
    "type": "question",
    "answer": {
      "code": [],
      "text": [
        "создает новую функцию"
      ],
      "link": []
    },
    "question": "как работает bind?",
    "competence": [
      "javascript"
    ],
    "description": "bind",
    "difficulty": "junior",
    "popularity": "4"
  },
  {
    "id": "jyaXC5JjagVYx9gy3tec",
    "question": "byte\n stream decoder",
    "type": null,
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e3"
    },
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "description": "",
    "popularity": null,
    "competence": []
  },
  {
    "id": "kFq9jrYlIY7suOskfJDe",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee471"
    },
    "question": "Приходилось\n ли вам работать с языками HTML-шаблонизации?",
    "difficulty": "junior",
    "answer": {
      "link": [],
      "text": [
        "jade\n <br>\n SWIG <br>\n "
      ],
      "code": []
    },
    "type": "question",
    "popularity": null,
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "kJAnifxxNC8XDunnCYmc",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "В\n HTML5 для любого элемента можно использовать собственные атрибуты,\n начинающиеся с префикса data-. Это позволяет хранить разную информацию,\n которая может помочь в работе скриптов, а также для оформления элементов\n через CSS."
      ]
    },
    "popularity": null,
    "type": "question",
    "description": "",
    "question": "Для\n чего нужны атрибуты, начинающиеся с data-?",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee46a"
    }
  },
  {
    "id": "kYZ1LJRU7QJKKK56Lis6",
    "difficulty": "junior",
    "popularity": null,
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee48c"
    },
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Нет,\n единственное что мы можем — это удалить класс, у которого указаны before или\n after, либо наоборот добавить."
      ]
    },
    "question": "Можно\n ли из js менять значения в before, after?",
    "competence": [
      "javascript"
    ],
    "description": ""
  },
  {
    "id": "kf3jnq3ucFantb51bk9E",
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b8"
    },
    "difficulty": "junior",
    "answer": {
      "link": [],
      "text": [
        "Например:\n <br>\n f([1, 2, null, 7, 8, null, 3]); // =&gt; [2, 4, 14, 16, 6] <br>\n function f(arr) { <br>\n return arr <br>\n .filter(item =&gt; item !== null) <br>\n .map(item =&gt; item * 2); <br>\n } <br>\n "
      ],
      "code": []
    },
    "popularity": null,
    "question": "Задача:\n Написать функцию, принимающую аргументом массив чисел и возвращающую новый\n массив, состоящий из удвоенных значений первого.",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "kfQMp9LxefZ0LX8tPAUj",
    "description": "",
    "answer": {
      "text": [
        "var\n a={}, <br>\n b={key:'b'}, <br>\n c={key:'c'}; <br>\n a[b]=123; <br>\n a[c]=456; <br>\n console.log(a[b]); <br>\n Ответ: 456 <br>\n Что же происходит? Когда у объекта устанавливается новое свойство, то\n JavaScript неявно сделает stringify значения. В коде выше b и c являются\n объектами, следовательно они оба конвертируются в \"[object Object]\"\n (String). Так как stringify значения равны, то получается, что мы присваиваем\n новое значение одному и тому же свойству. <br>\n Равносильно, что написать: <br>\n var a={}, <br>\n b='object', <br>\n c='object'; <br>\n a[b]=123; <br>\n a[c]=456; <br>\n "
      ],
      "link": [],
      "code": []
    },
    "popularity": null,
    "question": "Что\n выведется в консоль ? Объясните почему.",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c7"
    },
    "type": "question",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "kiDfh3Fe0cf41JN8wpgj",
    "popularity": "3",
    "question": "Как создавать окружения в вебпаке?",
    "answer": {
      "text": [
        "definePlugins"
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "javascript",
      "frontend"
    ],
    "type": "question",
    "description": "envinment",
    "difficulty": "middle"
  },
  {
    "id": "klqtMzpp4AQJWGdqgyXf",
    "competence": [
      "javascript"
    ],
    "question": "Что\n такое делегирование событий? Плюсы/минусы/подводные камни.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b4"
    },
    "difficulty": "junior",
    "description": "",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Делегирование\n событий — подход при работе с событиями DOM-дерева, при котором обработчики\n событий добавляются не на каждый конкретный элемент, а только на общий\n родительский, в то время как необходимость вызова это обработчика для\n конкретного интересующего нас элемента определяется через ин <br>\n ициатора события, узнать который можно из свойства объекта события\n event.target. <br>\n Такой подход возможен благодаря особенностям событийной модели DOM-дерева,\n а конкретно такой особенности, как всплытие событий. <br>\n Плюсы <br>\n Такой подход будет хорош, если элементы на странице или в какой-то области\n создаются динамически на протяжении какого-то промежутка времени. В этом\n случае, при использовании делегирования, мы можем позволить себе добавить обработчик\n события единожды и не отслеживать тот момент когда эти элементы будут\n созданы. <br>\n Кроме прочего это в лучшую сторону отразится на потреблении памяти, если\n таких элементов будет немало. <br>\n На самом деле, подход с делегированием событием имеет право на жизнь даже\n если все элементы уже созданы в DOM и их состав не предполагает динамического\n изменения, но при этом их количество достаточно велико. <br>\n Минусы <br>\n Чуть меньшая «прозрачность» и очевидность по сравнению с тем когда обработчик\n события добавляется непосредственно для нужного элемента. <br>\n Потенциально чуть больше нагрузки ложится на CPU, т.к. любое возникновения\n события внутри родительского элемента запускает обработчик и поиск\n необходимого элемента для проверки необходимости работы основного\n обработчика. Так что тут всё индивидуально, в каждом конкретном случае надо\n смотреть насколько вероятны возникновения событий, которые будут приходиться\n «мимо» целевых элементов и что нам более важно оптимизировать — память или\n CPU. <br>\n Подводные камни <br>\n Любой неосторожный event.stopPropagation может прервать цепочку всплытия\n события и оно не дойдёт до родительского элемента, на котором установлен\n обработчик. <br>\n Если реализуете делегирование собственноручно, а не используете готовое\n решение, то не стоит забывать про тот нюанс, что недостаточно проверить\n event.target на соответствие требуемому элементу. Необходимо искать по дереву\n вверх до тех пор пока либо не встретим либо этот элемент, либо родительский,\n либо дойдём до вершины дерева. Причиной тому служит всё то же всплытие\n событий — инициатором события может оказаться один из элементов, вложенных в\n наш, а не он сам. <br>\n "
      ]
    },
    "popularity": null,
    "type": "question"
  },
  {
    "id": "kmR4N3bKZVzvWYvJ0WtF",
    "description": "равны ли простые обьекты",
    "popularity": "5",
    "question": "Как проверить обьекты на равенство?",
    "type": "question",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "JSON.stringify(0bj) === JSON.stringify(0bj)"
      ]
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "ku6UsFeGl4dhM5iDje3k",
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "Дана\n структура данных в виде дерева: <br>\n const tree = { <br>\n value: 1, <br>\n children: [ <br>\n { <br>\n value: 2, <br>\n children: [ <br>\n { value: 4 }, <br>\n { value: 5 }, <br>\n ] <br>\n }, <br>\n { <br>\n value: 3, <br>\n children: [ <br>\n { value: 6 }, <br>\n { value: 7 }, <br>\n ] <br>\n } <br>\n ] <br>\n }; <br>\n Необходимо написать функцию, возвращающую значения всех вершин дерева:\n <br>\n getTreeValues(tree); // =&gt; [1, 2, 3, 4, 5, 6, 7] <br>\n Через рекурсию: <br>\n function getTreeValues(tree) { <br>\n let values = [ tree.value ]; <br>\n if (Array.isArray(tree.children)) { <br>\n tree.children.forEach(item =&gt; values =\n values.concat(getTreeValues(item))); <br>\n } <br>\n return values; <br>\n } <br>\n Через цикл: <br>\n function getTreeValues(tree) { <br>\n const tmpTree = [tree]; <br>\n const res = []; <br>\n let current; <br>\n while (tmpTree.length &gt; 0) { <br>\n current = tmpTree.shift(); <br>\n res.push(current.value); <br>\n if (current.children) { <br>\n current.children.forEach(item =&gt; tmpTree.push(item)); <br>\n } <br>\n } <br>\n return res <br>\n } <br>\n "
      ],
      "link": []
    },
    "question": "Задача:\n Обход дерева",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b9"
    },
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "kzvjCu2ZJuwLdFbi6jeE",
    "question": "В\n чем преимущество использования стрелочных функций для метода в конструкторе?",
    "answer": {
      "code": [],
      "text": [
        "Основным\n преимуществом использования стрелочной функции в качестве метода внутри\n конструктора является то, что значение this устанавливается во время создания\n функции и не может измениться после этого. Таким образом, когда конструктор\n используется для создания нового объекта, this всегда будет ссылаться на этот\n объект. Например, допустим, у нас есть конструктор Person, который принимает\n имя в качестве аргумента, имеет два метода для вывода в консоль этого имени,\n один в качестве обычной функции, а другой в качестве стрелочной: <br>\n const Person = function(firstName) { <br>\n this.firstName = firstName; <br>\n this.sayName1 = function() { console.log(this.firstName); }; <br>\n this.sayName2 = () =&gt; { console.log(this.firstName); }; <br>\n }; <br>\n const john = new Person(‘John’); <br>\n const dave = new Person(‘Dave’); <br>\n john.sayName1(); // John <br>\n john.sayName2(); // John <br>\n // У обычной функции значение `this` может быть изменено, но у стрелочной\n функции нет <br>\n john.sayName1.call(dave); // Dave (потому что ‘this’ сейчас ссылается на\n объект dave) <br>\n john.sayName2.call(dave); // John <br>\n john.sayName1.apply(dave); // Dave (потому что ‘this’ сейчас ссылается на\n объект dave) <br>\n john.sayName2.apply(dave); // John <br>\n john.sayName1.bind(dave)(); // Dave (потому что ‘this’ сейчас ссылается на\n объект dave) <br>\n john.sayName2.bind(dave)(); // John <br>\n var sayNameFromWindow1 = john.sayName1; <br>\n sayNameFromWindow1(); // undefined (потому что ‘this’ сейчас ссылается на\n объект window) <br>\n var sayNameFromWindow2 = john.sayName2; <br>\n sayNameFromWindow2(); // John <br>\n Смысл заключается в том, что this можно изменить для обычной функции, но\n для стрелочных функций контекст всегда остается неизменным. Поэтому, даже\n если вы передаете стрелочную функцию в разные части вашего приложения, вам не\n нужно беспокоиться об изменении контекста. <br>\n Это может быть особенно полезно в классовых React-компонентах. Если вы\n определяете метод класса для чего-то такого, как обработчик клика, используя\n обычную функцию, а затем передаете этот обработчик в дочерний компонент в\n качестве prop, вам также необходимо привязать this в конструкторе\n родительского компонента , Если вместо этого вы используете стрелочную\n функцию, то нет необходимости привязывать this, так как метод автоматически\n получит свое значение this из замыкающего лексического контекста. (Прочитайте\n эту статью о стрелочных функциях:\n https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb)"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
        "https://medium.com/@machnicki/handle-events-in-react-with-arro<span style=\"display:none\">w-functions-ede88184bbb</span>"
      ]
    },
    "difficulty": "junior",
    "popularity": null,
    "type": "question",
    "description": "",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee45b"
    }
  },
  {
    "id": "lMsMYvUOJPYzukgdXCvN",
    "type": "question",
    "competence": [
      "javascript",
      "html"
    ],
    "popularity": "5",
    "question": "Объясните\n делегирование событий",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee430"
    },
    "description": "Пожалуйста! Еще разик!",
    "answer": {
      "link": [
        "https://davidwalsh.name/event-delegate",
        "https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation"
      ],
      "text": [
        "Делегирование\n событий — это приём, заключающийся в добавлении обработчиков событий к\n родительскому элементу, а не к дочерним элементам. Обработчик будет\n срабатывать всякий раз, когда событие будет запущено на дочерних элементах\n благодаря всплытию событий в DOM. Преимущества этого приёма:<br>\n Экономит объем используемой памяти, т.к. для родительского элемента\n требуется только один обработчик.<br>\n Не нужно привязывать или убирать обработчики при добавлении и удалении\n элементов.",
        "Еще многого много текста ответ"
      ],
      "code": [
        " applyFilter(event: Event) {\n const filterValue = (event.target as HTMLInputElement).value;\n this.dataSource.filter = filterValue.trim().toLowerCase();\n }",
        " ngAfterViewInit() {\n this.dataSource.sort = this.sort;\n }",
        " // фильтруем таски как надо и выставляем в таблицу\n setTableData(config: ISobesConfigModel): void {\n let newDataSource: ITask[] = [];\n\n let matchedQuestions: ITask[] = [];\n let matchedExercises: ITask[] = [];\n let unmatchedQuestions: ITask[] = [];\n let unmatchedExercises: ITask[] = [];\n\n let questionNumber = Math.round(config.count * config.type / 100);\n let exerciseNumber = config.count - questionNumber;\n\n this.tasks.forEach((task: ITask) => {\n let taskChecker = (task: ITask, config: ISobesConfigModel) => {\n return task.competence.every(v => config.competence.includes(v));\n };\n if (config.difficulty.includes(task.difficulty) && config.popularity.includes(task.popularity) && taskChecker(task, config)) {\n if (task.type === 'question') {\n matchedQuestions.push(task)\n }\n if (task.type === 'exercise') {\n matchedExercises.push(task)\n }\n } else {\n if (task.type === 'question') {\n unmatchedQuestions.push(task)\n } else if (task.type === 'exercise') {\n unmatchedExercises.push(task)\n } else {\n unmatchedQuestions.push(task);\n }\n }\n });\n\n let matchedQuestionsRandom = [];\n for (let i = 0; i < matchedQuestions.length; i++) {\n let it = this.randomizer(matchedQuestions);\n matchedQuestionsRandom.push(it);\n }\n\n let matchedExercisesRandom = [];\n for (let i = 0; i < matchedExercises.length; i++) {\n let it = this.randomizer(matchedExercises);\n matchedExercisesRandom.push(it);\n }\n\n let unmatchedQuestionsRandom = [];\n for (let i = 0; i < unmatchedQuestions.length; i++) {\n let it = this.randomizer(unmatchedQuestions);\n unmatchedQuestionsRandom.push(it);\n }\n\n let unmatchedExercisesRandom = [];\n for (let i = 0; i < unmatchedExercises.length; i++) {\n let it = this.randomizer(unmatchedExercises);\n unmatchedExercisesRandom.push(it);\n }\n\n let questions: ITask[] = matchedQuestionsRandom.concat(unmatchedQuestionsRandom);\n let exercises: ITask[] = matchedExercisesRandom.concat(unmatchedExercisesRandom);\n\n newDataSource.push(...questions.slice(0, questionNumber));\n newDataSource.push(...exercises.slice(0, exerciseNumber));\n\n if (questionNumber > questions.length) {\n newDataSource.push(...exercises.slice(exerciseNumber, exerciseNumber + questionNumber - questions.length));\n }\n\n if (exerciseNumber > exercises.length) {\n newDataSource.push(...questions.slice(questionNumber, questionNumber + exerciseNumber - exercises.length));\n }\n newDataSource = this.setTableIndex(0, newDataSource);\n this.dataSource = new MatTableDataSource(newDataSource);\n }"
      ]
    }
  },
  {
    "id": "lbWxNrLHgkZKfSzFAfJG",
    "answer": {
      "text": [
        "var\n sum = 101*50, <br>\n sumArr = eval([4, 2, ... 3, 7].join('+').replace('++', '+')), <br>\n res; <br>\n res = sum-sumArr; <br>\n "
      ],
      "link": [],
      "code": []
    },
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "question": "Как\n быстрее всего найти сумму элементов массива?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee49a"
    },
    "difficulty": "junior"
  },
  {
    "id": "lcvVPWE6lB3RCbmtAbcc",
    "question": "ЧТо такое .getBoundingClientRect()?",
    "popularity": "4",
    "competence": [
      "javascript",
      "html",
      "css"
    ],
    "description": "getBoundingClientRect",
    "answer": {
      "code": [
        "https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"
      ],
      "link": [],
      "text": [
        "Находит позицию элемента на странице с точками-вершинами"
      ]
    },
    "difficulty": "junior",
    "type": "question"
  },
  {
    "id": "m3JByqTjWZhoWY4psE9F",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "popularity": null,
    "difficulty": null,
    "question": "execution\n context",
    "description": "",
    "type": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4df"
    },
    "competence": []
  },
  {
    "id": "m6XVRIPFqHjPJHS3tdQt",
    "popularity": null,
    "type": null,
    "description": "",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee51c"
    },
    "difficulty": null,
    "question": "Откуда\n берется свойство length у массива",
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    }
  },
  {
    "id": "mDvoQospWhIZZAhsfq85",
    "popularity": null,
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee486"
    },
    "description": "",
    "question": "Что\n покажут эти два alert?",
    "difficulty": "junior",
    "answer": {
      "text": [
        "var\n foo = \"Hello\"; <br>\n (function() { <br>\n var bar = \" World\"; <br>\n alert(foo + bar); <br>\n })(); <br>\n alert(foo + bar); <br>\n Hello world &amp;&amp; ReferenceError <br>\n "
      ],
      "link": [],
      "code": []
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "mHVoUjAobmw31yT7oA8p",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "description": "",
    "type": "question",
    "answer": {
      "code": [],
      "text": [
        "console.log('one');\n <br>\n setTimeout(function() { <br>\n console.log('two'); <br>\n }, 0); <br>\n console.log('three'); <br>\n "
      ],
      "link": []
    },
    "popularity": null,
    "question": "Что\n выводит код ниже?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee489"
    }
  },
  {
    "id": "mvCNUPRa1ZW8Z2XxXtxh",
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "text": [
        "width:\n 100px; <br>\n height: 100px; <br>\n border-right: 1px solid #f00; <br>\n border-radius: 0 50% 50% 0; <br>\n "
      ],
      "code": []
    },
    "question": "Нарисовать\n стилями полукруг.",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee491"
    },
    "description": "",
    "popularity": null,
    "difficulty": "junior"
  },
  {
    "id": "mwblxGSefusnWXYPE2dU",
    "_id": {
      "$oid": "60de0704e2c8c53194aee50a"
    },
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "popularity": null,
    "type": null,
    "difficulty": null,
    "description": "",
    "question": "Какие\n есть типы переменных?",
    "competence": []
  },
  {
    "id": "nH9TcyT5LCtlsKU4nmGN",
    "competence": [],
    "description": "",
    "popularity": null,
    "question": "Интерпретатор\n Ignition",
    "_id": {
      "$oid": "60de0704e2c8c53194aee504"
    },
    "type": null,
    "difficulty": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    }
  },
  {
    "id": "nRom6LlWEOjbMWSMujOD",
    "difficulty": "junior",
    "answer": {
      "text": [
        "function\n validBraces(str) { <br>\n <br>\n var arrOpenSymbols = [], <br>\n result = false, <br>\n countOpenSymbols; <br>\n if (str.length &gt; 0) { <br>\n for (var i = 0; i &lt; str.length; i++) { <br>\n if (str[i] === '{' || str[i] === '[' || str[i] === '(') { <br>\n arrOpenSymbols.push(str[i]); <br>\n } else { <br>\n countOpenSymbols = arrOpenSymbols.length; <br>\n if ((str[i] === '}' &amp;&amp; arrOpenSymbols[(countOpenSymbols-1)] ===\n '{') || <br>\n (str[i] === ']' &amp;&amp; arrOpenSymbols[(countOpenSymbols-1)] === '[') ||\n <br>\n (str[i] === ')' &amp;&amp; arrOpenSymbols[(countOpenSymbols-1)] === '(')\n <br>\n ) { <br>\n arrOpenSymbols.pop(); <br>\n } <br>\n } <br>\n } <br>\n <br>\n if (arrOpenSymbols.length === 0) { <br>\n result = true; <br>\n } else { <br>\n result = false; <br>\n } <br>\n } <br>\n return result; <br>\n } <br>\n console.log(''); <br>\n console.log(validBraces('()')); <br>\n console.log(validBraces('[)')); <br>\n console.log(validBraces('{}[]()')); <br>\n console.log(validBraces('([{}])')); <br>\n console.log(validBraces('())({}}{()][][')); <br>\n "
      ],
      "code": [],
      "link": []
    },
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a6"
    },
    "question": "Есть\n строка, состоящая из разных скобок, проверить закрыты ли все. Пример строки:\n \"())({}}{()][][\"",
    "popularity": null,
    "description": "",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "nsQQAoJUhqoyAplakUyD",
    "question": "Чем\n ООП в JS отличается от ООП в других языках",
    "competence": [],
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee521"
    },
    "difficulty": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "description": "",
    "type": null
  },
  {
    "id": "nw3jTZUGQPxBpe9DeDxu",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "_id": {
      "$oid": "60de0704e2c8c53194aee48d"
    },
    "answer": {
      "text": [
        "&lt;div\n class=\"wrap\"&gt; <br>\n &lt;div class=\"block\"&gt;&lt;/div&gt; <br>\n &lt;div class=\"block\"&gt;&lt;/div&gt; <br>\n &lt;div class=\"block\"&gt;&lt;/div&gt; <br>\n &lt;/div&gt; <br>\n .wrap { <br>\n width: 600px; <br>\n height: 200px; <br>\n border: 1px solid green; <br>\n } <br>\n .block { <br>\n float: left; <br>\n width: 200px; <br>\n height: 200px; <br>\n outline: 1px solid black; <br>\n } <br>\n "
      ],
      "link": [],
      "code": []
    },
    "difficulty": "junior",
    "question": "Вместить\n три блока 20X20px в ряд, в блок шириной 60px, при этом у блоков должны быть\n границы."
  },
  {
    "id": "nwK4HEpyzorKCnC8PMyD",
    "question": "Промисы\n все разрастаются и на смену Callback Hell приходит Promise Hell. Что же\n делать?",
    "description": "",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "answer": {
      "code": [],
      "text": [
        "function\n test() { <br>\n return new Promise(function (resolve) { <br>\n setTimeout (function () { <br>\n resolve(1); <br>\n }) <br>\n }) <br>\n } <br>\n async function test1() { <br>\n var res = await test(); <br>\n console.log(res + 1); <br>\n } <br>\n "
      ],
      "link": []
    },
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee496"
    },
    "type": "question"
  },
  {
    "id": "nyWOGVumN8wDHDozmXtI",
    "type": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">O - open closed principles - можем расширять, но не\n менять</div>\n </div>",
    "difficulty": null,
    "description": "",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee506"
    },
    "popularity": null
  },
  {
    "id": "o9jxCs3lEdmz9fIRpdGo",
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "question": "iterator",
    "difficulty": null,
    "competence": [],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f0"
    },
    "type": null
  },
  {
    "id": "oEoy0q7OhnMiRJFbQHM3",
    "question": "Требуется\n сверстать попап по центру, его размеры нам известны, но мы не хотим что бы он\n прокручивался вместе со страницей, причем по высоте может и не влезать в\n высоту экрана.",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "body\n { <br>\n overflow: hidden; <br>\n } <br>\n .wrap { <br>\n position: fixed; <br>\n top: 0; <br>\n left: 0; <br>\n width: 100%; <br>\n height: 100%; <br>\n overflow-y: auto; <br>\n background-color: rgba(230, 230, 230, .1); <br>\n } <br>\n .popup { <br>\n position: absolute; <br>\n width: 400px; <br>\n height: 300px; <br>\n right: 0; <br>\n left: 0; <br>\n top: 0; <br>\n bottom: 0; <br>\n margin: auto; <br>\n } <br>\n "
      ],
      "code": []
    },
    "type": "question",
    "description": "",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee490"
    }
  },
  {
    "id": "oyUbl6D4cQ1k90xnCBvQ",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4fb"
    },
    "difficulty": null,
    "question": "Графы",
    "type": null,
    "description": ""
  },
  {
    "id": "pK53IpxExhnWZLtyFjRr",
    "_id": {
      "$oid": "60de0704e2c8c53194aee502"
    },
    "popularity": null,
    "competence": [],
    "type": null,
    "question": "Компилятор\n Turbofan",
    "description": "",
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "difficulty": null
  },
  {
    "id": "pdfg8LDl1uvFtOF6uqh4",
    "type": null,
    "description": "",
    "competence": [],
    "question": "stream\n of bytes",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e2"
    },
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "difficulty": null
  },
  {
    "id": "phPZOGutvttB2n9Z5oe1",
    "description": "фасад pattern",
    "question": "Что такое фасад pattern?",
    "difficulty": "senior",
    "popularity": "5",
    "answer": {
      "code": [],
      "text": [
        "Надо посомтреть получше"
      ],
      "link": []
    },
    "competence": [
      "common questions",
      "javascript"
    ],
    "type": "question"
  },
  {
    "id": "pstkA7bxGr3VrGS6ZtKu",
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">[Symbol.iterator] (можно добавить в объект и он будет\n итерируемым, как массив)</div>\n </div>",
    "type": null,
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f1"
    },
    "competence": [],
    "description": "",
    "difficulty": null
  },
  {
    "id": "px1hzmlxhrPPkdgGKeRH",
    "popularity": null,
    "difficulty": "junior",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "question": "Есть\n div, в нем другой div, у второго задан padding 50%, как это все будет\n выглядеть?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a5"
    },
    "answer": {
      "text": [
        ".wrap\n { <br>\n width: 200px; <br>\n border: 1px solid green; <br>\n } <br>\n <br>\n .block { <br>\n width: 200px; <br>\n padding-bottom: 50%; <br>\n border: 1px solid red; <br>\n } <br>\n "
      ],
      "link": [],
      "code": []
    },
    "description": ""
  },
  {
    "id": "q2dEawsu6PXHcbJwUfPv",
    "popularity": "4",
    "question": "Что такое pr?",
    "description": "Pull request",
    "answer": {
      "text": [
        "pull request (открываем ветку куда запушили, делаем пул реквест с коментарием в основную ветку, в основной ветке принимаем)"
      ],
      "code": [],
      "link": []
    },
    "competence": [
      "common questions"
    ],
    "type": "question",
    "difficulty": "junior"
  },
  {
    "id": "qBqJ6wUx7rih3LPHWPaS",
    "type": "question",
    "question": "Еще\n интересный пример. Реализовать методы seven, plus, one, five, minus, two.\n seven(plus(one())) -&gt; 8. five(minus(two())) -&gt; 3",
    "description": "",
    "competence": [
      "javascript"
    ],
    "popularity": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "function\n one(arg){ <br>\n if (typeof arg === 'function') { <br>\n return arg(1); <br>\n } else { <br>\n return 1; <br>\n } <br>\n } <br>\n function seven(arg) { <br>\n if (typeof arg === 'function') { <br>\n return arg(7); <br>\n } else { <br>\n return 7; <br>\n } <br>\n } <br>\n function plus(arg) { <br>\n return function (a) { <br>\n return a + arg; <br>\n } <br>\n } <br>\n "
      ]
    },
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a2"
    }
  },
  {
    "id": "qLqXPkb7KfK794wWUAGI",
    "popularity": null,
    "type": "question",
    "difficulty": "junior",
    "description": "",
    "question": "В\n чем преимущества использования spread оператора и чем он отличается от rest\n оператора?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee460"
    },
    "answer": {
      "code": [],
      "text": [
        "Spread\n оператор синтаксиса ES6 очень полезен при написании кода в функциональном\n стиле, поскольку мы можем легко создавать копии массивов или объектов, не\n прибегая к Object.create, slice или функции библиотеки. Эта языковая функция\n часто используется в проектах с Redux и rx.js. <br>\n function putDookieInAnyArray(arr) { <br>\n return […arr, ‘dookie’]; <br>\n } <br>\n const result = putDookieInAnyArray([‘I’, ‘really’, “don’t”, ‘like’]); //\n [“I”, “really”, “don’t”, “like”, “dookie”] <br>\n const person = { <br>\n name: ‘Todd’, <br>\n age: 29, <br>\n }; <br>\n const copyOfTodd = { …person }; <br>\n В свою очередь, rest оператор синтаксиса ES6 позволяет в сокращенном виде\n указывать неопределенное количество аргументов, передаваемых в функцию. Можно\n сказать, что он противоположен spread оператору: собирает данные и добавляет\n их в массив, вместо разделения массива данных. Он используется в аргументах\n функций, а также при деструктуризации массивов и объектов. <br>\n function addFiveToABunchOfNumbers(…numbers) { <br>\n return numbers.map(x =&gt; x + 5); <br>\n } <br>\n const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10,\n 11, 12, 13, 14, 15] <br>\n const [a, b, …rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4] <br>\n const { e, f, …others } = { <br>\n e: 1, <br>\n f: 2, <br>\n g: 3, <br>\n h: 4, <br>\n }; // e: 1, f: 2, others: { g: 3, h: 4 }"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referenc<span style=\"display:none\">e/Functions/rest_parameters</span>",
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Referenc<span style=\"display:none\">e/Operators/Destructuring_assignment</span>"
      ]
    },
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "qPldh9jslARDWh2EEt3B",
    "_id": {
      "$oid": "60de0704e2c8c53194aee508"
    },
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">I - Interface segregation principle - не использовать\n слишком большие не связаннные контракты, интерфейсы маленькие, чтобы не один\n обьет работал со всеми</div>\n </div>",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "type": null,
    "difficulty": null,
    "popularity": null,
    "competence": [],
    "description": ""
  },
  {
    "id": "qZIvp4C8WCbaqJcM9b1F",
    "competence": [
      "javascript",
      "html",
      "css"
    ],
    "question": "Что такое .closest('.column')?",
    "description": ".closest('.column')",
    "type": "question",
    "popularity": "3",
    "difficulty": "junior",
    "answer": {
      "link": [],
      "text": [
        "Он ищет ближайшего родителя по модификатору. Лучше чем parentNode"
      ],
      "code": []
    }
  },
  {
    "id": "r3AUI5F1BHK7xo9Kk6Ww",
    "question": "scope\n chain",
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "popularity": null,
    "type": null,
    "competence": [],
    "difficulty": null,
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4da"
    }
  },
  {
    "id": "r8eqKsGirIaIyryvjM6n",
    "description": "",
    "question": "Можете\n ли вы описать разницу между прогрессивным улучшением и изящной деградацией?",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee463"
    },
    "difficulty": "junior",
    "popularity": null,
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "(graceful\n degradation) — принцип сохранения работоспособности при потере части\n функциональности. Отказоустойчивость клиентских веб-интерфейсов. <br>\n (progressive enhancement,) - Прогрессивное улучшение предполагает, что\n веб-интерфейсы должны создаваться поэтапно, циклически, от простого к\n сложному. На каждом из этапов должен получаться законченный веб-интерфейс,\n который будет лучше, красивее и удобнее предыдущего. Можно сказать, что\n сейчас таких этапов четыре: <br>\n <br>\n «Старый-добрый-HTML» <br>\n «CSS» <br>\n «CSS3» <br>\n «JavaScript» <br>\n отказоустойчивость клиентских веб-интерфейсов."
      ]
    },
    "type": "question"
  },
  {
    "id": "rA4o7abGgQ4ZlATYzbxk",
    "question": "В\n чем разница между классом в ES6 и функцией-конструктором в ES5?",
    "answer": {
      "link": [
        "https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance",
        "https://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5"
      ],
      "text": [
        "Для\n начала посмотрим на примеры: <br>\n // ES5 функция-конструктор <br>\n function Person(name) { <br>\n this.name = name; <br>\n } <br>\n // ES6 класс <br>\n class Person { <br>\n constructor(name) { <br>\n this.name = name; <br>\n } <br>\n } <br>\n Они выглядят довольно похоже, если рассматривать простые конструкторы.\n <br>\n Основное отличие в конструкторе возникает при использовании наследования.\n Если мы хотим создать класс `Student` (который будет являться подклассом\n класса `Person`) и добавить поле `studentId`, то, в дополнение к\n вышеописанному, мы должны сделать следующее: <br>\n // ES5 функция-конструктор <br>\n function Student(name, studentId) { <br>\n // Вызов конструктора суперкласса для инициализации производных от\n суперкласса членов. <br>\n Person.call(this, name); <br>\n // Инициализация собственных членов подкласса. <br>\n this.studentId = studentId; <br>\n } <br>\n Student.prototype = Object.create(Person.prototype); <br>\n Student.prototype.constructor = Student; <br>\n // ES6 класс <br>\n class Student extends Person { <br>\n constructor(name, studentId) { <br>\n super(name); <br>\n this.studentId = studentId; <br>\n } <br>\n } <br>\n Наследование в синтаксисе ES5 является намного более многословным, а в ES6\n более понятное и усваиваемое."
      ],
      "code": []
    },
    "description": "",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee459"
    },
    "type": "question"
  },
  {
    "id": "rMeREgps5WFCmxfZ4rSn",
    "competence": [
      "common questions",
      "html",
      "css"
    ],
    "popularity": "5",
    "difficulty": "beginner",
    "type": "question",
    "question": "px % em rem vw vw",
    "answer": {
      "link": [
        "https://elementor.com/help/whats-the-difference-between-px-em-rem-vw-and-vh/"
      ],
      "code": [],
      "text": [
        "Там в ссылке глянь"
      ]
    },
    "description": "В чем разница?"
  },
  {
    "id": "rciDcDLQ98i6aNTRXPn4",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ec"
    },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    },
    "difficulty": null,
    "description": "",
    "popularity": null,
    "question": "prototype\n chain",
    "type": null
  },
  {
    "id": "rhCq2NEyzUoQT3J0Vx9U",
    "type": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee511"
    },
    "description": "",
    "difficulty": null,
    "popularity": null,
    "answer": {
      "link": [],
      "code": [],
      "text": [
        ""
      ]
    },
    "competence": [],
    "question": "Что\n такое hoisting"
  },
  {
    "id": "rjQ4wX06mvEN87ZGXS97",
    "type": "question",
    "popularity": null,
    "question": "Задача:\n Логическое продолжение предыдущего вопроса — реализовать делегирование.",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "&lt;div\n class=\"wrapper\"&gt; <br>\n &lt;div class=\"child\"&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;click\n me&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; <br>\n &lt;div class=\"child\"&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;click me&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;\n <br>\n &lt;div class=\"child\"&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;click\n me&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; <br>\n &lt;div class=\"other\"&gt;&lt;div&gt;&lt;div&gt;&lt;div&gt;dont't\n click me&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; <br>\n &lt;/div&gt; <br>\n const delegate = (eventName, el, selector, handler) =&gt; { <br>\n el.addEventListener(eventName, (event) =&gt; { <br>\n let node = event.target; <br>\n const items = [].slice.call(el.querySelectorAll(selector)); <br>\n if (items.length) { <br>\n while (node !== el &amp;&amp; node !== null) { <br>\n const isTarget = items.some(item =&gt; node === item); <br>\n <br>\n if (isTarget) { <br>\n handler(node); <br>\n break; <br>\n } else { <br>\n node = node.parentNode; <br>\n } <br>\n } <br>\n } <br>\n }); <br>\n }; <br>\n delegate('click', document.querySelector('.wrapper'), '.child', (el) =&gt;\n el.style.backgroundColor = 'blue'); <br>\n "
      ]
    },
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4b5"
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior"
  },
  {
    "id": "roL6X92DIP4udioxIsam",
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "popularity": null,
    "competence": [],
    "type": null,
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee516"
    },
    "question": "Что\n такое event loop и как мы его используем",
    "difficulty": null
  },
  {
    "id": "s9KHuZXcSqWi6gtOhn03",
    "popularity": null,
    "type": "question",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee444"
    },
    "answer": {
      "link": [],
      "text": [
        "Поднятие\n (hoisting) - это термин, используемый для объяснения поведения объявлений\n переменных в вашем коде. Переменные, объявленные или инициализированные при\n помощи ключевого слова var, будут перемещены в верхнюю часть текущей области,\n что мы называем \"поднятием\". Однако, \"поднимается\" только\n объявление переменной, присвоение значения (если оно имеется) останется на\n прежнем месте. <br>\n Обратите внимание, что объявление фактически не перемещается - движок\n JavaScript анализирует объявления во время компиляции и узнает о объявлениях\n и их областях видимости. Просто легче понять подобное поведение, представляя\n объявления как перемещение наверх своей области видимости. Давайте рассмотрим\n несколько примеров. <br>\n // объявления переменных через var поднимаются. <br>\n console.log(foo); // undefined <br>\n var foo = 1; <br>\n console.log(foo); // 1 <br>\n // объявления переменных через let/const НЕ поднимаются. <br>\n console.log(bar); // ReferenceError: bar is not defined <br>\n let bar = 2; <br>\n console.log(bar); // 2 <br>\n При объявлении функции ее тело поднимается наверх, в то время как у\n функциональных выражений (когда переменной присваивается функция) поднимается\n только переменная. <br>\n // Объявление функции <br>\n console.log(foo); // [Function: foo] <br>\n foo(); // 'FOOOOO' <br>\n function foo() { <br>\n console.log('FOOOOO'); <br>\n } <br>\n console.log(foo); // [Function: foo] <br>\n // Функциональное выражение <br>\n console.log(bar); // undefined <br>\n bar(); // Uncaught TypeError: bar is not a function <br>\n var bar = function() { <br>\n console.log('BARRRR'); <br>\n }; <br>\n console.log(bar); // [Function: bar]"
      ],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "question": "Расскажите,\n что такое поднятие (hoisting)",
    "description": ""
  },
  {
    "id": "sqOmqxop55HZw1v6v9eA",
    "type": null,
    "answer": {
      "code": [],
      "text": [
        ""
      ],
      "link": []
    },
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f9"
    },
    "description": "",
    "popularity": null,
    "difficulty": null,
    "question": "Связные\n списки"
  },
  {
    "id": "t7eDNfspmt7XOelkApnI",
    "popularity": null,
    "type": "question",
    "question": "Что\n будет если задать margin: -10px;",
    "competence": [
      "javascript"
    ],
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ae"
    },
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Сдвинится\n вверх и влево на своих соседей"
      ]
    },
    "difficulty": "junior"
  },
  {
    "id": "tGj90CNmKJD8X7uWPZe3",
    "popularity": null,
    "answer": {
      "link": [],
      "text": [
        "defer\n <br>\n Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать\n страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт,\n когда он загрузится. <br>\n Атрибут async означает, что скрипт абсолютно независим: <br>\n <br>\n Страница не ждёт асинхронных скриптов, содержимое обрабатывается и\n отображается. <br>\n Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга: <br>\n DOMContentLoaded может произойти как до асинхронного скрипта (если асинхронный\n скрипт завершит загрузку после того, как страница будет готова), <br>\n …так и после асинхронного скрипта (если он короткий или уже содержится в\n HTTP-кеше) <br>\n Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.\n <br>\n "
      ],
      "code": []
    },
    "difficulty": "junior",
    "description": "",
    "competence": [
      "javascript"
    ],
    "question": "Объясните\n разницу между &lt;script&gt;, &lt;script async&gt; и &lt;script defer&gt;.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee46d"
    },
    "type": "question"
  },
  {
    "id": "u6WC4mgpIxd6hsRkYnbH",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee501"
    },
    "popularity": null,
    "type": null,
    "competence": [],
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "description": "",
    "question": "Компилятор\n Codegen"
  },
  {
    "id": "uMVyVrx8TikqYTMeEMI8",
    "popularity": null,
    "type": "question",
    "question": "Есть\n массив в котором лежат объекты с датами, отсортировать по датам.",
    "_id": {
      "$oid": "60de0704e2c8c53194aee492"
    },
    "answer": {
      "code": [],
      "text": [
        "var\n arr = [{date: '10.01.2017'}, {date: '05.11.2016'}, {date: '21.13.2002'}];\n <br>\n <br>\n arr.forEach(function(item) { <br>\n var arrDate = item.date.split('.'), <br>\n date = new Date(Number(arrDate[2]), Number(arrDate[1]),\n Number(arrDate[0])); <br>\n item.time = date.getTime(); <br>\n }); <br>\n arr.sort(function (a, b) { <br>\n if (a.time - b.time &lt; 0) { <br>\n return false; <br>\n } else { <br>\n return true; <br>\n } <br>\n }); <br>\n var res = arr.map(function (item) { <br>\n return {date: item.date}; <br>\n }); <br>\n console.log(res); <br>\n "
      ],
      "link": []
    },
    "difficulty": "junior",
    "description": "",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "uWUZko8dD6kom4N2y4ln",
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "Если\n очень кратко и поверхностно, то перед выводом картинки на экран браузер\n проходит 5 стадий, часть из которых может быть опущена: Обработка JS &gt;\n вычисление стилей &gt; расчет макета &gt; прорисовка &gt; компановка. С\n начала отрабатывают скрипты, в результате которых картинка может измениться.\n Далее идет вычисление стилей, чтобы понять, что изменилось и применить данные\n изменения. В свою очередь это может вызвать расчет макета, если были\n затронуты свойства, влияющие на размеры и т.п. элемента. После идет\n прорисовка, если были задеты свойства, вроде изменения цвета, тени и т.п.\n После идет компановка, то бишь сведение всех измененных слоев в правильном\n порядке и выведения их на экран пользователя. <br>\n Изоляция размеров — тот случай, когда у родителя отсутствует указание\n размеров, аля `width: auto; height: auto;` и т.п. В таком случае дочерний\n элемент может повлиять на родительский и изменить (к примеру, увеличить) его\n размеры. Вот `contain: size;` у родителя как раз и не даст этого сделать. <br>\n Ну а по существу, перевод есть перевод и, тем более, первый параграф сего\n ответа не является целью данной статьи, ибо так статьи излишне распухнет.\n <br>\n "
      ]
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "popularity": null,
    "question": "Объясните\n разницу между раскладкой (layout), painting и композитингом (compositing).",
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee47d"
    },
    "difficulty": "junior"
  },
  {
    "id": "uaQ1wnKNmH2huk3NBmUE",
    "_id": {
      "$oid": "60de0704e2c8c53194aee46e"
    },
    "popularity": null,
    "difficulty": "junior",
    "question": "Что\n такое прогрессивная отрисовка?",
    "description": "",
    "type": "question",
    "competence": [
      "javascript"
    ],
    "answer": {
      "code": [],
      "text": [
        "Progressive\n Web App<br>\n Progressive Loading<br>\n Идея прогрессивной загрузки достаточно простая:<br>\n 1. Сделать первоначальную загрузку как можно быстрее<br>\n 2. Загружать UI компоненты только по мере надобности<br>\n "
      ],
      "link": []
    }
  },
  {
    "id": "ujN0ccZ1udAq6KExmBnP",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4c9"
    },
    "answer": {
      "link": [],
      "text": [
        "Задачу\n можно решать различными способами. Обычно хотят узнать знает ли собеседуемый\n такой метод как reduce. <br>\n Идея заключается в том, чтобы обойти все элементы исходного массива и его\n “под массивов” с целью вернуть найденные значения в новый массив. Это\n происходит рекурсивно пока мы не дойдём до последнего элемента. <br>\n Так же с формированием нового массива нам помогает concat. <br>\n Ответ: <br>\n const flatten = (arr) =&gt; arr.reduce((flat, toFlatten) =&gt;\n flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten), []);\n <br>\n "
      ],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "popularity": null,
    "difficulty": "junior",
    "description": "",
    "question": "Объедините\n два массива с вложенностью <br>\n [1, [1, 2, [3, 4]], [2, 4]] -&gt; [1, 1, 2, 3, 4, 2, 4] <br>\n "
  },
  {
    "id": "uyPJUX1bhqjxMsmh5bSn",
    "answer": {
      "text": [
        "Функция\n высшего порядка — это любая функция, которая принимает одну или несколько\n функций в качестве аргументов, которые она использует для работы с данными\n и/или возвращает функцию в качестве результата. Функции высшего порядка\n предназначены для абстрагирования некоторой операции, которая выполняется\n повторно. Классическим примером является метод map, который принимает массив\n и функцию в качестве аргументов. Затем `map` использует эту функцию для\n преобразования каждого элемента в массиве, возвращая новый массив с\n преобразованными данными. Другими популярными примерами в JavaScript являются\n forEach, filter и reduce. Функции высшего порядка используют не только для\n манипуляций с массивами, но также и для возврата функции из другой функции,\n например при использовании Function.prototype.bind. <br>\n Map <br>\n Допустим, у нас есть массив с именами, которые нам нужны о преобразовать в\n верхний регистр. <br>\n const names = ['irish', 'daisy', 'anna']; <br>\n Императивное решение будет выглядеть так: <br>\n const transformNamesToUppercase = function(names) { <br>\n const results = []; <br>\n for (let i = 0; i &lt; names.length; i++) { <br>\n results.push(names[i].toUpperCase()); <br>\n } <br>\n return results; <br>\n }; <br>\n transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA'] <br>\n Воспользууемся .map(transformerFn), чтобы сделать код декларативным и более\n коротким: <br>\n const transformNamesToUppercase = function(names) { <br>\n return names.map(name =&gt; name.toUpperCase()); <br>\n }; <br>\n transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']"
      ],
      "code": [],
      "link": [
        "https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99",
        "https://hackernoon.com/effective-functional-javascript-first-class-and-higher-order-functions-713fde8df50a",
        "https://eloquentjavascript.net/05_higher_order.html"
      ]
    },
    "popularity": null,
    "difficulty": "junior",
    "description": "",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "question": "Дайте\n определение функции высшего порядка",
    "_id": {
      "$oid": "60de0704e2c8c53194aee45c"
    }
  },
  {
    "id": "uzmIdwJdlOPbOlOOdkMx",
    "difficulty": "junior",
    "description": "",
    "question": "Почему\n считается хорошим тоном оставить глобальную область видимости (global scope)\n в нетронутом состоянии?",
    "type": "question",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee44e"
    },
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "text": [
        "Каждый\n скрипт имеет доступ к глобальной области видимости, и если каждый будет\n использовать глобальное пространство имен для определения своих переменных,\n то могут возникнуть конфликты. Используйте модульный паттерн (используя IIFE)\n для инкапсуляции ваших переменных в локальное пространство имен."
      ],
      "code": []
    }
  },
  {
    "id": "vXBGoJn9ZWXGNFBl4eLt",
    "question": "web\n api",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4d9"
    },
    "competence": [],
    "type": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "description": "",
    "popularity": null
  },
  {
    "id": "vgRmreDNrx2CU0YK5oyh",
    "description": "",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "question": "Шаблонные\n строки в ES6 намного упрощают создание строк, можете ли вы привести пример их\n использования?",
    "answer": {
      "text": [
        "Шаблонные\n строки помогают упростить строковую строк или включение переменных в строку.\n До ES2015 писали так: <br>\n var person = { name: ‘Tyler’, age: 28 }; <br>\n console.log(‘Hi, my name is ‘ + person.name + ‘ and I am ‘ + person.age + ‘\n years old!’); <br>\n // ‘Hi, my name is Tyler and I am 28 years old!’ <br>\n С приходом шаблонных строк в ES6 стало намного проще: <br>\n const person = { name: ‘Tyler’, age: 28 }; <br>\n console.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);\n <br>\n // ‘Hi, my name is Tyler and I am 28 years old!’ <br>\n Обратите внимание, что для шаблонных строк используются обратные кавычки, а\n не простые. Переменные добавляются в подстановки ${}, обозначаемые знаком\n доллара и фигурными скобками. <br>\n Второй пример использования заключается в создании многострочных литералов.\n До ES2015 перенос осуществлялся следующим образом: <br>\n console.log(‘This is line one.\\nThis is line two.’); <br>\n // This is line one. <br>\n // This is line two. <br>\n Или же, чтобы не приходилось прокручивать длинную строку в текстовом\n редакторе, можно было разбить код на несколько строк в коде, таким образом:\n <br>\n console.log(‘This is line one.\\n’ + <br>\n ‘This is line two.’); <br>\n // This is line one. <br>\n // This is line two. <br>\n Однако шаблонные строки сохраняют любой интервал, который вы добавляете к\n ним. Например, чтобы создать тот же многострочный литерал, который мы создали\n выше, вы можете просто написать: <br>\n console.log(`This is line one. <br>\n This is line two.`); <br>\n // This is line one. <br>\n // This is line two. <br>\n Еще одним вариантом использования шаблонных строк будет использование в\n качестве замены библиотек шаблонизации для интерполяции переменных: <br>\n const person = { name: ‘Tyler’, age: 28 }; <br>\n document.body.innerHTML = ` <br>\n &lt;div&gt; <br>\n &lt;p&gt;Name: ${person.name}&lt;/p&gt; <br>\n &lt;p&gt;Name: ${person.age}&lt;/p&gt; <br>\n &lt;/div&gt; <br>\n ` <br>\n Обратите внимание, что ваш код может быть восприимчив к XSS при\n использовании .innerHTML. Очищайте ваши данные перед отображением, если они\n получены от пользователя!"
      ],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"
      ],
      "code": []
    },
    "popularity": null,
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee45e"
    }
  },
  {
    "id": "vmGgJKxGXBTA4p28yDdW",
    "difficulty": null,
    "competence": [],
    "type": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "popularity": null,
    "description": "",
    "question": "\n <div style=\"left:3px;overflow:hidden;position:relative\">\n <div style=\"float:left\">D - Dependency inversion principle - decupling</div>\n </div>",
    "_id": {
      "$oid": "60de0704e2c8c53194aee509"
    }
  },
  {
    "id": "w397bBevwzL3ISK59i2J",
    "_id": {
      "$oid": "60de0704e2c8c53194aee488"
    },
    "description": "",
    "answer": {
      "code": [],
      "text": [
        "var\n foo = {n: 1};<br>\n var bar = foo;<br>\n foo.x = foo = {n: 2};<br>\n <br>\n Этот вопрос задают в топ 3% компаний (Apple, Google, Facebook). <br>\n Главное на что здесь стоит обратить внимание, так это то, что foo на\n которую ссылается foo.x “устанавливается” перед тем как foo изменится. foo.x\n ссылается на старое значение foo. <br>\n See section 11.13.1 of the ES5 spec: <br>\n Let lref be the result of evaluating LeftHandSideExpression. <br>\n Let rref be the result of evaluating AssignmentExpression. <br>\n Это значит, что в старом foo появиться новое свойство x равное {n: 2} . А в\n новое foo запишется {n: 2} . <br>\n Значение старого foo находиться в bar: <br>\n // bar <br>\n { <br>\n n: 1, <br>\n x: { <br>\n n: 2 <br>\n } <br>\n } <br>\n Так как при дальнейшем выводе foo.x наше foo ссылается на его новое\n значение, в котором отсутствует x , то соответственно foo.x будет не\n определенно — undefined . <br>\n Ответ: undefined <br>\n "
      ],
      "link": []
    },
    "question": "Чему\n равно foo.x?",
    "difficulty": "junior",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "type": "question"
  },
  {
    "id": "wI0QegcuFAkBUNDcUvfR",
    "difficulty": "junior",
    "competence": [
      "typescript"
    ],
    "description": "",
    "type": "question",
    "answer": {
      "code": [],
      "link": [
        "https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions",
        "https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo"
      ],
      "text": [
        "Они\n могут использоваться в IIFE для инкапсуляции кода в локальную область\n видимости, чтобы объявленные в ней переменные не попадали в глобальную\n область видимости. <br>\n (function() { <br>\n // Здесь код функции. <br>\n })(); <br>\n Как callback-функция, которая используется один раз и не должна\n использоваться где-либо еще. Код будет казаться более автономным и читаемым,\n когда обработчики будут определены прямо внутри вызывающего их кода, а не\n искать в другом месте, чтобы найти тело функции. <br>\n setTimeout(function() { <br>\n console.log('Hello world!'); <br>\n }, 1000); <br>\n Аргументы в конструкциях функционального программирования или Lodash\n (аналогично callback-функциям). <br>\n const arr = [1, 2, 3]; <br>\n const double = arr.map(function(el) { <br>\n return el * 2; <br>\n }); <br>\n console.log(double); // [2, 4, 6]"
      ]
    },
    "popularity": "4",
    "_id": {
      "$oid": "60de0704e2c8c53194aee438"
    },
    "question": "В\n каких случаях обычно используются анонимные функции?"
  },
  {
    "id": "wTWYoGA5gd7tuYb1S2uw",
    "competence": [],
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "description": "",
    "popularity": null,
    "difficulty": null,
    "type": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4e0"
    },
    "question": "hoisting"
  },
  {
    "id": "wpvVkIbBtQKNQINbPz3k",
    "type": "question",
    "question": "Обратная\n польская нотация.",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "answer": {
      "link": [],
      "code": [],
      "text": [
        "var\n notation = '23+1-', notation1 = '7 2 3 * -', notation2 = '1 2 + 4 * 3 +';\n <br>\n function getComputation(notation) { <br>\n var queue = [], tmp, num1, num2; <br>\n for (var i = 0; i &lt; notation.length; i++) { <br>\n if (/\\d+/.test(notation[i]) === true) { <br>\n queue.push(Number(notation[i])); <br>\n } <br>\n else { <br>\n switch (notation[i]) { <br>\n case '+': <br>\n tmp = queue.pop() + queue.pop(); <br>\n queue.push(tmp); <br>\n break; <br>\n case '-': <br>\n num1 = queue.pop(); <br>\n num2 = queue.pop(); <br>\n if (num1 &gt; num2) { <br>\n tmp = num1 - num2; <br>\n } <br>\n else { <br>\n tmp = num2 - num1; <br>\n } <br>\n queue.push(tmp); <br>\n break; <br>\n case '*': <br>\n tmp = queue.pop() * queue.pop(); <br>\n queue.push(tmp); <br>\n break; <br>\n case '/': <br>\n tmp = queue.pop() / queue.pop(); <br>\n queue.push(tmp); <br>\n break; <br>\n } <br>\n } <br>\n } <br>\n return queue[0]; <br>\n } <br>\n console.log(getComputation(notation)); <br>\n console.log(getComputation(notation1)); <br>\n console.log(getComputation(notation2)); <br>\n "
      ]
    },
    "description": "",
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4a4"
    }
  },
  {
    "id": "wwhoJqpXfCXSrmXqLUjp",
    "_id": {
      "$oid": "60de0704e2c8c53194aee44f"
    },
    "difficulty": "junior",
    "question": "Для\n чего используют событие `load`? Есть ли у этого события недостатки? Знаете ли\n вы какие-либо альтернативы, и в каких случаях бы стали их использовать?",
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "answer": {
      "text": [
        "Событие\n load происходит в конце процесса загрузки документа. На этом этапе все\n объекты в документе находятся в DOM, и все изображения, скрипты и ссылки\n загрузились. <br>\n Событие DOM DOMContentLoaded будет запущено после создания DOM для\n страницы, но не будет ждать окончания загрузки других ресурсов. Оно\n предпочтительно в тех случаях, когда вам не нужно загружать страницу целиком\n перед инициализацией."
      ],
      "code": [],
      "link": [
        "https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload"
      ]
    },
    "popularity": null
  },
  {
    "id": "wwx5q46Ig1RIxavtUs7H",
    "type": "question",
    "difficulty": "junior",
    "competence": [
      "javascript"
    ],
    "answer": {
      "text": [
        "mousedown -> mouseMove -> mouseup -> click"
      ],
      "code": [],
      "link": []
    },
    "question": "В каком порядке делать изменение размера колонок?",
    "description": "Типа как в экселе, когда хватаешь колонку и тащишь, а потом отпускаешь.",
    "popularity": "2"
  },
  {
    "id": "x3bSrFhwBy0yU9hVpqkE",
    "type": null,
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ef"
    },
    "description": "",
    "competence": [],
    "popularity": null,
    "answer": {
      "text": [
        ""
      ],
      "link": [],
      "code": []
    },
    "question": "generator\n object"
  },
  {
    "id": "x6YwGOelyu23zeiVfbhh",
    "question": "Какие\n инструменты и методы вы используете при отладке кода?",
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee454"
    },
    "difficulty": "junior",
    "popularity": null,
    "type": "question",
    "answer": {
      "text": [
        "React\n и Redux: <br>\n React Devtools <br>\n Redux Devtools <br>\n Vue: <br>\n Vue Devtools <br>\n JavaScript: <br>\n Chrome Devtools <br>\n Выражение debugger <br>\n Отладка при помощи старого доброго console.log"
      ],
      "code": [],
      "link": [
        "https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d",
        "https://raygun.com/blog/javascript-debugging/"
      ]
    },
    "description": ""
  },
  {
    "id": "xKPZWDUL5cOAcPqfShI3",
    "popularity": null,
    "question": "Контекст\n вызова, arrow function, bind",
    "competence": [],
    "_id": {
      "$oid": "60de0704e2c8c53194aee51f"
    },
    "difficulty": null,
    "type": null,
    "description": "",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        ""
      ]
    }
  },
  {
    "id": "xSAArRdURVBeGSbdtTRV",
    "popularity": null,
    "answer": {
      "code": [],
      "text": [
        "js\n юыстрее"
      ],
      "link": []
    },
    "description": "",
    "_id": {
      "$oid": "60de0704e2c8c53194aee466"
    },
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "question": "Какие\n преимущества и недостатки у CSS и JavaScript анимаций?",
    "type": "question"
  },
  {
    "id": "xfL3IpgRurqablKT0wic",
    "type": null,
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "description": "",
    "question": "Чем\n отличаются друг от друга унарные, бинарные и тернарные операторы",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee510"
    },
    "popularity": null,
    "competence": []
  },
  {
    "id": "xjChUqmq086KpKpPC4Dk",
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "_id": {
      "$oid": "60de0704e2c8c53194aee4f3"
    },
    "question": "Promise",
    "popularity": null,
    "type": null,
    "description": "",
    "difficulty": null,
    "competence": []
  },
  {
    "id": "xm6T9aDRQ8uJDsMCuwzz",
    "popularity": null,
    "competence": [
      "javascript"
    ],
    "_id": {
      "$oid": "60de0704e2c8c53194aee472"
    },
    "difficulty": "junior",
    "type": "question",
    "description": "",
    "question": "В\n чем разница между «сбросом» и «нормализацией» CSS? Что бы вы выбрали и\n почему?",
    "answer": {
      "code": [],
      "link": [],
      "text": [
        "Цели\n normalize.css: <br>\n <br>\n сохранять полезные настройки браузера, а не стирать их; <br>\n нормализовать стили для широкого круга HTML-элементов; <br>\n корректировать ошибки и основные несоответствия браузера; <br>\n совершенствовать юзабилити незаметными улучшениями; <br>\n объяснять код, используя комментарии и детальную документацию. <br>\n "
      ]
    }
  },
  {
    "id": "xrGpWjDUr6cAPosnBgL4",
    "competence": [
      "javascript"
    ],
    "description": "",
    "type": "question",
    "popularity": null,
    "answer": {
      "code": [],
      "text": [
        "На\n сегодняшний день существует три режима отображения, которые используются\n движками разметки (layout engines) браузеров: режим совместимости (quirks\n mode), частично стандартный режим (almost standards mode) и стандартный режим\n (full standards mode). В режиме совместимости (quirks mode), разметка\n эмулирует нестандартное поведение браузеров Navigator 4 и Internet Explorer\n 5. Этот режим необходим для поддержки сайтов, созданных до начала широкого\n применения веб стандартов. В стандартном режиме (full standards mode)\n поведение браузера соответствует (будем надеяться) описанному в спецификациях\n HTML и CSS. В частично стандартном режиме (almost standards mode) реализовано\n лишь незначительное количество так называемых \"странностей\"\n (quirks)."
      ],
      "link": []
    },
    "difficulty": "junior",
    "question": "В\n чем разница между standards mode и quirks mode?",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4ca"
    }
  },
  {
    "id": "yDtZGwF5hlBotdzVNMCi",
    "question": "Какие\n есть falsy значения",
    "type": null,
    "popularity": null,
    "competence": [],
    "answer": {
      "link": [],
      "text": [
        ""
      ],
      "code": []
    },
    "description": "",
    "difficulty": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee50e"
    }
  },
  {
    "id": "yMSxGv2uOPnqhbGhzMQz",
    "description": "",
    "competence": [
      "javascript"
    ],
    "type": "question",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee461"
    },
    "answer": {
      "link": [
        "http://requirejs.org/docs/whyamd.html",
        "https://nodejs.org/docs/latest/api/modules.html",
        "http://2ality.com/2014/09/es6-modules-final.html"
      ],
      "code": [],
      "text": [
        "Это\n зависит от среды выполнения JavaScript. <br>\n На клиенте (в среде браузера), пока переменные/функции объявлены в\n глобальной области видимости (window), все скрипты могут на них ссылаться. В\n качестве альтернативы, используйте Asynchronous Module Definition (AMD) через\n RequireJS для модульного подхода. <br>\n На сервере (Node.js) обычно используется CommonJS. Каждый файл считается\n модулем, и он может экспортировать переменные и функции, добавляя их к\n объекту module.exports. <br>\n ES2015 позволяет использовать модульный синтаксис, который призван заменить\n как AMD, так и CommonJS. В конечном итоге он будет поддерживаться как в\n браузере, так и в Node. <br>\n "
      ]
    },
    "question": "Каким\n образом можно обмениваться кодом между файлами?",
    "difficulty": "junior"
  },
  {
    "id": "yZSuh13seqyyTn4kMCFw",
    "competence": [
      "javascript"
    ],
    "question": "Как\n сделать, чтобы это выражение работало?",
    "description": "",
    "popularity": null,
    "_id": {
      "$oid": "60de0704e2c8c53194aee483"
    },
    "difficulty": "junior",
    "answer": {
      "text": [
        "add(2,\n 5); // 7 <br>\n add(2)(5); // 7 <br>\n "
      ],
      "code": [],
      "link": []
    },
    "type": "question"
  },
  {
    "id": "zAS6bg5r1ZXX9JRNYQnx",
    "answer": {
      "text": [
        "function\n makeArmy() { <br>\n let shooters = []; <br>\n for(let i = 0; i &lt; 10; i++) { <br>\n let shooter = function() { // функция shooter <br>\n alert( i ); // должна выводить порядковый номер <br>\n }; <br>\n shooters.push(shooter); <br>\n } <br>\n return shooters; <br>\n } <br>\n let army = makeArmy(); <br>\n "
      ],
      "link": [],
      "code": []
    },
    "competence": [
      "javascript"
    ],
    "type": "question",
    "question": "армия\n функций",
    "tableIndex": 244,
    "difficulty": "junior",
    "description": "Армию функцию мне запили",
    "popularity": "3",
    "_id": {
      "$oid": "60de0704e2c8c53194aee4cf"
    }
  },
  {
    "id": "zLWnQ9XVxPgrtofXOiB4",
    "difficulty": "junior",
    "description": "",
    "answer": {
      "link": [],
      "text": [
        "Разницу\n между Expires, Date, Age и If-Modified-… <br>\n Expires: Tue, 31 Jan 2012 15:02:53 GMT <br>\n Дата предполагаемого истечения срока актуальности сущности. <br>\n Date: Tue, 15 Nov 1994 08:12:31 GMT <br>\n Дата генерации отклика. <br>\n If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT <br>\n Дата. Выполнять метод если сущность изменилась с указанного момента. <br>\n Do Not Track <br>\n При включении этой опции браузеры будут посылать в http-заголовках запрос\n “Do Not Track” для того, чтобы ваши действия не отслеживались сайтом и\n третьими сторонами на нем (например, аналитическими и рекламными системами).\n <br>\n Cache-Control <br>\n Общий заголовок Cache-Control используется для задания инструкций\n кэширования как для запросов, так и для ответов. Инструкции кэширования\n однонаправленные: заданная инструкция в запросе не подразумевает, что такая\n же инструкция будет указана в ответе <br>\n Transfer-Encoding <br>\n механизм передачи данных в протоколе передачи гипертекста (HTTP),\n позволяющий надёжно доставлять данные от сервера клиенту (чаще всего\n клиентскому web-браузеру) без необходимости заранее знать точный размер всего\n тела HTTP-сообщения. Это достигается разбиением сообщения на небольшие части\n (chunks), а затем передачей каждой части с указанием только её размера (в\n шестнадцатеричном виде). Окончание передачи сообщения определяется наличием\n последней части с нулевой длиной. <br>\n Etag (или entity tag) — один из механизмов кэширования в HTTP. По сути это\n идентификатор, который присваивается файлу сервером для последующей проверки.\n <br>\n Когда клиент запрашивает файлы веб-страницы (картинки, CSS и т.д), сервер\n передает все данные вместе с тэгами Etag в виде: ETag:\n \"6d82cbb050ddc7fa9cbb659014546e59\" <br>\n Файлы сохраняются в кэше на стороне клиента, и когда браузер запрашивает\n эти файлы снова, то к запросу добавляется строка If-None-Match:\n If-None-Match: \"6d82cbb050ddc7fa9cbb659014546e59\" <br>\n Сервер, в свою очередь, проверяет Etag, если он совпадает, то в ответ\n сервер отправляет код 304:HTTP/1.1 304 Not Modified Иначе требуемые файлы\n будут заново отправлены. <br>\n X-Frame-Options <br>\n Заголовок X-Frame-Options со стороны сервера может разрешать или запрещать\n отображение страницы внутри фрейма. <br>\n Это должен быть именно HTTP-заголовок: браузер проигнорирует его, если\n найдёт в HTML-теге &lt;meta&gt;. Поэтому при &lt;meta\n http-equiv=\"X-Frame-Options\"...&gt; ничего не произойдёт. <br>\n Заголовок может иметь 3 значения: <br>\n DENY <br>\n Никогда не показывать страницу внутри фрейма. <br>\n SAMEORIGIN <br>\n Разрешить открытие страницы внутри фрейма только в том случае, если\n родительский документ имеет тот же источник. <br>\n ALLOW-FROM domain <br>\n Разрешить открытие страницы внутри фрейма только в том случае, если\n родительский документ находится на указанном в заголовке домене."
      ],
      "code": []
    },
    "popularity": null,
    "question": "Опишите\n следующие заголовки HTTP-запросов и ответов:",
    "_id": {
      "$oid": "60de0704e2c8c53194aee47f"
    },
    "type": "question",
    "competence": [
      "javascript"
    ]
  },
  {
    "id": "zPyUWR6P5vjeh5wMcbow",
    "description": "",
    "type": "question",
    "popularity": null,
    "answer": {
      "text": [
        "Поскольку,\n мы работаем с числами, надо расширить прототип Number новыми методами. <br>\n Number.prototype.plus = function (value) { <br>\n return this + value; <br>\n } <br>\n <br>\n Number.prototype.minus = function (value) { <br>\n return this - value; <br>\n }"
      ],
      "link": [],
      "code": []
    },
    "question": "Реализовать\n методы, которые в процессе выполнения строки (2).plus(3).minus(1) дали бы на\n выходе 4.",
    "competence": [
      "javascript"
    ],
    "difficulty": "junior",
    "_id": {
      "$oid": "60de0704e2c8c53194aee48a"
    }
  }
]
